<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a81f8d07405397122ace4236bd53c12c4a00f69" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78808611" /></Metadata><TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <TypeSignature Language="F#" Value="type PropertyMetadata = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>登録時の条件など、特定の種類に適用されるときの依存関係プロパティの動作を定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティメタデータは、<xref:System.Windows.DependencyProperty.Register%2A> メソッド (または添付プロパティまたは読み取り専用の依存関係プロパティのバリエーション) を呼び出すとき、または <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> メソッドを呼び出すときに元の所有者の登録後に、依存関係プロパティの登録時に定義および使用できます。 <xref:System.Windows.DependencyProperty.AddOwner%2A> は、プロパティのメタデータも受け取ります。  
  
 このクラスは、これらの各呼び出しで使用できる具象基本クラスです。 ただし、<xref:System.Windows.FrameworkPropertyMetadata>などの派生クラスのいずれかを使用してメタデータを指定することは非常に一般的です。 これらの派生クラスは、ブール型プロパティ値として格納されるより詳細なメタデータをサポートします。これは、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] framework レベルでのみ実装されるプロパティシステムとレイアウト動作を検出または有効にするのに役立ちます。  
  
 このクラスのいくつかのプロパティは、オブジェクトモデルへの読み取り/書き込みですが、<xref:System.Windows.DependencyProperty.Register%2A> や <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>などのプロパティシステム操作で使用されているインスタンスの前にのみ書き込むことができます。 これらの各プロパティは、コンストラクターによって設定されている場合もありますが、<xref:System.Windows.PropertyMetadata.Merge%2A> メソッドの実装で設定できるように公開されています。  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 この型と、この型のメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティに指定する既定値。通常、特定の型の値として指定されます。</param>
        <summary>メタデータが適用される依存関係プロパティの指定した既定値を使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用される依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります (不一致によって実行時例外が発生します)。  
  
 パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を指定することはできません。 これを行おうとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した既定値と <see cref="T:System.Windows.PropertyMetadata" /> 実装参照を使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `defaultValue` 提供された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用される依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります (不一致によって実行時例外が発生します)。  
  
 パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を指定することはできません。 これを行おうとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, propertyChangedCallback As PropertyChangedCallback, coerceValueCallback As CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.PropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.PropertyMetadata" Usage="new System.Windows.PropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照です。</param>
        <param name="coerceValueCallback">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照です。</param>
        <summary>指定した既定値とコールバックを使用して、<see cref="T:System.Windows.PropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyChangedCallback>ではなく <xref:System.Windows.CoerceValueCallback> を指定する場合は、`propertyChangedCallback` パラメーターに `null` を渡すことができます。  
  
 `defaultValue` に対して指定された値の型は、このメタデータが適用される依存関係プロパティの元の登録で指定されている型と一致しているか、その型に関連付けられている必要があります。 メタデータの既定値の型と、それが適用される依存関係プロパティの型が一致しない場合、コンパイル中に不一致が検出されないため、デバッグが困難になる可能性があります (不一致によって実行時例外が発生します)。  
  
 パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を指定することはできません。 これを行おうとすると、例外が発生します。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> は値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CoerceValueCallback : System.Windows.CoerceValueCallback with get, set" Usage="System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータに指定されている <see cref="T:System.Windows.CoerceValueCallback" /> 実装への参照を取得または設定します。</summary>
        <value><see cref="T:System.Windows.CoerceValueCallback" /> 実装参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティメタデータのコールバックは、通常、含んでいる型のパブリックメンバーではないため、既存の依存関係プロパティのメタデータを使用するだけのほとんどのシナリオでは、このプロパティの値は重要ではありません。 このプロパティが公開される理由の1つは、基本メタデータとオーバーライド/追加メタデータの両方で <xref:System.Windows.CoerceValueCallback>が指定されている場合に、メタデータサブクラスが必要なマージロジックを実行できるようにするためです。 ただし、<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> の既定のマージロジックでは、前のロジックが置き換えられます。  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> は、オブジェクトモデルで読み取り/書き込み可能として定義されます。 これは、<xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後に <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> を調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになりました。 このメタデータインスタンスに `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> を設定しようとすると、例外が発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultValue : obj with get, set" Usage="System.Windows.PropertyMetadata.DefaultValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの既定値を取得または設定します。</summary>
        <value>プロパティの既定値です。 パラメーターなしのコンストラクターを使用して作成された <see cref="T:System.Windows.PropertyMetadata" /> インスタンスの既定値は <see cref="F:System.Windows.DependencyProperty.UnsetValue" />されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> は、オブジェクトモデルで読み取り/書き込み可能として定義されます。 これは、<xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後に <xref:System.Windows.PropertyMetadata.DefaultValue%2A> を調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになりました。 このメタデータインスタンスに `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> <xref:System.Windows.PropertyMetadata.DefaultValue%2A> を設定しようとすると、例外が発生します。  
  
 パラメーターなしのコンストラクターでは既定値ですが、<xref:System.Windows.PropertyMetadata.DefaultValue%2A> またはコンストラクターを使用して <xref:System.Windows.DependencyProperty.UnsetValue> の `defaultValue` を設定することはできません。 これを行おうとすると、例外が発生します。  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用  
 この型のメンバーは、通常、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">いったん作成した後は、値 <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定できません。</exception>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.PropertyMetadata.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータが何らかの方法でプロパティに適用されていて、該当のメタデータ インスタンスが不変の状態にあるかどうかを判断する値を取得します。</summary>
        <value>メタデータ インスタンスが不変の状態の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>などの <xref:System.Windows.PropertyMetadata>のさまざまなプロパティは、オブジェクトモデルで読み取り/書き込み可能として定義されます。 これは、これらのプロパティを <xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後で調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として依存関係プロパティに適用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになります。 これらの呼び出しのいずれかの時点で、<xref:System.Windows.PropertyMetadata.OnApply%2A> が呼び出され、このプロパティの値は `true`に設定されます。  
  
   
  
## Examples  
 次の例では、カスタムメタデータプロパティの設定操作の前に <xref:System.Windows.PropertyMetadata.IsSealed%2A> を確認します。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="propertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">このインスタンスの値とマージする基本メタデータ。</param>
        <param name="dp">このメタデータが適用される依存関係プロパティ。</param>
        <summary>このメタデータと基本メタデータをマージします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、メタデータがオーバーライドされるときに内部的に使用されます (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> メソッド)。  
  
   
  
## Examples  
 次の例では、プロパティメタデータに追加のプロパティを追加するカスタムメタデータ型のマージを実装します。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.PropertyMetadata" /> から派生するクラス実装では、実装に追加したメタデータプロパティを考慮するために、このメソッドをオーバーライドする必要があります。 たとえば、実装によって新しいフラグ列挙値が追加されている場合、<see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> の実装では、これらのフラグを正しく組み合わせることができる必要があります。  
  
基本実装では <see cref="T:System.Windows.PropertyMetadata" /> 型で既に定義されているすべてのプロパティの結合が処理されるため、実装コードの前に常に基本実装を呼び出してください。  
  
マージの正確な動作はユーザーによって設定されます。 値を組み合わせるか、派生メタデータが既定値のままである場合は基本値に戻すか、または特定のメタデータクラスに追加したプロパティの型に基づいて他の多くの動作を指定するかを選択できます。</para></block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="propertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">メタデータが適用された依存関係プロパティ。</param>
        <param name="targetType">該当するメタデータが型固有のメタデータの場合、このメタデータに関連付けられている型。 これが既定のメタデータの場合、この値は null 参照です。</param>
        <summary>このメタデータがプロパティに適用されたときに呼び出され、メタデータがシールされることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サブクラスを使用すると、<xref:System.Windows.PropertyMetadata.OnApply%2A> が呼び出された後に、<xref:System.Windows.PropertyMetadata> サブクラスのデータ構造のすべての変更性を変更不可としてマークする必要があります。 この値は、メタデータがプロパティシステム操作に適用されると呼び出されます (レジスタ、所有者の追加、メタデータのオーバーライド)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyChangedCallback : System.Windows.PropertyChangedCallback with get, set" Usage="System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータに指定されている <see cref="T:System.Windows.PropertyChangedCallback" /> 実装への参照を取得または設定します。</summary>
        <value><see cref="T:System.Windows.PropertyChangedCallback" /> 実装参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティメタデータ内のコールバックは、通常、定義型のパブリックメンバーではないため、既存の依存関係プロパティのメタデータを使用するだけのほとんどのシナリオでは、このプロパティの値は重要ではありません。 このプロパティが公開される理由の1つは、基本メタデータとオーバーライド/追加メタデータの両方で <xref:System.Windows.PropertyChangedCallback>が指定されている場合に、メタデータクラスが必要なマージロジックを実行できるようにするためです。 の既定のマージロジックでは、テーブル内のすべての <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> の実装を保持し、それぞれを呼び出します。また、最初に階層内の最上位のクラスによって確立されたコールバックを使用します。  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> は、オブジェクトモデルで読み取り/書き込み可能として定義されます。 これは、<xref:System.Windows.PropertyMetadata> オブジェクト自体を初期化した後に <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> を調整できるようにするためです。 ただし、メタデータが <xref:System.Windows.DependencyProperty.Register%2A>、<xref:System.Windows.DependencyProperty.AddOwner%2A>、または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しの一部として使用されると、プロパティシステムによってそのメタデータインスタンスが封印され、プロパティが不変と見なされるようになりました。 このメタデータインスタンスに `true` <xref:System.Windows.PropertyMetadata.IsSealed%2A> <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> を設定しようとすると、例外が発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">依存関係プロパティの操作にいったん適用した後は、メタデータのプロパティを設定できません。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
