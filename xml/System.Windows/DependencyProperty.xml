<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="98d26600187a9167e7848ac403e5d62c852a04e1" /><Meta Name="ms.sourcegitcommit" Value="9058026d5788c19bed0a767fc52b40a1eac8ebfe" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/24/2019" /><Meta Name="ms.locfileid" Value="72848312" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スタイル設定、データ バインディング、アニメーション、および継承などの方法によって設定できるプロパティを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty> は、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]の次の機能をサポートしています。  
  
-   プロパティは、スタイルで設定できます。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
-   プロパティは、データバインディングを使用して設定できます。 データバインディングの依存関係プロパティの詳細については、「[方法:](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)2 つのコントロールのプロパティをバインドします。  
  
-   プロパティは、動的リソース参照を使用して設定できます。 詳細については、「[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
-   プロパティは、要素ツリー内の親要素から自動的に値を継承できます。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
-   プロパティはアニメーション化できます。 詳しくは、「 [アニメーションの概要](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)」をご覧ください。  
  
-   プロパティは、プロパティの前の値が変更されたときに報告でき、プロパティ値を強制的に変更できます。 詳しくは、「[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。  
  
-   プロパティは [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]に情報を報告します。たとえば、プロパティ値を変更する場合は、レイアウトシステムが要素のビジュアルを再構成する必要があるかどうかなどです。  
  
-   プロパティは、[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]でサポートを受け取ります。  たとえば、プロパティは **[プロパティ]** ウィンドウで編集できます。  
  
 依存関係プロパティの詳細については、「[依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)」を参照してください。 カスタム型のプロパティで前の一覧の機能をサポートするには、依存関係プロパティを作成する必要があります。  カスタム依存関係プロパティを作成する方法については、「[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)」を参照してください。  
  
 添付プロパティは、任意のオブジェクトが添付プロパティを定義する型に情報を報告できるようにするプロパティです。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]では、型がプロパティを定義する型から継承するかどうかに関係なく、<xref:System.Windows.DependencyObject> から継承されるすべての型で、添付プロパティを使用できます。 添付プロパティは、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 言語の機能です。  [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]で添付プロパティを設定するには、 *ownerType*を使用します。*propertyName*構文。 添付プロパティの例としては、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> プロパティがあります。 すべての <xref:System.Windows.DependencyObject> 型で使用できるプロパティを作成する場合は、添付プロパティを作成する必要があります。 添付プロパティの作成方法など、添付プロパティの詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```xaml 
<object property="dependencyPropertyName"/>  
```

- または -

```xaml
<object property="ownerType.dependencyPropertyName"/>  
```

- または -

```xaml
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 値  
 `dependencyPropertyName`  
 目的の依存関係プロパティの <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> を指定する文字列。 このプロパティが既定の XML 名前空間にない場合は、前に XML 名前空間プレフィックスを付けることができます (詳細については、「 [WPF xaml の Xaml 名前空間と名前空間のマッピング](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)」を参照してください)。  
  
 `ownerType`.`dependencyPropertyName`  
 依存関係プロパティの所有者の種類、ドット (.)、<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>を指定する文字列。 `ownerType` の前に XML 名前空間プレフィックスを付けることもできます。 この使用法は、遅延バインディングされたスタイルとテンプレートに固有のものであり、`TargetType` がまだ知られていないため、コンテキストを解析するために依存関係プロパティの所有者を指定する必要があります。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
 `attachedPropertyOwnerType` *のハッシュ コードを返します。* `attachedPropertyName`  
 添付プロパティの所有者、ドット (.)、添付プロパティ名を指定する文字列。 `attachedPropertyOwnerType` の前に XML 名前空間プレフィックスを付けることもできます。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に登録済みの依存関係プロパティの所有者として、ある型に別の型を追加します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">この依存関係プロパティの所有者として追加する型。</param>
        <summary>登録済みの依存関係プロパティの所有者として、別の型を追加します。</summary>
        <returns>依存関係プロパティを識別する元の <see cref="T:System.Windows.DependencyProperty" /> 識別子への参照。 この識別子は、追加するクラスが <see langword="public static readonly" /> フィールドとして公開する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、プロパティシステムは、特定の依存関係プロパティを最初に登録しなかった型の依存関係プロパティを認識できます。  
  
 通常、<xref:System.Windows.DependencyProperty.AddOwner%2A> は、マネージクラスの継承によって依存関係プロパティを公開していないクラスに依存関係プロパティを追加するために使用されます (クラスの継承によって、ラッパープロパティが派生クラスに継承されるため、[全般メンバー] を指定します。依存関係プロパティへのテーブルアクセスは既に存在します)。 <xref:System.Windows.DependencyProperty.AddOwner%2A> を使用すると、プロパティシステムは、その依存関係プロパティを最初に登録しなかった型の依存関係プロパティを認識できます。  
  
 この署名では、メタデータを指定することはできません。  このメソッドを使用すると、新しい <xref:System.Windows.DependencyProperty> とその所有者の種類に対してメタデータが自動的に生成されます。 自動生成されるメタデータは、このプロパティが定義されているすべての基本型からのマージされたメタデータの結果です。 結合されたメタデータが使用できない場合は、プロパティの既定のメタデータが使用されます。 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> メソッドを使用してプロパティが登録されている場合、既定のメタデータは <xref:System.Windows.DependencyProperty.RegisterAttached%2A> が呼び出されたときに作成されたメタデータと同じになります。 それ以外の場合、<xref:System.Windows.PropertyMetadata> オブジェクトは、プロパティ型の default に設定された <xref:System.Windows.PropertyMetadata.DefaultValue%2A> プロパティを使用して作成され、<xref:System.Windows.PropertyMetadata> の他のすべてのプロパティは `null`に設定されます。 指定された型に追加された依存関係プロパティのバージョンにメタデータを提供する場合は、<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> シグネチャを使用します。  
  
 通常、このメソッドの戻り値は、依存関係プロパティの識別子を格納することによって、依存関係プロパティを宣言および公開するために使用されます。 この識別子は、依存関係プロパティに対してプロパティシステム Api を呼び出す場合 (特に、追加所有者クラスに存在する場合) に、依存関係プロパティへのアクセスを提供します。 同様の機能を示すには、元の所有者と追加された所有者の両方に同じプロパティ名を使用する必要があります。 <xref:System.Windows.DependencyProperty.AddOwner%2A> メソッドの <xref:System.Windows.DependencyProperty> 戻り値を使用して依存関係プロパティ識別子を定義し、<xref:System.Windows.DependencyProperty.AddOwner%2A>を使用して型に追加される依存関係プロパティの [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] プロパティラッパーを宣言する必要があります。  
  
 前述の <xref:System.Windows.DependencyProperty.AddOwner%2A> 方法は、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]内で宣言された依存関係プロパティを作成するときに使用します。 たとえば、<xref:System.Windows.Controls.Border> と <xref:System.Windows.Controls.Control> の両方で、類似した機能を持つ `BorderBrush` 依存関係プロパティが定義されています。 <xref:System.Windows.Controls.Control> は、元の所有者 <xref:System.Windows.Controls.Border> および登録されている <xref:System.Windows.Controls.Border.BorderBrushProperty> 依存関係プロパティの識別子に基づいて <xref:System.Windows.DependencyProperty.AddOwner%2A> を呼び出すことによって、`BorderBrush` プロパティをプロパティシステムに定義します。 その後 <xref:System.Windows.DependencyProperty.AddOwner%2A> 戻り値を使用して、追加された所有者のそのプロパティに対して新しい静的な <xref:System.Windows.DependencyProperty> フィールド (<xref:System.Windows.Controls.Control.BorderBrushProperty>) が確立され、`BorderBrush` プロパティラッパーも宣言されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">この依存関係プロパティの所有者として追加する型。</param>
        <param name="typeMetadata">提供される型に存在する依存関係プロパティを修飾するメタデータ。</param>
        <summary>既に登録済みの依存関係プロパティの所有者として別の型を追加します。その際、提供される所有者の型に存在する依存関係プロパティに依存関係プロパティのメタデータを提供します。</summary>
        <returns>依存関係プロパティを識別する元の <see cref="T:System.Windows.DependencyProperty" /> 識別子への参照。 この識別子は、追加するクラスが <see langword="public static readonly" /> フィールドとして公開する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、プロパティシステムは、特定の依存関係プロパティを最初に登録しなかった型の依存関係プロパティを認識できます。  
  
 このメソッドの戻り値は、依存関係プロパティを宣言および公開するために使用されます。これは、特に、追加する所有者クラスに存在するためです。 通常は、元の所有者と追加された所有者の両方に同じプロパティ名を使用して、同様の機能を示す必要があります。 <xref:System.Windows.DependencyProperty.AddOwner%2A>を使用して型に追加される依存関係プロパティについては、新しい [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] プロパティラッパーと同様に、識別子を公開することをお勧めします。  
  
 前述の <xref:System.Windows.DependencyProperty.AddOwner%2A> 方法は、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]内で宣言された Api を作成するときに使用します。 たとえば、<xref:System.Windows.Controls.Border> と <xref:System.Windows.Controls.Control> の両方で、類似した機能を持つ `BorderBrush` 依存関係プロパティが定義されています。 <xref:System.Windows.Controls.Control> は、元の所有者 <xref:System.Windows.Controls.Border> および登録されている <xref:System.Windows.Controls.Border.BorderBrushProperty> 依存関係プロパティの識別子に <xref:System.Windows.DependencyProperty.AddOwner%2A> を呼び出すことによって、`BorderBrush` プロパティをプロパティシステムに定義します。 次に、<xref:System.Windows.DependencyProperty.AddOwner%2A> 戻り値を使用して、追加された所有者のプロパティに対して静的な <xref:System.Windows.DependencyProperty> フィールド (<xref:System.Windows.Controls.Control.BorderBrushProperty>) が確立され、`BorderBrush` プロパティラッパーも宣言されます。  
  
 追加された所有者の依存関係プロパティ識別子は、<xref:System.Windows.DependencyObject.GetValue%2A>などの操作に使用する必要があります。 ただし、異なるメタデータを持つ所有者として追加されたクラスの型またはインスタンスに関係する型固有の操作では、元の (追加された所有者ではない) 依存関係プロパティの識別子がで指定されている場合でも、期待どおりの結果が返されます。<xref:System.Windows.DependencyObject.GetValue%2A> や <xref:System.Windows.DependencyProperty.GetMetadata%2A>などのメソッドの呼び出し。 追加された所有者のメタデータは <xref:System.Windows.DependencyProperty.AddOwner%2A> 呼び出し自体によってこれらされ、必ずしも [所有者クラス識別子の追加] フィールドによって排他的に参照されるわけではありません。 ただし、<xref:System.Windows.DependencyProperty.AddOwner%2A>を使用して型に追加される依存関係プロパティについては、識別子と新しい [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] プロパティラッパーを公開することをお勧めします。そうしないと、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] との間に不一致が生じ、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]プロパティの表現。  
  
 指定されたメタデータは、基本所有者に存在する依存関係プロパティのプロパティメタデータとマージされます。 元の基本メタデータで指定されたすべての特性が保持されます。 新しいメタデータで特に変更された特性だけが、基本メタデータの特性を上書きします。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>などの一部の特性は、新しいメタデータで指定されている場合に置き換えられます。 その他 (<xref:System.Windows.PropertyChangedCallback>など) は結合されます。 最終的には、マージ動作はオーバーライドに使用されているプロパティメタデータ型によって異なるため、ここで説明する動作は、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 依存関係プロパティで使用される既存のプロパティメタデータクラスに関するものです。 詳細については、「[依存関係プロパティのメタ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)データ」および「[フレームワークプロパティメタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの既定のメタデータを取得します。</summary>
        <value>依存関係プロパティの既定のメタデータ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のメタデータは、明示的な <xref:System.Windows.DependencyProperty.Register%2A> または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 呼び出しによって代替メタデータが指定されていない場合に、その特定のオブジェクトまたは派生型のオブジェクトで使用できるプロパティメタデータです。  
  
 元の所有者が、依存関係プロパティを確立した最初の <xref:System.Windows.DependencyProperty.Register%2A> 呼び出しにメタデータを適用した場合、そのメタデータは <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>として返されます。  
  
 元の <xref:System.Windows.DependencyProperty.Register%2A> の呼び出しでメタデータが適用されていない場合は、<xref:System.Windows.DependencyProperty.Register%2A> 呼び出し内から既定のメタデータが生成され、この値が <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>として返されます。  
  
 <xref:System.Windows.DependencyProperty> に既定のメタデータを関連付ける主な目的は、<xref:System.Windows.DependencyObject> または派生型のこのプロパティに既定値を指定することです。  
  
 非添付プロパティの場合、このプロパティによって返されるメタデータ型を <xref:System.Windows.PropertyMetadata> 型の派生型にキャストすることはできません。これは、プロパティが最初に派生メタデータ型に登録されていた場合でも同様です。 最初に登録されたメタデータを元のメタデータ型として使用する場合は、代わりに <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> を呼び出し、元の登録型をパラメーターとして渡します。  
  
 添付プロパティの場合、このプロパティによって返されるメタデータの型は、元の <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 登録方法で指定された型と一致します。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Windows.DependencyProperty" /> のハッシュ コードを返します。</summary>
        <returns>この <see cref="T:System.Windows.DependencyProperty" /> のハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティシステムは独自の一意の識別子 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>を使用し、そのプロパティの値は <xref:System.Windows.DependencyProperty.GetHashCode%2A>によって返されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>特定の型のメタデータが存在する場合、この依存関係プロパティに関連付けられているメタデータを返します。 依存関係プロパティが最初に登録された型、その後で依存関係プロパティが追加された型、または継承を通じて依存関係プロパティが取得され、そのメタデータが明確にオーバーライドされた型を指定できます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">依存関係プロパティのメタデータを取得する対象の特定の型。</param>
        <summary>指定した既存の型に存在する場合の、この依存関係プロパティのメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型として使用する型またはオブジェクト参照のいずれかを指定する必要があります。これは、型に存在する依存関係プロパティのメタデータを変更する <xref:System.Windows.DependencyProperty.AddOwner%2A> または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 呼び出しが原因で、メタデータが元の登録と異なる可能性があるためです。  
  
   
  
## Examples  
 次の例では、型に基づいて依存関係プロパティのメタデータを取得します。 型を取得するには、`typeof` 演算子を使用します。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">メタデータの取得元となる依存関係プロパティの型固有のバージョンを確認するために型をチェックするときの、対象となる依存関係オブジェクト。</param>
        <summary>この依存関係プロパティのメタデータが指定したオブジェクト インスタンスに存在する場合に、このメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定の依存関係プロパティのメタデータは、型に存在するときにプロパティメタデータを調整できる <xref:System.Windows.DependencyProperty.AddOwner%2A> または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 呼び出しによって、元の登録と異なる可能性があるため、型またはオブジェクト参照のいずれかを指定する必要があります。  
  
 インスタンスに基づいてプロパティメタデータを要求する場合は、その型を内部で評価できるようにインスタンスを渡すだけです。 依存関係プロパティのメタデータは、インスタンスごとに異なります。任意の型プロパティの組み合わせに対して常に一貫しています。  
  
   
  
## Examples  
 次の例では、特定の <xref:System.Windows.DependencyObject> インスタンスに基づいて、依存関係プロパティのメタデータを取得します。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">依存関係プロパティ メタデータの取得元となる依存関係オブジェクト型を記録する特定のオブジェクト。</param>
        <summary>指定した型に存在する場合の、この依存関係プロパティのメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定の依存関係プロパティのメタデータは、型に存在するときにプロパティメタデータを調整できる <xref:System.Windows.DependencyProperty.AddOwner%2A> または <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 呼び出しによって、元の登録と異なる可能性があるため、型またはオブジェクト参照のいずれかを指定する必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.DependencyObjectType>に基づいて依存関係プロパティのメタデータを取得します。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティを一意に識別する内部的に生成された値を取得します。</summary>
        <value>一意の数値識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値は整数であり、グローバル一意識別子 (GUID) ではありません。 一般に、このインデックス値の使用は必須ではなく、すべての依存関係プロパティのテーブルへのインデックスアクセスはありません。 依存関係プロパティは、その識別子フィールドによって参照される必要があります。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> は、<xref:System.Windows.DependencyProperty.GlobalIndex%2A> を0から始まる配列インデックスとして使用するデータ構造に高速にアクセスするために、内部的に使用されます。 同様の使用方法には、デザイナーまたはツールのアプリケーションが含まれる場合があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">確認する値。</param>
        <summary>指定した値がこの依存関係プロパティの型で受け入れ可能かどうかを、依存関係プロパティの最初の登録で指定されたプロパティの型と照合することによって判断します。</summary>
        <returns>指定した値が登録済みのプロパティ型であるか、または受け入れ可能な派生型である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `null` の値は参照型の依存関係プロパティ、または <xref:System.Nullable%601> 依存関係プロパティの有効な型であり、このような場合には `true` を返します。 依存関係プロパティが参照でも <xref:System.Nullable%601> 型でもない場合、<xref:System.Windows.DependencyProperty.IsValidType%2A> は例外を発生させるのではなく、null 値に対して `false` を返します。  
  
   
  
## Examples  
 次の例では、依存関係プロパティで <xref:System.Windows.DependencyObject.SetValue%2A> を呼び出す前に、チェックとして <xref:System.Windows.DependencyProperty.IsValidType%2A> を使用します。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">確認する値。</param>
        <summary>指定した値がプロパティの型で受け入れ可能かどうかを基本型チェックによって判断します。さらに、その型の有効値の範囲内にこの値があるかどうかを判断することもあります。</summary>
        <returns>値が受け入れ可能で、適切な型または派生型である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの場合は、依存関係プロパティの登録で指定されている <xref:System.Windows.ValidateValueCallback> を使用して、その型の許容範囲の値を指定できます。  
  
 このメソッドは <xref:System.Windows.DependencyProperty.IsValidType%2A> を内部的に呼び出します。 対象の依存関係プロパティに <xref:System.Windows.ValidateValueCallback>がない場合、このメソッドを呼び出すことは、実質的に <xref:System.Windows.DependencyProperty.IsValidType%2A>呼び出しと同じです。 依存関係プロパティに <xref:System.Windows.ValidateValueCallback>があり、<xref:System.Windows.DependencyProperty.IsValidType%2A> が `true`を返した場合、返される値はコールバックに実装されます。  
  
 Null 値は参照型の依存関係プロパティ、または <xref:System.Nullable%601> 依存関係プロパティの有効な値であり、このような場合に `true` を返します。 依存関係プロパティが参照でも <xref:System.Nullable%601> 型でもない場合、<xref:System.Windows.DependencyProperty.IsValidType%2A> は例外を発生させるのではなく、null 値に対して `false` を返します。  
  
   
  
## Examples  
 次の例では、依存関係プロパティで <xref:System.Windows.DependencyObject.SetValue%2A> を呼び出す前に、チェックとして <xref:System.Windows.DependencyProperty.IsValidValue%2A> を使用します。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの名前を取得します。</summary>
        <value>プロパティの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、依存関係プロパティの登録時に `name` パラメーターとして指定された名前を取得します。 この名前は不変であり、`null` または空の文字列にすることはできません。 同じ所有者の種類で重複する名前の登録は許可されていません。重複したを登録しようとすると、例外がスローされます。  
  
> [!IMPORTANT]
>  依存関係プロパティの <xref:System.Windows.DependencyProperty.Name%2A> は、依存関係プロパティの識別子の名前とサフィックス "Property" の組み合わせの規則に従う必要があります。 詳細については、「[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、依存関係プロパティ識別子のさまざまな特性 (<xref:System.Windows.DependencyProperty.Name%2A>を含む) をクエリします。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型のインスタンスに存在する場合の代替メタデータをこの依存関係プロパティに提供します。この代替メタデータは、依存関係プロパティの最初の登録時に指定したメタデータの代わりに使用されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">この依存関係プロパティが継承され、指定した代替メタデータが適用される型。</param>
        <param name="typeMetadata">オーバーライドする型の依存関係プロパティに適用するメタデータ。</param>
        <summary>指定した型のインスタンスに存在する場合の代替メタデータをこの依存関係プロパティに提供し、基本型から継承されたときにこの依存関係プロパティに存在していたメタデータをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティのメタデータは、プロパティシステムが依存関係プロパティを使用する前にオーバーライドする必要があります。 これは、依存関係プロパティを登録するクラスを使用して、特定のインスタンスが作成された時刻に相当します。 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> の呼び出しは、このメソッドの `forType` パラメーターとして、または同様のインスタンス化を使用して自身を提供する型の静的コンストラクター内でのみ実行する必要があります。 所有者の型のインスタンスが存在した後にメタデータを変更しようとしても、例外は発生しませんが、プロパティシステムの動作が矛盾します。  
  
 このメソッドでは、特定の派生クラスに対するメタデータのオーバーライドが確立された後、この同じ派生クラスでメタデータをオーバーライドしようとすると、例外が発生します。  
  
 指定されたメタデータは、基本所有者に存在する依存関係プロパティのプロパティメタデータとマージされます。 元の基本メタデータで指定されたすべての特性が保持されます。新しいメタデータで特に変更された特性だけが、基本メタデータの特性を上書きします。 新しいメタデータで指定されている場合、<xref:System.Windows.PropertyMetadata.DefaultValue%2A> などの一部の特性は置き換えられます。 その他 (<xref:System.Windows.PropertyChangedCallback>など) は結合されます。 最終的には、マージ動作はオーバーライドに使用されているプロパティメタデータ型によって異なるため、ここで説明する動作は、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 依存関係プロパティで使用される既存のプロパティメタデータクラスに関するものです。 詳細については、「[依存関係プロパティのメタ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)データ」および「[フレームワークプロパティメタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">読み取り専用の依存関係プロパティでメタデータをオーバーライドしようとしました (このシグネチャを使用してこの操作を行うことはできません)。</exception>
        <exception cref="T:System.ArgumentException">指定した型に存在する場合のメタデータが、この依存関係プロパティに対して既に確立されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">この依存関係プロパティが継承され、指定した代替メタデータが適用される型。</param>
        <param name="typeMetadata">オーバーライドする型の依存関係プロパティに適用するメタデータ。</param>
        <param name="key">読み取り専用の依存関係プロパティのアクセス キー。</param>
        <summary>指定した型のインスタンスに存在する場合に代替メタデータを読み取り専用の依存関係プロパティに提供し、依存関係プロパティの最初の登録時に指定したメタデータをオーバーライドします。 例外の発生を防ぐために、読み取り専用の依存関係プロパティに <see cref="T:System.Windows.DependencyPropertyKey" /> を渡す必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このシグネチャは、読み取り専用の依存関係プロパティ識別子 (<xref:System.Windows.DependencyPropertyKey>) メソッドの基になる実装を提供します。 読み取り/書き込み依存関係プロパティのメタデータをオーバーライドする場合は、<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>を使用します。  
  
 依存関係プロパティのメタデータは、プロパティシステムが依存関係プロパティを使用する前にオーバーライドする必要があります。 これは、依存関係プロパティを登録するクラスに対して特定のオブジェクトが作成された時刻に相当します。 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> の呼び出しは、このメソッドの `forType` パラメーターとして、または同様のインスタンス化を使用して自身を提供する型の静的コンストラクター内でのみ実行する必要があります。 所有者の型のインスタンスが存在した後にメタデータを変更しようとしても、例外は発生しませんが、プロパティシステムの動作が矛盾します。  
  
 このメソッドでは、特定の派生クラスに対するメタデータのオーバーライドが確立された後、この同じ派生クラスでメタデータをオーバーライドしようとすると、例外が発生します。  
  
 指定されたメタデータは、基本所有者に存在する依存関係プロパティのプロパティメタデータとマージされます。 元の基本メタデータで指定されたすべての特性が保持されます。新しいメタデータで特に変更された特性だけが、基本メタデータの特性を上書きします。 新しいメタデータで指定されている場合、<xref:System.Windows.PropertyMetadata.DefaultValue%2A> などの一部の特性は置き換えられます。 その他 (<xref:System.Windows.PropertyChangedCallback>など) は結合されます。 マージ動作は、オーバーライドに使用されているプロパティメタデータ型によって異なります。 詳細については、「[依存関係プロパティのメタ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)データ」および「[フレームワークプロパティメタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティをプロパティ システムに登録したオブジェクト、または自身をプロパティの所有者として追加したオブジェクトの型を取得します。</summary>
        <value>プロパティを登録したオブジェクト、または自身をプロパティの所有者として追加したオブジェクトの型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値は、プロパティの登録時に指定されました。 所有者は、<xref:System.Windows.DependencyProperty.Register%2A> 呼び出しから生成された <xref:System.Windows.DependencyProperty> 識別子の場合は元の登録型、<xref:System.Windows.DependencyProperty.AddOwner%2A> 呼び出しから生成された <xref:System.Windows.DependencyProperty> 識別子の場合は所有者として追加された型のいずれかになります。  
  
 特定の <xref:System.Windows.DependencyProperty> の <xref:System.Windows.DependencyProperty.OwnerType%2A> は不変であり、有効な <xref:System.Windows.DependencyProperty>で `null` することはできません。  
  
   
  
## Examples  
 次の例では、`dp`依存関係プロパティの識別子に基づいて所有者の種類を取得し、その同じ識別子の所有者の型でメタデータを取得します。 この操作は、実際には `dp`で <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> を取得することと同じです。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値の型を取得します。</summary>
        <value>プロパティ値の <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、`propertyType` パラメーターを使用して、元のプロパティの登録によって宣言されたプロパティの値の型を報告します。 <xref:System.Windows.DependencyProperty.Name%2A>と同様に、依存関係プロパティのプロパティの型は登録後に変更できません。  
  
   
  
## Examples  
 次の例では、依存関係プロパティ識別子のさまざまな特性 (<xref:System.Windows.DependencyProperty.PropertyType%2A>を含む) をクエリします。 <xref:System.Windows.DependencyProperty.PropertyType%2A> の型名の文字列は、返された <xref:System.Type>から取得されます。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.DependencyProperty" /> インスタンスによって識別される依存関係プロパティが読み取り専用の依存関係プロパティかどうかを示す値を取得します。</summary>
        <value>依存関係プロパティが読み取り専用の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取り専用の依存関係プロパティは、<xref:System.Windows.DependencyProperty.Register%2A> メソッドではなく、<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> メソッドを呼び出すことによって、プロパティシステム内に登録されます。 添付プロパティは、読み取り専用として登録することもできます。「<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>」を参照してください。  
  
 読み取り専用の依存関係プロパティには、メタデータのオーバーライドや値の設定などのメタデータ操作を実行するために、<xref:System.Windows.DependencyProperty> 識別子ではなく <xref:System.Windows.DependencyPropertyKey> 識別子が必要です。 <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> または識別子を公開する別の API を呼び出すことによって <xref:System.Windows.DependencyProperty> 識別子のコレクションを取得した場合は、<xref:System.Windows.DependencyObject.SetValue%2A> を呼び出す前に <xref:System.Windows.DependencyProperty.ReadOnly%2A> 値を確認するか、入力パラメーターとしてその依存関係プロパティ識別子を使用 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> します。識別子が表す依存関係プロパティが読み取り専用でないことを確認します。 <xref:System.Windows.DependencyProperty.ReadOnly%2A> の値が依存関係プロパティで `true` 場合、その依存関係プロパティの <xref:System.Windows.DependencyPropertyKey> 識別子への参照を、メタデータまたは <xref:System.Windows.DependencyProperty> 識別子から取得するためのプログラムによる方法はありません。読み取り専用の依存関係プロパティに対して <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> を呼び出すためには、識別子を静的フィールドとして使用できる必要があります。  
  
 カスタム依存関係プロパティを作成し、読み取り専用として登録する場合は、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] ラッパープロパティの get アクセサーのみを定義する必要があります。 それ以外の場合は、バッキング依存関係プロパティへのアクセスと比較して、クラスにプロパティラッパーの混乱したオブジェクトモデルが含まれます。 詳細については、「[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)」または「読み取り専用の[依存関係プロパティ](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティのフィールドから既定のメタデータと依存関係プロパティの識別子プロパティを取得し、情報を使用してテーブルに "メタデータブラウザー" を実装します。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依存プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。 名前は、所有者型の登録名前空間内で一意である必要があります。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録する所有者型。</param>
        <summary>プロパティ名、プロパティ型、所有者型を指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ名、プロパティの型、所有者の型、プロパティ メタデータを指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるコールバックへの参照。</param>
        <summary>プロパティ名、プロパティ型、所有者型、プロパティ メタデータ、およびプロパティの値検証コールバックを指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
   
  
## Examples  
 次の例では、検証コールバックを含む依存関係プロパティを登録します (コールバック定義は表示されません。コールバック定義の詳細については、「<xref:System.Windows.ValidateValueCallback>)」を参照してください。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>添付プロパティをプロパティ システムに登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録する所有者型。</param>
        <summary>プロパティ名、プロパティ型、および所有者型を指定して、添付プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティは、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]によって定義されるプロパティの概念です。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] は、添付プロパティを依存関係プロパティとして実装します。 添付プロパティは依存関係プロパティで [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] あるため、レポートレイアウト特性などの操作のために一般的なプロパティシステムで使用できるメタデータを適用することができます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
   
  
## Examples  
 次の例では、この <xref:System.Windows.DependencyProperty.RegisterAttached%2A> シグネチャを使用して、抽象クラスに添付プロパティを登録します。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。 ここには、既定値などの特性を含めることができます。</param>
        <summary>プロパティ名、プロパティの型、所有者の型、およびプロパティ メタデータを指定して、アタッチされるプロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティは、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]によって定義されるプロパティの概念です。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] は、添付プロパティを依存関係プロパティとして実装します。 添付プロパティは依存関係プロパティで [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] あるため、レポートレイアウト特性などの操作のために一般的なプロパティシステムで使用できるメタデータを適用することができます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 <xref:System.Windows.DependencyProperty.Register%2A> ではなく <xref:System.Windows.DependencyProperty.RegisterAttached%2A> に依存関係プロパティを登録する具体的なシナリオの1つは、プロパティ値の継承をサポートすることです。 依存関係プロパティを公開するプロパティラッパーアクセサーがクラスで定義されていても、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用して、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータで <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> を指定するプロパティを登録するには、常に <xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。 ここには、既定値などの特性を含めることができます。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および値の検証コールバックを指定して、添付プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティは、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]によって定義されるプロパティの概念です。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] は、添付プロパティを依存関係プロパティとして実装します。 添付プロパティは依存関係プロパティで [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] あるため、レポートレイアウト特性などの操作のために一般的なプロパティシステムで使用できるメタデータを適用することができます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 <xref:System.Windows.DependencyProperty.Register%2A> ではなく <xref:System.Windows.DependencyProperty.RegisterAttached%2A> に依存関係プロパティを登録する具体的なシナリオの1つは、プロパティ値の継承をサポートすることです。 依存関係プロパティを公開するプロパティラッパーアクセサーがクラスで定義されていても、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用して、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータで <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> を指定するプロパティを登録するには、常に <xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、この <xref:System.Windows.DependencyProperty.RegisterAttached%2A> シグネチャを使用して、抽象クラスに添付プロパティを登録します。 この添付プロパティは列挙型のプロパティであり、登録は検証コールバックを追加して、指定された値が列挙体の値であることを確認します。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>読み取り専用添付プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ型、所有者型、およびプロパティ メタデータを指定して、読み取り専用の添付プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要がある依存関係プロパティのキー。これは後で依存関係プロパティの参照に使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.Windows.DependencyPropertyKey>型を返し、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> は <xref:System.Windows.DependencyProperty>型を返します。 通常、読み取り専用プロパティを表すキーは公開されません。これは、キーを使用して <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>を呼び出すことによって依存関係プロパティの値を設定できるためです。 クラスの設計は要件に影響しますが、一般に、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみに、<xref:System.Windows.DependencyPropertyKey> のアクセスと可視性を制限することをお勧めします。 また、<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> の値をクラスの `public static readonly` フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 添付プロパティの主なシナリオは [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]で使用されるため、読み取り専用の添付プロパティはまれなシナリオです。 パブリック setter を使用しない場合、添付プロパティを [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文で設定することはできません。  
  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 依存関係プロパティを添付として登録するための特定のシナリオの1つは、プロパティ値の継承をサポートすることです。 依存関係プロパティを公開するプロパティラッパーアクセサーがクラスで定義されていても、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用して、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータで <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> を指定するプロパティを登録するには、常に <xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるユーザー作成のコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを指定して、読み取り専用の添付プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要があり、依存関係プロパティの参照に使用される、依存関係プロパティのキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.Windows.DependencyPropertyKey>型を返し、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> は <xref:System.Windows.DependencyProperty>型を返します。 通常、<xref:System.Windows.DependencyProperty>型を表すキーです。 通常、読み取り専用プロパティを表すキーは公開されません。これは、キーを使用して <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>を呼び出すことによって依存関係プロパティの値を設定できるためです。 クラスの設計は要件に影響しますが、一般に、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみに、<xref:System.Windows.DependencyPropertyKey> のアクセスと可視性を制限することをお勧めします。 また、<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> の値をクラスの `public static readonly` フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 添付プロパティの主なシナリオは [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]で使用されるため、読み取り専用の添付プロパティはまれなシナリオです。 パブリック setter を使用しない場合、添付プロパティを [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 構文で設定することはできません。  
  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 依存関係プロパティを <xref:System.Windows.DependencyProperty.Register%2A> ではなくアタッチ済みとして登録する特定のシナリオでは、プロパティ値の継承をサポートします。 依存関係プロパティを公開するプロパティラッパーアクセサーがクラスで定義されていても、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用して、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータで <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> を指定するプロパティを登録するには、常に <xref:System.Windows.DependencyProperty.RegisterAttached%2A> を使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>読み取り専用の依存関係プロパティとして、依存関係プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータを指定して、読み取り専用の依存関係プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要があり、依存関係プロパティの参照に使用される、依存関係プロパティのキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.Windows.DependencyPropertyKey>型を返し、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> は <xref:System.Windows.DependencyProperty>型を返します。 通常、読み取り専用プロパティを表すキーは公開されません。これは、キーを使用して <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>を呼び出すことによって依存関係プロパティの値を設定できるためです。 クラスの設計は要件に影響しますが、一般に、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみに、<xref:System.Windows.DependencyPropertyKey> のアクセスと可視性を制限することをお勧めします。 また、<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> の値をクラスの `public static readonly` フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 読み取り専用の依存関係プロパティは、既存の API とカスタマイズシナリオの両方で、非常に一般的なシナリオです。他の [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 機能では、そのプロパティが呼び出し元によって設定されることを意図していない場合でも依存関係プロパティが必要になる可能性があるためです。 読み取り専用の依存関係プロパティの値は、依存関係プロパティを受け取る他のプロパティシステム操作の基準として使用できます。たとえば、スタイルの依存関係プロパティの <xref:System.Windows.Trigger> に基づいています。  
  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
   
  
## Examples  
 次の例では、`AquariumSize` 依存関係プロパティを読み取り専用として登録します。 この例では、`AquariumSizeKey` を内部キーとして定義し (そのため、アセンブリ内の他のクラスがメタデータをオーバーライドする可能性があります)、そのキーに基づいて依存関係プロパティ識別子を `AquariumSizeProperty`として公開します。 また、ラッパーは get アクセサーのみを使用して `AquariumSize`用に作成されます。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるユーザー作成のコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを指定して、読み取り専用の依存関係プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要がある依存関係プロパティのキー。これは後で依存関係プロパティの参照に使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは <xref:System.Windows.DependencyPropertyKey>型を返し、<xref:System.Windows.DependencyProperty.RegisterAttached%2A> は <xref:System.Windows.DependencyProperty>型を返します。 通常、読み取り専用プロパティを表すキーは公開されません。これは、キーを使用して <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>を呼び出すことによって依存関係プロパティの値を設定できるためです。 クラスの設計は要件に影響しますが、一般に、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみに、<xref:System.Windows.DependencyPropertyKey> のアクセスと可視性を制限することをお勧めします。 また、<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> の値をクラスの `public static readonly` フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 読み取り専用の依存関係プロパティは、非常に一般的なシナリオです。 読み取り専用の依存関係プロパティの値は、依存関係プロパティを受け取る他のプロパティシステム操作の基準として使用できます。たとえば、スタイルの依存関係プロパティの <xref:System.Windows.Trigger> に基づいています。  
  
 依存関係プロパティの登録の詳細については、「<xref:System.Windows.DependencyProperty>」を参照してください。  
  
 読み取り専用の依存関係プロパティでの検証は、重要度が低い場合があります。 キーに指定した非パブリックアクセスレベルにより、任意の無効な入力の可能性が減少します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>依存関係プロパティの文字列表現を返します。</summary>
        <returns>依存関係プロパティの文字列表現。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装は、<xref:System.Windows.DependencyProperty.Name%2A> プロパティ値を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティは存在するが、その値がプロパティ システムによって設定されていないことを示すために、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プロパティ システムが <see langword="null" /> の代わりに使用する静的な値を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> は、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プロパティシステムが、要求された <xref:System.Windows.DependencyProperty> 値を特定できない場合に使用される sentinel 値です。 `null`ではなく <xref:System.Windows.DependencyProperty.UnsetValue> が使用されます。これは、`null` が有効なプロパティ値であり、有効な (および頻繁に使用される) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>である可能性があるためです。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> が <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>から返されることはありません。 <xref:System.Windows.DependencyObject> インスタンスの依存関係プロパティで <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> を呼び出すと、次のいずれかが適用されます。  
  
-   依存関係プロパティには、メタデータに既定値が設定されており、その値が返されます。 この値は <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>から取得できます。  
  
-   他の値がプロパティシステムによって設定されており、既定値が関連していません。 詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> の <xref:System.Windows.PropertyMetadata.DefaultValue%2A> の設定は、特に許可されていません。  
  
 要求されたプロパティがローカルに設定されていない場合、<xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> は <xref:System.Windows.DependencyProperty.UnsetValue> を返します。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> は、<xref:System.Windows.CoerceValueCallback>の戻り値として使用される場合に特別な意味を持ちます。 詳細については、「[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。  
  
 データベースにバインドしている場合、<xref:System.Windows.DependencyProperty.UnsetValue> は <xref:System.DBNull.Value>と同じではありません。これは、<xref:System.DBNull.Value> が true null と等しくない方法と似ています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値検証コールバックを取得します。</summary>
        <value>依存関係プロパティを最初に登録するときに <paramref name="validateValueCallback" /> パラメーターで指定した、この依存関係プロパティの値検証コールバック。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティには、検証コールバックが登録されていない依存関係プロパティの `null` が含まれます。  
  
 検証値のコールバックは静的な意味で動作する必要があります。 <xref:System.Windows.ValidateValueCallback> によって適用される検証では、指定された値が特定のインスタンスに対して有効かどうかを判断できません。 コールバックは、依存関係プロパティを持つすべてのオブジェクトが、指定された値を有効なものとして受け入れるかどうかを判断するだけです。 特定のインスタンスの他の依存関係プロパティの値を知ることに依存する検証を実行する必要がある場合は、代わりに <xref:System.Windows.CoerceValueCallback> を使用します。 <xref:System.Windows.CoerceValueCallback> は、依存関係プロパティの識別子内で直接ではなく、依存関係プロパティのメタデータの一部として登録されます。 詳細については、「[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>
