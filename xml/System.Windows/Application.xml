<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6baa7c3a15ef44ceb503be098d467c16f04fbec2" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77229732" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Windows Presentation Foundation アプリケーションをカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> は、次のような [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アプリケーション固有の機能をカプセル化するクラスです。  
  
-   **アプリケーションの有効期間**: <xref:System.Windows.Application.Activated>、<xref:System.Windows.Application.Current%2A>、<xref:System.Windows.Application.Deactivated>、<xref:System.Windows.Application.DispatcherUnhandledException>、<xref:System.Windows.Application.Exit>、<xref:System.Windows.Application.Run%2A>、<xref:System.Windows.Application.SessionEnding>、<xref:System.Windows.Application.Shutdown%2A>、<xref:System.Windows.Application.ShutdownMode%2A>、<xref:System.Windows.Application.Startup>。  
  
-   **アプリケーションスコープウィンドウ、プロパティ、およびリソース管理**: <xref:System.Windows.Application.FindResource%2A>、<xref:System.Windows.Application.GetContentStream%2A>、<xref:System.Windows.Application.GetResourceStream%2A>、<xref:System.Windows.Application.LoadComponent%2A>、<xref:System.Windows.Application.MainWindow%2A>、<xref:System.Windows.Application.Properties%2A>、<xref:System.Windows.Application.Resources%2A>、<xref:System.Windows.Application.StartupUri%2A>、<xref:System.Windows.Application.Windows%2A>。  
  
-   **コマンドラインパラメーターと終了コード処理**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>、<xref:System.Windows.Application.Exit?displayProperty=nameWithType>、<xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>。  
  
-   **ナビゲーション**: <xref:System.Windows.Application.FragmentNavigation>、<xref:System.Windows.Application.LoadCompleted>、<xref:System.Windows.Application.Navigated>、<xref:System.Windows.Application.Navigating>、<xref:System.Windows.Application.NavigationProgress>、<xref:System.Windows.Application.NavigationStopped>、<xref:System.Windows.Application.NavigationFailed>、<xref:System.Windows.Application.SetCookie%2A>、<xref:System.Windows.Application.GetCookie%2A>。  
  
 <xref:System.Windows.Application> は、シングルトンパターンを実装して、そのウィンドウ、プロパティ、およびリソーススコープサービスへの共有アクセスを提供します。 そのため、<xref:System.AppDomain>ごとに作成できる <xref:System.Windows.Application> クラスのインスタンスは1つだけです。  
  
 マークアップ、マークアップと分離コード、またはコードを使用して、<xref:System.Windows.Application> を実装できます。 マークアップまたはマークアップと分離コードのどちらを使用する場合でも <xref:System.Windows.Application> がマークアップと共に実装される場合は、マークアップファイルを [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` 項目として構成する必要があります。  
  
> [!NOTE]
>  スタンドアロンアプリケーションは、<xref:System.Windows.Application> オブジェクトを必要としません。<xref:System.Windows.Application>のインスタンスを作成せずにウィンドウを開くカスタムの `static` エントリポイントメソッド (`Main`) を実装することもできます。 ただし、[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] には <xref:System.Windows.Application> オブジェクトが必要です。  
  
   
  
## Examples  
 次の例は、マークアップのみを使用して標準アプリケーションを定義する方法を示しています。  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 次の例は、コードのみを使用して標準アプリケーションを定義する方法を示しています。  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 次の例は、マークアップと分離コードの組み合わせを使用して、標準アプリケーションを定義する方法を示しています。  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型のパブリック <see langword="static" /> (<see langword="Shared" /> Visual Basic) メンバーは、スレッドセーフです。 さらに、<see cref="M:System.Windows.Application.FindResource(System.Object)" /> メソッドと <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> メソッド、および <see cref="P:System.Windows.Application.Properties" /> および <see cref="P:System.Windows.Application.Resources" /> プロパティはスレッドセーフです。</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Application" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションスコープのウィンドウ、プロパティ、およびリソースデータの1つのセットへの共有アクセスを確保するために、<xref:System.AppDomain>ごとに作成できる <xref:System.Windows.Application> クラスのインスタンスは1つだけです。 その結果、<xref:System.Windows.Application> クラスのパラメーターなしのコンストラクターは、初期化されているインスタンスが <xref:System.AppDomain>内の最初のインスタンスであるかどうかを検出します。そうでない場合は、<xref:System.InvalidOperationException> がスローされます。  
  
 現在の <xref:System.AppDomain> の <xref:System.Windows.Application> オブジェクトは、静的な <xref:System.Windows.Application.Current%2A> プロパティから公開されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">1 つの <see cref="T:System.Windows.Application" /> に対して、<see cref="T:System.AppDomain" /> クラスのインスタンスが複数作成されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが前面のアプリケーションになったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1つまたは複数の開いているウィンドウがアクティブになっている Windows Presentation Foundation アプリケーションがアクティブ化されている (前面のアプリケーションになります)。これは、アプリケーションが起動されてから初めて windows がアクティブになったとき、または windows の1つがアクティブになったときに、アプリケーションが非アクティブになっている: 具体的には、次の場合にアクティブ化が行われます。  
  
-   アプリケーションが最初のウィンドウを開きます。  
  
-   ユーザーは、ALT + TAB キーを使用するか、タスクマネージャーを使用して、アプリケーションに切り替えます。  
  
-   ユーザーは、アプリケーション内のいずれかのウィンドウのタスクバーボタンをクリックします。  
  
 アクティブ化時に検出する必要があるアプリケーションは、<xref:System.Windows.Application.Activated> イベントを処理できます。  
  
 アプリケーションが最初にアクティブ化された後は、有効期間中に何度も非アクティブになり、再アクティブ化される可能性があります。 アプリケーションの動作または状態がアクティブ化状態に依存している場合は、<xref:System.Windows.Application.Activated> イベントと <xref:System.Windows.Application.Deactivated> イベントの両方を処理して、どのアクティブ化状態になっているかを判断できます。  
  
 アプリケーションがアクティブになると、アプリケーションがアクティブになっている間にアクティブ化されたアプリケーション内のウィンドウの数に関係なく、アプリケーションが非アクティブになるまで <xref:System.Windows.Application.Activated> は再び発生しません。  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]に対して <xref:System.Windows.Application.Activated> が発生していません。  
  
   
  
## Examples  
 次の例は、スタンドアロンアプリケーションのアクティブ化と非アクティブ化を検出する方法を示しています。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Windows.Application" /> の <see cref="T:System.AppDomain" /> オブジェクトを取得します。</summary>
        <value>現在の <see cref="T:System.Windows.Application" /> の <see cref="T:System.AppDomain" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> は、現在の <xref:System.AppDomain>の <xref:System.Windows.Application> インスタンスへの共有アクセスを提供する静的 <xref:System.Windows.Application.Current%2A> プロパティを実装する、<xref:System.AppDomain> ごとのシングルトン型です。 この設計では、共有リソースや状態など、<xref:System.Windows.Application>によって管理される状態が、1つの共有された場所から利用できることが保証されます。  
  
 このプロパティはスレッドセーフであり、任意のスレッドから使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが前面のアプリケーションではなくなったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが次の処理を実行すると、1つ以上の開いているウィンドウが非アクティブ化された (フォアグラウンドアプリケーションではなく) Windows Presentation Foundation アプリケーション。  
  
-   ALT + TAB キーを押すか、タスクマネージャーを使用して、別のアプリケーションに切り替えます。  
  
-   別のアプリケーションのウィンドウのタスクバーボタンをクリックします。  
  
 非アクティブ化を検出する必要があるアプリケーションは、<xref:System.Windows.Application.Deactivated> イベントを処理できます。  
  
 アプリケーションが最初にアクティブ化された後は、有効期間中に何度も非アクティブになり、再アクティブ化される可能性があります。 アプリケーションの動作または状態がアクティブ化状態に依存している場合は、<xref:System.Windows.Application.Deactivated> イベントと <xref:System.Windows.Application.Activated> イベントの両方を処理して、どの状態にあるかを判断できます。  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]に対して <xref:System.Windows.Application.Deactivated> が発生していません。  
  
   
  
## Examples  
 次の例では、スタンドアロンアプリケーションが非アクティブ化され、アクティブ化されるタイミングを検出する方法を示します。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションによってスローされた例外が処理されないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、Windows Presentation Foundation はハンドルされない例外をキャッチし、(例外を報告できる) ダイアログボックスから例外のユーザーに通知し、アプリケーションを自動的にシャットダウンします。  
  
 ただし、アプリケーションで、一元化された場所からカスタムのハンドルされない例外処理を実行する必要がある場合は、<xref:System.Windows.Application.DispatcherUnhandledException>を処理する必要があります。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> は、メイン UI スレッドで実行されているコードによって処理されない例外ごとに <xref:System.Windows.Application> によって発生します。  
  
 バックグラウンド UI スレッド (独自の <xref:System.Windows.Threading.Dispatcher>を持つスレッド) またはバックグラウンドワーカースレッド (<xref:System.Windows.Threading.Dispatcher>を持たないスレッド) のいずれかで例外が処理されない場合、例外はメイン UI スレッドに転送されません。 その結果、<xref:System.Windows.Application.DispatcherUnhandledException> は発生しません。 このような状況では、次の操作を行うためのコードを記述する必要があります。  
  
1.  バックグラウンドスレッドで例外を処理します。  
  
2.  これらの例外をメイン UI スレッドにディスパッチします。  
  
3.  <xref:System.Windows.Application.DispatcherUnhandledException> を発生させることができるように、メイン UI スレッドでそれらを処理せずに再スローします。  
  
 詳細については、「[スレッドモデル](~/docs/framework/wpf/advanced/threading-model.md)の概要」を参照してください。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> イベントハンドラーには、次のような、例外に関するコンテキスト情報を含む <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> 引数が渡されます。  
  
-   例外 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>)。  
  
-   元の <xref:System.Windows.Threading.Dispatcher> (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>)。  
  
 この情報を使用すると、例外が復旧可能かどうかを判断できます。 回復可能な例外は、たとえば、回復不能な例外が <xref:System.StackOverflowException>である可能性があるなど、<xref:System.IO.FileNotFoundException>である可能性があります。  
  
 未処理の例外を <xref:System.Windows.Application.DispatcherUnhandledException>から処理し、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] で処理を続行しない場合は、<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> プロパティを `true`に設定する必要があります。  
  
 <xref:System.Windows.Application> が発生する他のイベントとは異なり、<xref:System.Windows.Application.DispatcherUnhandledException> には、対応する保護された仮想実装 (OnDispatcherUnhandledException) がありません。 そのため、<xref:System.Windows.Application> から派生するクラスは、未処理の例外を処理するために、常に <xref:System.Windows.Application.DispatcherUnhandledException> でイベントハンドラーを登録する必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Application.DispatcherUnhandledException> イベントを処理することによって、未処理の例外を処理する方法を示します。  
  
 [!code-csharp[handling-unhandled-exceptions](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs)]
 [!code-vb[handling-unhandled-exceptions](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがシャットダウンする直前に発生し、キャンセルできません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションは、次のいずれかの理由でシャットダウンできます。  
  
-   <xref:System.Windows.Application> オブジェクトの <xref:System.Windows.Application.Shutdown%2A> メソッドは、明示的に、または <xref:System.Windows.Application.ShutdownMode%2A> プロパティによって決定されたとおりに呼び出されます。  
  
-   ユーザーは、ログオフまたはシャットダウンによってセッションを終了します。  
  
 アプリケーションのシャットダウンが発生したことを検出するには、<xref:System.Windows.Application.Exit> イベントを処理し、必要に応じて追加の処理を実行します。  
  
 また、<xref:System.Windows.Application.Shutdown%2A> を明示的に呼び出す必要がない場合に、アプリケーションの終了コードを検査または変更するために <xref:System.Windows.Application.Exit> を処理することもできます。 終了コードは、<xref:System.Windows.Application.Exit> イベントハンドラーに渡される <xref:System.Windows.ExitEventArgs> 引数の <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> プロパティから公開されます。 アプリケーションの実行が停止すると、後続の処理のために、終了コードがオペレーティングシステムに渡されます。  
  
 アプリケーションで <xref:System.Windows.Application.SessionEnding> イベントが処理され、その後キャンセルされる場合、<xref:System.Windows.Application.Exit> は発生せず、アプリケーションはシャットダウンモードに従って実行を継続します。  
  
 終了コードは [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]から設定できますが、値は無視されます。  
  
 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]の場合、次のような状況で <xref:System.Windows.Application.Exit> が発生します。  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] は移動します。  
  
-   [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]で、[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] をホストしているタブが閉じられたとき。  
  
-   ブラウザーが閉じられた。  
  
 いずれの場合も、<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> プロパティの値は無視されます。  
  
   
  
## Examples  
 次の例は、その方法を示しています。  
  
-   <xref:System.Windows.Application.Exit> イベントを処理します。  
  
-   <xref:System.Windows.ExitEventArgs>の <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> プロパティを調べて更新します。  
  
-   分離ストレージのアプリケーションログにエントリを書き込みます。  
  
-   アプリケーションの状態を分離ストレージに保持します。  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースの名前。</param>
        <summary>指定したキーを持つ [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] リソース (<see cref="T:System.Windows.Style" /> や <see cref="T:System.Windows.Media.Brush" /> など) を検索します。要求したリソースが見つからない場合は例外がスローされます (「<see href="~/docs/framework/wpf/advanced/xaml-resources.md">XAML Resources (XAML リソース)</see>」を参照)。</summary>
        <returns>要求されたリソース オブジェクト。 要求したリソースが見つからない場合は、<see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> は、まず、指定されたリソースのアプリケーションスコープのリソースを確認します。 アプリケーションスコープのリソースは <xref:System.Windows.Application>によって管理され、<xref:System.Windows.Application.Resources%2A> プロパティから公開されます。 指定されたリソースがアプリケーションスコープリソースのセットに見つからない場合、<xref:System.Windows.Application.FindResource%2A> はシステムリソースを検索します。 システムリソースは、ユーザーが定義したシェルリソースであり、色、フォント、およびシェルの構成が含まれます。 これらは、それぞれ <xref:System.Windows.SystemColors>、<xref:System.Windows.SystemFonts>、および <xref:System.Windows.SystemParameters> 型から静的プロパティとして公開されます。 これらの型を取得するために <xref:System.Windows.Application.FindResource%2A> を使用するには、<xref:System.Windows.Application.FindResource%2A>に渡すように設計されたリソースキープロパティも公開します。たとえば、<xref:System.Windows.SystemParameters.IconWidthKey%2A>のようにします。  
  
 <xref:System.Windows.Application.FindResource%2A> はオブジェクトを返すため、リソースが見つかった場合は、返された値を適切な型にキャストする必要があります。  
  
> [!IMPORTANT]
>  見つからないキーに対してこのメソッドを呼び出すと、例外がスローされます。 <xref:System.Windows.Application.FindResource%2A>を呼び出した結果として発生する例外を処理しない場合は、代わりに <xref:System.Windows.Application.TryFindResource%2A> を呼び出します。要求されたリソースが見つからない場合、<xref:System.Windows.Application.TryFindResource%2A> は `null` 参照を返し、例外をスローしません。  
  
 このメソッドはスレッドセーフであり、任意のスレッドから呼び出すことができます。  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Application.FindResource%2A> を使用してリソースを検索し、リソースが見つからない場合に <xref:System.Windows.ResourceReferenceKeyNotFoundException> を処理する方法を示します。  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">リソースが見つかりません。</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターがコンテンツ フラグメントへのナビゲーションを開始すると発生します。ナビゲーションは、目的のフラグメントが現在のコンテンツにある場合はすぐに発生し、目的のフラグメントが別のコンテンツにある場合は、ソース [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] コンテンツが読み込まれた後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ナビゲーターは、<xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>のいずれかです。  
  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>) をご覧ください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">Loose リソースにマッピングする相対 <see cref="T:System.Uri" />。</param>
        <summary>指定した <see cref="T:System.Uri" /> にあるコンテンツ データ ファイル (「<see href="~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md">WPF Application Resource, Content, and Data Files (WPF アプリケーション リソース、コンテンツおよびデータ ファイル)</see>」を参照) のリソース ストリームを返します。</summary>
        <returns>指定した <see cref="T:System.Windows.Resources.StreamResourceInfo" /> にあるコンテンツ データ ファイルを格納している <see cref="T:System.Uri" />。 Loose リソースが見つからない場合は null が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはスレッドセーフではありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> は null です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> は、絶対 <see cref="T:System.Uri" /> です。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">クッキーが作成された場所を指定する <see cref="T:System.Uri" />。</param>
        <summary><see cref="T:System.Uri" /> で指定した場所のクッキーを取得します。</summary>
        <returns>クッキーが存在する場合は <see cref="T:System.String" /> 値が返されます。それ以外の場合は <see cref="T:System.ComponentModel.Win32Exception" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> は、指定された <xref:System.Uri>のクッキーを取得します。 クッキーを取得できない場合は、<xref:System.ComponentModel.Win32Exception> がスローされます。 Cookie 文字列を解析して名前と値のペアのリストにするには、コードを記述する必要があります。  
  
 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]の cookie の概要については、「[ナビゲーションの概要](~/docs/framework/wpf/app-development/navigation-overview.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">指定したクッキーを取得しようとして問題が起きると、([!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] から呼び出された) <see langword="InternetGetCookie" /> 関数により <see cref="M:System.Windows.Application.GetCookie(System.Uri)" /> エラーが発生します。</exception>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">起点サイトの Loose リソースにマッピングする <see cref="T:System.Uri" />。</param>
        <summary>指定した <see cref="T:System.Uri" /> にある元のサイトに対するデータ ファイル (「<see href="~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md">WPF Application Resource, Content, and Data Files (WPF アプリケーション リソース、コンテンツおよびデータ ファイル)</see>」を参照) のリソース ストリームを返します。</summary>
        <returns>指定した <see cref="T:System.Windows.Resources.StreamResourceInfo" /> にある起点サイト データ ファイルのリソース ストリームを格納している <see cref="T:System.Uri" />。 Loose リソースが見つからない場合は <see langword="null" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはスレッドセーフではありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> は null です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> は相対参照ではなく絶対参照の形式ですが、<c>pack://siteoforigin:,,,/</c> の形式ではありません。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">埋め込みリソースにマッピングする <see cref="T:System.Uri" />。</param>
        <summary>指定した <see cref="T:System.Uri" /> にあるリソース データ ファイル (「<see href="~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md">WPF Application Resource, Content, and Data Files (WPF アプリケーション リソース、コンテンツおよびデータ ファイル)</see>」を参照) のリソース ストリームを返します。</summary>
        <returns>指定した <see cref="T:System.Windows.Resources.StreamResourceInfo" /> にあるリソース データ ファイルのリソース ストリームを格納している <see cref="T:System.Uri" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはスレッドセーフではありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> は null です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> は相対参照ではなく絶対参照の形式ですが、<c>pack://application:,,,/</c> の形式ではありません。</exception>
        <exception cref="T:System.IO.IOException"><see cref="T:System.Uri" /> に渡される <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> が見つかりません。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターによる移動先のコンテンツが読み込まれ、解析されて、レンダリングが開始されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ナビゲーターは、<xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>のいずれかです。  
  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>) をご覧ください。  
  
> [!NOTE]
>  移動したコンテンツのプロパティにアクセスする前に、移動したコンテンツのイベント (<xref:System.Windows.Controls.Page> の <xref:System.Windows.FrameworkElement.Loaded> イベントなど) をリッスンします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した Uniform Resource Identifier (URI) にある [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ファイルを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] ファイルには、アプリケーションコードファイル ([!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] ページ項目として構成されている)、またはアプリケーションデータファイル (リソースファイル、コンテンツファイル、またはサイトの起点ファイル) を指定できます。「 [WPF アプリケーションリソース、コンテンツ、およびデータファイル](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)」を参照してください。  
  
> [!NOTE]
>  このメソッドはスレッドセーフではありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">相対 <see cref="T:System.Uri" /> ファイルにマップする [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</param>
        <summary>指定した Uniform Resource Identifier (URI) にある [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ファイルを読み込んで、[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ファイルのルート要素で指定したオブジェクトのインスタンスに変換します。</summary>
        <returns>読み込まれた XAML ファイルに指定されているルート要素のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値は、[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ファイルのルート要素と同じ型に明示的に変換する必要があります。  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] ファイルには、アプリケーションコードファイル ([!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] ページ項目として構成されている)、またはアプリケーションデータファイル (リソースファイル、コンテンツファイル、またはサイトの起点ファイル) を指定できます。「 [WPF アプリケーションリソース、コンテンツ、およびデータファイル](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)」を参照してください。  
  
> [!NOTE]
>  このメソッドはスレッドセーフではありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> が null です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> が絶対 URI です。</exception>
        <exception cref="T:System.Exception">ファイルが [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] ファイルではありません。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ファイルのルート要素と同じ型のオブジェクト。</param>
        <param name="resourceLocator">相対 <see cref="T:System.Uri" /> ファイルにマップする [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</param>
        <summary>指定した Uniform Resource Identifier (URI) にある [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ファイルを読み込んで、[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ファイルのルート要素で指定したオブジェクトのインスタンスに変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] ファイルには、アプリケーションコードファイル ([!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] ページ項目として構成されている)、またはアプリケーションデータファイル (リソースファイル、コンテンツファイル、またはサイトの起点ファイル) を指定できます。「 [WPF アプリケーションリソース、コンテンツ、およびデータファイル](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)」を参照してください。  
  
> [!NOTE]
>  このメソッドはスレッドセーフではありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> が null です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> が絶対 URI です。</exception>
        <exception cref="T:System.Exception"><paramref name="component" /> は、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ファイルのルート要素に一致しない型です。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのメイン ウィンドウを取得または設定します。</summary>
        <value>メイン アプリケーション ウィンドウとして指定される <see cref="T:System.Windows.Window" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> は、<xref:System.AppDomain>でインスタンス化される最初の <xref:System.Windows.Window> オブジェクトへの参照を使用して自動的に設定されます。  
  
 別の <xref:System.Windows.Application.Windows%2A> オブジェクトを <xref:System.Windows.Application.MainWindow%2A> プロパティに割り当てる <xref:System.Windows.Application.MainWindow%2A> 設定することにより、別のメインウィンドウを指定できます。  
  
 <xref:System.Windows.Application> オブジェクトの <xref:System.Windows.Application.ShutdownMode%2A> プロパティが <xref:System.Windows.ShutdownMode.OnMainWindowClose>に設定されている場合は、メインウィンドウを閉じるとアプリケーションがシャットダウンします。  
  
 アプリケーションのメインウィンドウが [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]の <xref:System.Windows.Application.StartupUri%2A> プロパティを設定することによって生成されるウィンドウでない場合は、[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]から <xref:System.Windows.Application.MainWindow%2A> プロパティを設定できます。 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] アプローチには、次の2つの制限があります。  
  
-   メインウィンドウとして、[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]のみの <xref:System.Windows.Window> または [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]のみの <xref:System.Windows.Navigation.NavigationWindow> を指定できます。  
  
-   指定したウィンドウの [<xref:System.Windows.UIElement.Visibility%2A>] プロパティを設定する必要があります。そうしないと、表示されません。  
  
 インスタンス化される最初の <xref:System.Windows.Window> オブジェクトへの参照も、最初の項目として <xref:System.Windows.Application.Windows%2A> コレクションに追加されます。 その後 <xref:System.Windows.Application.MainWindow%2A> 別の <xref:System.Windows.Window>への参照が設定されている場合は、メインウィンドウへの参照を持つ項目の位置が変更されますが、<xref:System.Windows.Application.Windows%2A> 内の項目の順序は変わりません。 そのため、<xref:System.Windows.Application.Windows%2A>の最初の項目ではなく、常に <xref:System.Windows.Application.MainWindow%2A> を使用してメインウィンドウを参照します。  
  
> [!NOTE]
>  メインウィンドウが <xref:System.Windows.Navigation.NavigationWindow>で、<xref:System.Windows.Navigation.NavigationWindow> メンバーへの特定のアクセスが必要な場合は、<xref:System.Windows.Application.MainWindow%2A> の値を <xref:System.Windows.Navigation.NavigationWindow>にキャストする必要があります。  
>   
>  このプロパティは、<xref:System.Windows.Application> オブジェクトを作成したスレッドからのみ使用できます。  
  
   
  
## Examples  
 次の例は、メインアプリケーションウィンドウを検索する方法を示しています。  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 次の例では、[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]を使用して <xref:System.Windows.Application.MainWindow%2A> を設定する方法を示します。  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 次の例は、アプリケーションの起動時にコード内の <xref:System.Windows.Application.MainWindow%2A> をインスタンス化する方法を示しています。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" /> は、ブラウザーでホストされるアプリケーション ([!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] など) から設定されます。</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターによる移動先のコンテンツが見つかったときに発生します。ただし、読み込みはまだ完了していない可能性があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ナビゲーターは、<xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>のいずれかです。  
  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>) をご覧ください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターによって新しいナビゲーションが要求されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ナビゲーターは、<xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>のいずれかです。  
  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>) をご覧ください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターが要求されたコンテンツに移動する際にエラーが発生したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ナビゲーターは、<xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>のいずれかです。  
  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>) をご覧ください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターによって管理されているダウンロード中に定期的に発生して、ナビゲーションの進行状況に関する情報を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ナビゲーターは、<xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>のいずれかです。  
  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>) をご覧ください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのナビゲーターの <see langword="StopLoading" /> メソッドが呼び出されたとき、または現在のナビゲーションの進行中にナビゲーターによって新しいナビゲーションが要求されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ナビゲーターは、<xref:System.Windows.Navigation.NavigationWindow> または <xref:System.Windows.Controls.Frame>のいずれかです。  
  
 [https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>) をご覧ください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Application.Activated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> は、<xref:System.Windows.Application.Activated> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnActivated%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.Activated> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnActivated%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Application.Deactivated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> は、<xref:System.Windows.Application.Deactivated> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnDeactivated%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.Deactivated> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnDeactivated%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.ExitEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Application.Exit" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> は、<xref:System.Windows.Application.Exit> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型は、<xref:System.Windows.Application.OnExit%2A> メソッドをオーバーライドする可能性があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.Exit> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnExit%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.FragmentNavigation" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> は、<xref:System.Windows.Application.FragmentNavigation> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnFragmentNavigation%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.FragmentNavigation> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnFragmentNavigation%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.LoadCompleted" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> は、<xref:System.Windows.Application.LoadCompleted> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnLoadCompleted%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.LoadCompleted> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnLoadCompleted%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.Navigated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> は、<xref:System.Windows.Application.Navigated> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnNavigated%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.Navigated> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnNavigated%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.Navigating" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> は、<xref:System.Windows.Application.Navigating> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnNavigating%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.Navigating> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnNavigating%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.NavigationFailed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> は、<xref:System.Windows.Application.NavigationFailed> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnNavigationFailed%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.NavigationFailed> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnNavigationFailed%2A> を呼び出す必要があります。  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.NavigationProgress" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> は、<xref:System.Windows.Application.NavigationProgress> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnNavigationProgress%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.NavigationProgress> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnNavigationProgress%2A> を明示的に呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.Navigation.NavigationEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.NavigationStopped" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> は、<xref:System.Windows.Application.NavigationStopped> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnNavigationStopped%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.NavigationStopped> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnNavigationStopped%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.SessionEndingCancelEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.SessionEnding" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> は、<xref:System.Windows.Application.SessionEnding> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnSessionEnding%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.SessionEnding> を発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnSessionEnding%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Windows.StartupEventArgs" /> です。</param>
        <summary><see cref="E:System.Windows.Application.Startup" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> は、<xref:System.Windows.Application.Startup> イベントを発生させます。  
  
 <xref:System.Windows.Application> から派生した型で <xref:System.Windows.Application.OnStartup%2A>がオーバーライドされる場合があります。 オーバーライドされたメソッドは、<xref:System.Windows.Application.Startup> イベントを発生させる必要がある場合に、基底クラスの <xref:System.Windows.Application.OnStartup%2A> を呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション スコープのプロパティのコレクションを取得します。</summary>
        <value>アプリケーション スコープのプロパティを格納している <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> は、アプリケーションスコープのプロパティを格納するために使用できる <xref:System.Windows.Application.Properties%2A> を介してディクショナリを公開します。 これにより、独自の状態コードを記述することなく、スレッドセーフな方法で <xref:System.AppDomain> のすべてのコード間で状態を共有できます。  
  
 <xref:System.Windows.Application.Properties%2A> に格納されているプロパティは、返される適切な型に変換する必要があります。  
  
 <xref:System.Windows.Application.Properties%2A> プロパティはスレッドセーフであり、任意のスレッドから使用できます。  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Application.Properties%2A>を使用して、アプリケーションスコープのプロパティを作成して使用する方法を示します。  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Reflection.Assembly" /> アプリケーションのリソース用のパッケージの Uniform Resource Identifier (URI) を提供する [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] を取得または設定します。</summary>
        <value>[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アプリケーション内のリソースのパッケージ Uri (uniform resource identifier) を提供する <see cref="T:System.Reflection.Assembly" /> への参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] リソースは、<xref:System.Reflection.Assembly.GetEntryAssembly%2A> メソッドから返された値によって識別されるエントリアセンブリに対して実行時に解決されます。  
  
 エントリアセンブリは <xref:System.Reflection.Assembly.GetEntryAssembly%2A> によって返されるアセンブリであり、次のようになります。  
  
-   既定のアプリケーションドメイン内の実行可能アセンブリ。  
  
-   <xref:System.AppDomain.ExecuteAssembly%2A>を呼び出すことによって実行される最初のアセンブリ。  
  
 ただし、次の場合は、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリがエントリアセンブリへの参照を取得できません。  
  
-   アンマネージ (ネイティブ) アプリケーションは、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリをホストします。  
  
-   マネージアプリケーションは、<xref:System.AppDomain.ExecuteAssembly%2A>以外のメソッドを使用して新しいアプリケーションドメインに読み込むことによって、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリをホストします。  
  
 どちらの場合も、<xref:System.Reflection.Assembly.GetEntryAssembly%2A> は `null`を返し、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリのリソースを解決することはできません。 このような場合、<xref:System.Windows.Application.ResourceAssembly%2A> は、リソースを解決するために使用するアセンブリへの参照を使用して1回だけ設定できます。  
  
 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリが読み込まれた後にリソースアセンブリが変更される可能性が低いため、<xref:System.Windows.Application.ResourceAssembly%2A> を1回だけ設定できます。  
  
> [!NOTE]
>  <xref:System.Reflection.Assembly.GetEntryAssembly%2A> が `null`ではなくアセンブリへの参照を返す場合、[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アセンブリがエントリアセンブリを検出できるときに <xref:System.Windows.Application.ResourceAssembly%2A> を設定することはできません。  
  
 このプロパティはスレッドセーフであり、任意のスレッドから使用できます。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> は .NET Framework バージョン3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アプリケーションに入力アセンブリがあるか、<see cref="P:System.Windows.Application.ResourceAssembly" /> が既に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイルやブラシなど、アプリケーション スコープ リソースのコレクションを取得または設定します。</summary>
        <value>0 個以上のアプリケーション スコープ リソースが格納された <see cref="T:System.Windows.ResourceDictionary" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> プロパティを使用して、アプリケーションのウィンドウと要素間でリソースを共有できます。 また、<xref:System.Windows.Application.Resources%2A> プロパティは、次の順序で走査されるリソース参照パスに含まれています。  
  
1.  要素  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  システム  
  
 その結果、[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 要素はアプリケーションスコープのリソースにバインドできます。 また、リソースが変更された場合、リソースシステムによって、リソースにバインドされている要素のプロパティが自動的に更新され、変更が反映されます。  
  
 アプリケーションスコープリソースは、アプリケーション全体で一貫したテーマをサポートするための簡単な方法を提供します。 `Application.Resources` タグを使用すると、[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] でテーマを簡単に作成できます。 ただし、多数のテーマ要素を含む複数のテーマがアプリケーションでサポートされている場合は、テーマごとに1つの <xref:System.Windows.ResourceDictionary> インスタンスを使用してそれらを管理する方が簡単な場合があります。 この方法では、Resources プロパティを適切な <xref:System.Windows.ResourceDictionary>に設定することによって、新しいテーマを適用できます。  
  
 <xref:System.Windows.Application.Resources%2A>を使用する場合は、2つの点を考慮する必要があります。 まず、ディクショナリ*キー*はオブジェクトであるため、プロパティ値の設定と取得の両方で同じオブジェクトインスタンスを使用する必要があります (文字列を使用する場合は、キーの大文字と小文字が区別されることに注意してください)。 2つ目は、ディクショナリ*値*がオブジェクトであるため、プロパティ値を取得するときに、値を目的の型に変換する必要があります。  
  
 <xref:System.Windows.Application.Resources%2A> はスレッドセーフであり、任意のスレッドから使用できます。  
  
   
  
## Examples  
この例では、XAML をアプリケーションスコープのリソースと共に使用して、一貫した外観を作成する方法を示します。 最初の例は、 *app.xaml*からのものです。2番目の。 *mainwindow.xaml*からです。 
  
[!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml?highlight=7)]  
  
 次の例は、コードおよび XAML でアプリケーションリソースを設定する方法を示しています ( C# wpf プロジェクトの app.xaml ファイルまたは Visual Basic wpf プロジェクトの app.xaml ファイル)。  
  
 [!code-csharp[Setting-an-application-resource-in-code](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[Setting-an-application-resource-in-code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[Setting-an-application-resource-in-XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml?highlight=8-10)]  
  
 次の例は、コードでアプリケーションリソースを取得する方法を示しています。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Windows Presentation Foundation アプリケーションを開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Windows Presentation Foundation アプリケーションを開始します。</summary>
        <returns>アプリケーションのシャットダウン時にオペレーティング システムに返される <see cref="T:System.Int32" /> アプリケーション終了コード。 終了コードの既定値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] アプリケーションを起動するために <xref:System.Windows.Application.Run%2A> が呼び出されます。 マークアップ、マークアップ、分離コードを使用して <xref:System.Windows.Application> を定義すると、<xref:System.Windows.Application.Run%2A> が暗黙的に呼び出されます。 ただし、コードを使用して <xref:System.Windows.Application> を定義する場合は、<xref:System.Windows.Application.Run%2A>を明示的に呼び出す必要があります。  
  
 <xref:System.Windows.Application.Run%2A> が呼び出されると、<xref:System.Windows.Application> 新しい <xref:System.Windows.Threading.Dispatcher> インスタンスを UI スレッドにアタッチします。 次に、<xref:System.Windows.Threading.Dispatcher> オブジェクトの <xref:System.Windows.Threading.Dispatcher.Run%2A> メソッドが呼び出されます。これにより、windows メッセージを処理するメッセージポンプが開始されます。 最後に、<xref:System.Windows.Threading.Dispatcher> オブジェクトは、<xref:System.Windows.Application> オブジェクトの <xref:System.Windows.Application.OnStartup%2A> メソッドを呼び出して、<xref:System.Windows.Application.Startup> イベントを発生させます。 このため、アプリケーションの実行モデルは、<xref:System.Windows.Application.Startup>を処理する時間によって確立され、その時点でアプリケーションは実行されていると見なされます。  
  
 <xref:System.Windows.Application.Shutdown%2A> が呼び出されると、アプリケーションは実行を停止します。<xref:System.Windows.Application.ShutdownMode%2A> プロパティの値によって <xref:System.Windows.Application.Shutdown%2A> が呼び出されるタイミングと、自動的に行われるか、または明示的に呼び出す必要があるかが決まります。  
  
 <xref:System.Windows.Application.Run%2A> は、<xref:System.Windows.Application> オブジェクトを作成するスレッドからのみ呼び出すことができます。 また、[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]から <xref:System.Windows.Application.Run%2A> を呼び出すことはできません。  
  
   
  
## Examples  
 次の例は、カスタム <xref:System.Windows.Application> を使用し、そのため <xref:System.Windows.Application.Run%2A>を明示的に呼び出す必要があるアプリケーションを示しています。  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> は、ブラウザーによってホストされるアプリケーション ([!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] など) から呼び出されます。</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">アプリケーションの起動時に自動的に開く <see cref="T:System.Windows.Window" />。</param>
        <summary>Windows Presentation Foundation アプリケーションを開始し、指定したウィンドウを開きます。</summary>
        <returns>アプリケーションのシャットダウン時にオペレーティング システムに返される <see cref="T:System.Int32" /> アプリケーション終了コード。 終了コードの既定値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、アプリケーションの実行が開始された後に、指定したウィンドウを開くために <xref:System.Windows.Application.Run%2A> メソッドを拡張します。  
  
 実行開始時にウィンドウを開く <xref:System.Windows.Application> コードを定義する場合は、明示的に <xref:System.Windows.Application.Run%2A>を呼び出します。  
  
 マークアップ、マークアップ、分離コードを使用して <xref:System.Windows.Application> を作成する場合は、次のいずれかの方法を使用して、ウィンドウを自動的に開くことができます。  
  
-   宣言によって、<xref:System.Windows.Application.StartupUri%2A>を設定します。  
  
-   プログラムで <xref:System.Windows.Application.Startup>を処理します。  
  
   
  
## Examples  
 次の例は、<xref:System.Windows.Application.Run%2A>を呼び出す前に、<xref:System.Windows.Application>をインスタンス化する、手動で作成された静的なエントリポイントメソッドを持つアプリケーションを示しています。  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> は、ブラウザーによってホストされるアプリケーション ([!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] など) から呼び出されます。</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがログオフするかオペレーティング システムをシャットダウンして、Windows セッションを終了するときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、Windows セッションが終了すると、アプリケーションがシャットダウンされます。これは、ユーザーがログオフまたはシャットダウンしたときに発生します。 この場合、Windows は、開いているアプリケーションをシャットダウンするように要求します。 ただし、この問題が発生した場合、アプリケーションをシャットダウンする準備ができていない可能性があります。 たとえば、一貫性のない状態のデータや、実行時間の長い操作の途中にあるアプリケーションがあるとします。 このような状況では、セッションが終了しないようにすることが望ましい場合があります。また、セッションを終了させるかどうかをユーザーが選択できるようにすることが望ましい場合もあります。  
  
 <xref:System.Windows.Application.SessionEnding> イベントを処理することによって、セッションが終了したことを検出できます。 アプリケーションでセッションが終了しないようにする必要がある場合、イベントハンドラーに渡される <xref:System.Windows.SessionEndingCancelEventArgs> 引数は `true` に設定した <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> を公開します (既定値は `false`)。  
  
 <xref:System.Windows.Application.SessionEnding> が処理されない場合、または取り消されずに処理される場合、<xref:System.Windows.Application.Shutdown%2A> が呼び出され、<xref:System.Windows.Application.Exit> イベントが発生します。  
  
 セッションが終了する理由に関する詳細情報を取得するには、アプリケーションで <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>を調べることができます。これは、<xref:System.Windows.ReasonSessionEnding> 値 (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> および <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>) の1つです。  
  
 <xref:System.Windows.Application.SessionEnding> は、コンソールアプリケーションでは発生しません。  
  
 <xref:System.Windows.Application.SessionEnding> は、<xref:System.Windows.Application> オブジェクトを作成するスレッドでのみ発生します。  
  
 <xref:System.Windows.Application.SessionEnding> は、XAML ブラウザーアプリケーション (Xbap) に対しては発生しません。  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Application.SessionEnding> イベントを処理し、ユーザーがこのイベントをキャンセルできるようにする方法を示します。  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">クッキーを作成する場所を指定する <see cref="T:System.Uri" />。</param>
        <param name="value">クッキー データを格納している <see cref="T:System.String" />。</param>
        <summary><see cref="T:System.Uri" /> で指定した場所にクッキーを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cookie は任意のデータであり、アプリケーションセッション (セッション cookie) 中、またはアプリケーションセッション (永続的なクッキー) 間で、アプリケーションによってクライアントコンピューターに格納できます。 <xref:System.Windows.Application.SetCookie%2A>を呼び出すことによって、両方の種類の cookie を作成できます。  
  
 Cookie データは、通常、次の形式で名前と値のペアの形式になります。  
  
 `Name=Value`  
  
 この形式の文字列を <xref:System.Windows.Application.SetCookie%2A>に渡し、cookie を設定する場所の <xref:System.Uri> (通常はアプリケーションドメイン) を指定します。  
  
 Cookie がセッション cookie であるか、永続的な cookie であるかは、<xref:System.Windows.Application.SetCookie%2A> に渡す cookie 文字列に有効期限が含まれているかどうかによって異なります。 セッション cookie の文字列に有効期限が含まれていません。 永続的な cookie の文字列は、次の形式で指定する必要があります。  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 永続 cookie は、有効期限が切れるまで、現在の [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] インストールの Temporary Internet Files フォルダーに格納されます。その場合は削除されます。 アプリケーションから永続的な cookie を削除するには、有効期限を過去の日付/時刻値に設定します。  
  
 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]の cookie の概要については、「[ナビゲーションの概要](~/docs/framework/wpf/app-development/navigation-overview.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">指定したクッキー作成の試行中に問題が起きると、([!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] から呼び出された) <see langword="InternetSetCookie" /> 関数により <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" /> エラーが発生します。</exception>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーションをシャットダウンします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションをシャットダウンします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Shutdown%2A> が呼び出されると、アプリケーションは実行を停止します。 <xref:System.Windows.Application.Exit> イベントを処理して、アプリケーションが実行を停止しようとしていることを検出し、適切な処理を実行できます。  
  
 <xref:System.Windows.Application.Shutdown%2A> は、次の状況で Windows Presentation Foundation によって暗黙的に呼び出されます。  
  
-   <xref:System.Windows.Application.ShutdownMode%2A> が <xref:System.Windows.ShutdownMode.OnLastWindowClose>に設定されている場合。  
  
-   <xref:System.Windows.Application.ShutdownMode%2A> が <xref:System.Windows.ShutdownMode.OnMainWindowClose>に設定されている場合。  
  
-   ユーザーがセッションを終了し、<xref:System.Windows.Application.SessionEnding> イベントが未処理であるか、キャンセルせずに処理された場合。  
  
 <xref:System.Windows.Application.Shutdown%2A> を呼び出すと、<xref:System.Windows.Application.ShutdownMode%2A> の設定に関係なく、アプリケーションがシャットダウンされます。 ただし、<xref:System.Windows.Application.ShutdownMode%2A> が <xref:System.Windows.ShutdownMode.OnExplicitShutdown>に設定されている場合は、アプリケーションをシャットダウンするために <xref:System.Windows.Application.Shutdown%2A> を呼び出す必要があります。  
  
> [!IMPORTANT]
>  <xref:System.Windows.Application.Shutdown%2A> が呼び出されると、開いているウィンドウの <xref:System.Windows.Window.Closing> イベントがキャンセルされたかどうかに関係なく、アプリケーションはシャットダウンします。  
  
 このメソッドは、<xref:System.Windows.Application> オブジェクトを作成したスレッドからのみ呼び出すことができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">アプリケーションの整数型終了コード。 既定の終了コードは 0 です。</param>
        <summary>アプリケーションをシャットダウンして、指定した終了コードをオペレーティング システムに返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Exit> イベントを処理して終了コードを設定できます。 ただし、明示的に <xref:System.Windows.Application.Shutdown%2A>を呼び出し、終了コードを設定するためだけに <xref:System.Windows.Application.Exit> を処理する場合は、代わりに <xref:System.Windows.Application.Shutdown%2A> を呼び出すことができます。  
  
 このメソッドは、<xref:System.Windows.Application> オブジェクトを作成したスレッドからのみ呼び出すことができます。  
  
 終了コードの詳細については、「<xref:System.Environment.ExitCode%2A?displayProperty=nameWithType>」を参照してください。
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Application.Shutdown" /> メソッドが呼び出される条件を取得または設定します。</summary>
        <value><see cref="T:System.Windows.ShutdownMode" /> 列挙値です。 既定値は <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションの <xref:System.Windows.Application.Shutdown%2A> メソッドが呼び出された場合にのみ、アプリケーションの実行が停止します。 シャットダウンは、<xref:System.Windows.Application.ShutdownMode%2A> プロパティの値によって指定されたように、暗黙的または明示的に発生する場合があります。  
  
 <xref:System.Windows.Application.ShutdownMode%2A> を <xref:System.Windows.ShutdownMode.OnLastWindowClose>に設定した場合、Windows Presentation Foundation (WPF) は、現在インスタンス化されているウィンドウがメインウィンドウとして設定されている場合でも、アプリケーションの最後のウィンドウを閉じると暗黙的に <xref:System.Windows.Application.Shutdown%2A> を呼び出します (「<xref:System.Windows.Application.MainWindow%2A>」を参照)。  
  
 <xref:System.Windows.ShutdownMode.OnMainWindowClose> の <xref:System.Windows.Application.ShutdownMode%2A> により、他のウィンドウが現在開いている場合でも、WPF は <xref:System.Windows.Application.MainWindow%2A> が閉じるときに <xref:System.Windows.Application.Shutdown%2A> を暗黙的に呼び出します。  
  
 一部のアプリケーションの有効期間は、メインウィンドウまたは最後のウィンドウが閉じられたとき、または windows に依存していない場合に依存しないことがあります。 これらのシナリオでは、<xref:System.Windows.Application.ShutdownMode%2A> プロパティを <xref:System.Windows.ShutdownMode.OnExplicitShutdown>に設定する必要があります。そのためには、アプリケーションを停止するための明示的な <xref:System.Windows.Application.Shutdown%2A> メソッド呼び出しが必要です。 それ以外の場合、アプリケーションはバックグラウンドで実行を継続します。  
  
 <xref:System.Windows.Application.ShutdownMode%2A> は、[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] またはプログラムによってコードから宣言して構成できます。  
  
 このプロパティは、<xref:System.Windows.Application> オブジェクトを作成したスレッドからのみ使用できます。  
  
   
  
## Examples  
 次の例は、アプリケーションを明示的に閉じる必要があることを指定するように <xref:System.Windows.Application.ShutdownMode%2A> を構成する方法を示しています。  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Application.Run" /> オブジェクトの <see cref="T:System.Windows.Application" /> メソッドが呼び出されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的な Windows Presentation Foundation アプリケーションでは、起動時に次のようなさまざまな初期化タスクを実行できます。  
  
-   コマンドラインパラメーターを処理しています。  
  
-   メインウィンドウを開きます。  
  
-   アプリケーションスコープのリソースを初期化しています。  
  
-   アプリケーションスコープのプロパティを初期化しています。  
  
 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> と <xref:System.Windows.Application.Resources%2A>をそれぞれ使用して、メインウィンドウとアプリケーションスコープのリソースを宣言によって指定できます。 ただし、アプリケーションのリソースまたはメインウィンドウは、実行時にプログラムによってのみ決定できることもあります。 また、アプリケーションスコープのプロパティとコマンドラインパラメーターは、プログラムでのみ使用できます。 プログラムによる初期化は、次のような <xref:System.Windows.Application.Startup> イベントを処理することによって実行できます。  
  
-   <xref:System.Windows.Application.Startup> イベントハンドラーに渡される <xref:System.Windows.StartupEventArgs> クラスの <xref:System.Windows.StartupEventArgs.Args%2A> プロパティから使用できるコマンドラインパラメーターを取得して処理します。  
  
-   <xref:System.Windows.Application.Resources%2A> プロパティを使用して、アプリケーションスコープのリソースを初期化します。  
  
-   <xref:System.Windows.Application.Properties%2A> プロパティを使用して、アプリケーションスコープのプロパティを初期化します。  
  
-   1つまたは複数のウィンドウをインスタンス化して表示します。  
  
> [!NOTE]
>  コマンドラインパラメーターは、<xref:System.Environment> オブジェクトの静的 <xref:System.Environment.GetCommandLineArgs%2A> メソッドを呼び出すことによって取得することもできます。 ただし、<xref:System.Environment.GetCommandLineArgs%2A> を実行するには完全な信頼が必要です。  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]を使用して <xref:System.Windows.Application.StartupUri%2A> を設定した場合、作成されるメインウィンドウは、<xref:System.Windows.Application> イベントが処理されるまで、<xref:System.Windows.Application.Startup> オブジェクトの <xref:System.Windows.Application.MainWindow%2A> プロパティまたは <xref:System.Windows.Application.Windows%2A> プロパティからは使用できません。 起動時にメインウィンドウにアクセスする必要がある場合は、<xref:System.Windows.Application.Startup> イベントハンドラーから新しいウィンドウオブジェクトを手動で作成する必要があります。  
  
> [!NOTE]
>  アプリケーションで <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> を使用して資格情報ポリシーを指定する場合は <xref:System.Windows.Application.Startup> が発生した後に <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> を設定する必要があります。それ以外の場合、<xref:System.Windows.Application.Startup> イベントが発生した直後に既定の内部ポリシーに設定 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ます。  
  
 <xref:System.Windows.Application.Startup> イベントハンドラーに渡されるコマンドライン引数は、[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]に渡される [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] のクエリ文字列パラメーターと同じではありません。  
  
   
  
## Examples  
 次の例では、スタンドアロンアプリケーションからコマンドラインオプションを取得して処理する方法を示します。 **/Start最小化**されたコマンドラインパラメーターを指定した場合、アプリケーションはメインウィンドウを最小化された状態で開きます。  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] は [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] 配置で起動されるため、コマンドライン引数を取得して処理することはできません (「 [Wpf アプリケーションの配置 (wpf)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)」を参照してください)。 ただし、起動に使用される URL のクエリ文字列パラメーターを取得して処理することはできます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの起動時に自動的に表示される UI を取得または設定します。</summary>
        <value>アプリケーションの起動時に自動的に開く UI を参照する <see cref="T:System.Uri" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.StartupUri%2A> を使用すると、アプリケーションの起動時に UI リソースを自動的に読み込むことができます。  
  
 次の表に、読み込むことができる UI リソースの種類、それらが開かれるウィンドウの種類、およびこれらのリソースを <xref:System.Windows.Application.StartupUri%2A>として設定できるアプリケーションの種類を示します。  
  
|種類|ウィンドウ|アプリケーションの種類|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|スタンドアロンのみ|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロンのみ|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン/ブラウザーでホスト|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン/ブラウザーでホスト|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン/ブラウザーでホスト|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|スタンドアロン/ブラウザーでホスト|  
  
 通常は、[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]で <xref:System.Windows.Application.StartupUri%2A> プロパティを宣言によって設定します。 ただし、必要な UI リソースを実行時にしか読み込むことができないアプリケーションの場合に便利な、<xref:System.Windows.Application.Startup> イベントハンドラーなどのプログラムを使用して <xref:System.Windows.Application.StartupUri%2A> を設定することができます。 たとえば、UI リソースの名前が構成ファイルに格納されている場合、アプリケーションは実行時まで待機してリソースを読み込むことができます。  
  
 <xref:System.Windows.Application.StartupUri%2A> を宣言またはプログラムによって設定した場合でも、対応する UI リソースは、<xref:System.Windows.Application.Startup> イベントが処理されるまで読み込まれません。 そのため、<xref:System.Windows.Application.Startup>を処理するときに、<xref:System.Windows.Application.Windows%2A> プロパティまたは <xref:System.Windows.Application.MainWindow%2A> プロパティから結果のウィンドウにアクセスすることはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> に null の値が設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">要求されたアンビエント プロパティの名前。</param>
        <summary>指定されたアンビエント プロパティを現在のスコープで使用できるかどうかを照会します。</summary>
        <returns>要求されたアンビエント プロパティを使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Windows.Application> のインスタンスが <xref:System.Windows.Markup.IQueryAmbient> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">検索するリソースの名前。</param>
        <summary>指定したリソースを検索します。</summary>
        <returns>要求されたリソース オブジェクト。 要求したリソースが見つからない場合は、null 参照が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> は、まず、指定されたリソースのアプリケーションスコープのリソースを確認します。 アプリケーションスコープのリソースは <xref:System.Windows.Application>によって管理され、<xref:System.Windows.Application.Resources%2A> プロパティから公開されます。 指定されたリソースがアプリケーションスコープリソースのセットに見つからない場合、<xref:System.Windows.Application.TryFindResource%2A> はシステムリソースを検索します。 システムリソースは、ユーザーが定義したシェルリソースであり、色、フォント、およびシェルの構成が含まれます。 これらは、それぞれ <xref:System.Windows.SystemColors>、<xref:System.Windows.SystemFonts>、および <xref:System.Windows.SystemParameters> 型から静的プロパティとして公開されます。 これらの型を取得するために <xref:System.Windows.Application.TryFindResource%2A> を使用するには、<xref:System.Windows.Application.TryFindResource%2A>に渡すように設計されたリソースキープロパティも公開します。たとえば、<xref:System.Windows.SystemParameters.IconWidthKey%2A>のようにします。  
  
 <xref:System.Windows.Application.TryFindResource%2A> はオブジェクトを返すため、リソースが見つかった場合は、返された値を適切な型にキャストする必要があります。  
  
 このメソッドはスレッドセーフであり、任意のスレッドから呼び出すことができます。  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.Application.TryFindResource%2A> を使用してリソースを取得する方法を示します。  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションでインスタンス化されたウィンドウを取得します。</summary>
        <value>現在の <see cref="T:System.Windows.WindowCollection" /> のすべてのウィンドウ オブジェクトへの参照を格納している <see cref="T:System.AppDomain" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] スレッドでウィンドウがインスタンス化されるとすぐに、<xref:System.Windows.Application.Windows%2A> に <xref:System.Windows.Window> 参照が自動的に追加されます。ワーカースレッドによって作成されたウィンドウは追加されません。 <xref:System.Windows.Window> 参照は、<xref:System.Windows.Window.Closing> イベントが処理された後、その <xref:System.Windows.Window.Closed> イベントが発生する前に、自動的に削除されます。  
  
 既定では、<xref:System.Windows.Application.Windows%2A> プロパティに追加された最初の項目が <xref:System.Windows.Application.MainWindow%2A>になります。  
  
 このプロパティは、<xref:System.Windows.Application> オブジェクトを作成したスレッドからのみ使用できます。  
  
   
  
## Examples  
 次の例は、<xref:System.Windows.Application.Windows%2A> プロパティを列挙してトップレベルの Windows メニューを構築する方法を示しています。これは、[!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]などの [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] アプリケーションや、[!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)]などの複数インスタンスのシングルドキュメントインターフェイス (SDI) アプリケーションに共通しています。  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>
