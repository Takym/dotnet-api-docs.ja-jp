<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="95c0765345a2b3868b6509d0a8dab864fe9bb2ef" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78843412" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ルーティング イベントに関連付けられている状態情報とイベント データを格納します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1つの <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>で異なる <xref:System.Windows.RoutedEventArgs> を使用できます。 このクラスは、<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>のイベントデータをパッケージ化し、追加のイベント状態情報を提供します。このクラスは、ルーティングイベントに関連付けられたハンドラーを呼び出すために、イベントシステムによって使用されます。  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このパラメーターなしのコンストラクターを使用する場合、新しい <xref:System.Windows.RoutedEventArgs> インスタンスのすべてのパブリックプロパティは、次の既定値を想定します。  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> では、既定値が `null` に設定されます。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> では、既定値が `null` に設定されます。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> では、既定値が `null` に設定されます。  
  
 <xref:System.Windows.RoutedEventArgs.Source%2A> および <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> の Null 値は、<xref:System.Windows.RoutedEventArgs> データがソースを指定しようとしていないことを意味します。 このインスタンスが <xref:System.Windows.UIElement.RaiseEvent%2A>の呼び出しで使用されている場合、<xref:System.Windows.RoutedEventArgs.Source%2A> と <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> の値は、イベントを発生させた要素に基づいて設定され、ルーティングを介してリスナーに渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (routedEvent As RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードされたコンストラクターを使用する場合、新しい <xref:System.Windows.RoutedEventArgs> インスタンスの未指定のプロパティは、次の既定値を想定します。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> では、既定値が `null` に設定されます。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> では、既定値が `null` に設定されます。  
  
 <xref:System.Windows.RoutedEventArgs.Source%2A> および <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> の Null 値は、この <xref:System.Windows.RoutedEventArgs> がソースを指定しようとしていないことを意味します。 このインスタンスが <xref:System.Windows.UIElement.RaiseEvent%2A>の呼び出しで使用されている場合、<xref:System.Windows.RoutedEventArgs.Source%2A> と <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> の値は、イベントを発生させた要素に基づいて設定され、ルーティングを介してリスナーに渡されます。  
  
   
  
## Examples  
 次の例では、<xref:System.Windows.UIElement.RaiseEvent%2A>への呼び出しで使用する新しい <xref:System.Windows.RoutedEventArgs> を構築します。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (routedEvent As RoutedEvent, source As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <param name="source">イベントの処理時に報告される代替ソース。 <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティに、このソースが事前設定されます。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。また、このコンストラクターでは、イベントに対して異なるソースを宣言することができます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードされたコンストラクターを使用する場合、新しい <xref:System.Windows.RoutedEventArgs> インスタンスの未指定のプロパティは、次の既定値を想定します。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値 `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> では、既定値が `null` に設定されます。  
  
 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> の Null 値は、イベントを発生させてルーティング経由で渡される要素に基づいて設定されますが、呼び出しの前に `null` が読み取られます。  
  
 このシグネチャは、<xref:System.Windows.RoutedEventArgs> を <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>などの純粋に渡すときに使用します。引数は、内部で <xref:System.Windows.UIElement.RaiseEvent%2A> を呼び出すために使用されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ルーティング イベントがルートをたどる際のイベント処理の現在の状態を示す値を取得または設定します。</summary>
        <value>設定時に、イベントを処理済みとしてマークする場合は <see langword="true" /> 、マークしない場合は <see langword="false" />に設定します。 この値を読み取る場合、 <see langword="true" /> は、クラス ハンドラーまたはルート上にある一部のインスタンス ハンドラーのいずれかが、このイベントを処理済みとして既にマークしていることを示します。 <see langword="false" /> は、いずれのハンドラーもイベントを処理済みとしてマークしていないことを示します。  
  
既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを処理済みとしてマークすると、ルーティングイベントの可視性が、イベントルートに沿ったリスナーに制限されます。 イベントは引き続きルートの残りの部分を移動しますが、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> メソッドの呼び出しで明示的に追加されたハンドラーのみが応答として呼び出されます。 `HandledEventsToo` `true`。 インスタンスリスナーの既定のハンドラー ([!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]で表されるものなど) は呼び出されません。 処理済みとマークされたイベントの処理は、一般的なシナリオではありません。  
  
 独自のイベントを定義しているコントロール作成者は、クラスレベルでのイベント処理に関して行った決定によって、コントロールのユーザーと、コントロールに含まれている可能性のあるその他の要素に影響を与えます。または、コントロールを格納している。 詳細については、「[ルーティング イベントの処理済みとしてのマーキング、およびクラス処理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)」を参照してください。  
  
 非常にまれな状況では、<xref:System.Windows.RoutedEventArgs.Handled%2A> が `true`としてマークされているイベントを処理し、<xref:System.Windows.RoutedEventArgs.Handled%2A> を `false`に変更することでイベント引数を変更することが適切です。 これは、コントロールの入力イベントの特定の領域で必要になることがあります。たとえば、低いレベルの入力イベントと高いレベルの入力イベントが処理に対して競合し、それぞれが異なるルーティング方法を使用しようとしている場合に、<xref:System.Windows.UIElement.KeyDown> と <xref:System.Windows.UIElement.TextInput> のキー処理が行われます。  
  
   
  
## Examples  
 次の例では、イベントを処理済みとしてマークするイベントハンドラーを実装しています。  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">呼び出すジェネリック ハンドラー/デリゲート実装。</param>
        <param name="genericTarget">指定したハンドラーが呼び出されるターゲット。</param>
        <summary>派生クラスでオーバーライドされた場合、型固有の方法でイベント ハンドラーを呼び出す方法を提供します。これにより、基本実装よりも効率が向上する場合があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本実装にはリフレクションが組み込まれています。これにより、ハンドラーが文字どおり <xref:System.Windows.RoutedEventHandler>でない場合に適したハンドラーが決定され、このリフレクションの手順によってパフォーマンスが低下します。 呼び出しは、リフレクションに依存しないことで、より効率的に行うことができます。 これは、オーバーライドを選択する任意のルーティングイベント引数クラスでこのメソッドを使用できるようにためするシナリオです。 実装では、型セーフハンドラーを呼び出す必要があるため、このメソッドの基本を呼び出すことはできません。  
  
   
  
## Examples  
 次に示すのは、実装に使用できる基本的なパターンを示す擬似コードです。 ここでは、`MyRoutedEventHandler` は <xref:System.Windows.RoutedEventHandler>のサブクラスです。  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>このメソッドは、派生イベントデータクラスによってオーバーライドされ、デリゲートのより効率的な呼び出しを提供するためのものです。 実装では、指定された <paramref name="genericHandler" /> を型固有のデリゲートにキャストし、そのハンドラーを呼び出す必要があります。  
  
既定の実装は、指定されたハンドラーを呼び出そうとして、<see cref="T:System.Windows.RoutedEventHandler" />としてキャストしようとします。 <paramref name="genericHandler" /> または <paramref name="genericTarget" /> のいずれかが <see langword="null" />として指定されている場合、例外が発生します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="P:System.Windows.RoutedEventArgs.Source" /> に設定する新しい値。</param>
        <summary>派生クラスでオーバーライドした場合、インスタンスの <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティの値が変更されるたびに、通知コールバックのエントリ ポイントを提供します。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>報告されたイベントソースをプログラムによって変更すると、イベント内の型固有のデータを更新する必要が生じる可能性があります。 このため、<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> メソッドは保護された仮想であり、<see cref="T:System.Windows.RoutedEventArgs" />のサブクラスによってオーバーライドされることを意図しています。  
  
このメソッドには既定の実装がありません。</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親クラスによって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、純粋なヒット テストで判断される元の報告ソースを取得します。</summary>
        <value>複合要素ツリーを平坦化するなどの目的でクラス処理によって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、元の報告ソース。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、クラスイベントハンドラーまたはインスタンスハンドラーが呼び出される前に値を1回取得し、この時点以降は調整されません。 元のソース情報は、イベントデータで報告される場合と同様に、クラスハンドラーまたはクラスの実装に対して読み取り専用になります。  
  
 ソースが調整される可能性のある一般的なケースとしては、コントロールのコンテンツモデル内のコンテンツ要素 (リスト項目の内容など) によって、リスト項目要素が <xref:System.Windows.RoutedEventArgs.Source%2A> として報告され、リスト項目内の実際の要素が <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>になります。  
  
 さまざまな要素およびコンテンツモデルによるソース調整は、クラスごとに異なります。 イベントソースを調整する各クラスは、ほとんどの入力シナリオおよびクラスが意図しているシナリオについてレポートするのに最も役に立つソースを予測し、そのソースを <xref:System.Windows.RoutedEventArgs.Source%2A>として設定します。 このソースがイベントの処理に関連するものではない場合は、<xref:System.Windows.RoutedEventArgs.OriginalSource%2A> を確認して、より適切な別のソースを報告しているかどうかを確認してください。 入力イベントの詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> インスタンスに関連付けられている <see cref="T:System.Windows.RoutedEventArgs" /> を取得または設定します。</summary>
        <value>呼び出されたイベントの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既にルーティングされている <xref:System.Windows.RoutedEventArgs> にこの値を設定することはできません (たとえば、ハンドラーから引数を取得した場合)。 これを行おうとすると、例外が発生します。 イベントの呼び出しを生成するためにまだ使用されていないインスタンスでのみ設定できます。  
  
 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> の値は、いつでも `null` できません。  
  
   
  
## Examples  
 次の例では、初期コンストラクターを使用して新しいルーティングイベントデータを作成し、後続の操作として <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> プロパティを設定します。 ルーティングイベントを発生させる前に、<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 設定しておく必要があります。  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベントのルーティング中に <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 値を変更しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを発生させたオブジェクトへの参照を取得または設定します。</summary>
        <value>イベントを発生させたオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルートを発生させた要素の後に実際に移動したすべてのバブルルーティングイベントに対して、まだトンネルダウンされていないトンネリングルーティングイベントの場合、<xref:System.Windows.RoutedEventArgs.Source%2A> の値は、イベント引数クラスの `sender` パラメーターの値とは異なります。 イベントに関係する2つの要素のうち、特定のハンドラー (<xref:System.Windows.RoutedEventArgs.Source%2A>、そのハンドラーを発生させた要素、または `sender`で最も重要な要素は、ハンドラーが処理しているアプリケーションロジックによって異なります。  
  
 このプロパティの設定は、通常、イベントソースを調整する他の Api をオーバーライドまたは実装する場合 (クラスがイベントを処理する場合など) にのみ実行されます。 特にハンドラーがイベントを処理済みとしてマークしない場合、インスタンスハンドラーからの見かけ上のイベントソースのリセットは推奨されません。  
  
 別のイベントソースをレポートするために <xref:System.Windows.RoutedEventArgs.Source%2A> をリセットすると、<xref:System.Windows.RoutedEventArgs.OriginalSource%2A> は元の <xref:System.Windows.UIElement.RaiseEvent%2A> 呼び出しによって最初に発生したソースを報告し続けます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>
