<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c23786d83ef2e28eca7b69128c8f9b14b1dde4ae" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70345348" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="FileSystem" /> モジュールに含まれるプロシージャを使って、ファイル、ディレクトリ、またはフォルダー、およびシステムの操作を実行します。 <see langword="My" /> 機能を使用すると、<see langword="FileSystem" /> モジュールを使用した場合よりファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このモジュールは、ファイルとフォルダーにアクセスする Visual Basic 言語キーワードとランタイムライブラリメンバーをサポートしています。  
  
   
  
## Examples  
 この例では`GetAttr` 、関数を使用して、ファイル、ディレクトリ、またはフォルダーの属性を決定します。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">ディレクトリとファイルの概要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">入出力の概要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">キーワード (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">ランタイムライブラリのメンバーの Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDir(string Path) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須です。 新しい既定ディレクトリまたはフォルダーになるディレクトリまたはフォルダーを識別する文字列式です。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="ChDir" /> は現在のドライブの既定ディレクトリまたは既定フォルダーを変更します。</param>
        <summary>現在のディレクトリまたはフォルダーを変更します。 <see langword="My" /> 機能を使用すると、<see langword="ChDir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`ChDir`は既定のディレクトリを変更しますが、既定のドライブは変更しません。 たとえば、既定のドライブが C の場合、次のステートメントではドライブ D の既定のディレクトリが変更されますが、C は既定のドライブのままです。  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 相対ディレクトリを変更するには、次のように2つのピリオドを入力します。  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  関数`ChDir`には、部分信頼の状況での実行に影響する可能性があるアンマネージコードのアクセス許可が必要です。 詳細については<xref:System.Security.Permissions.SecurityPermission> 、「」および「」を参照してください。  
  
   
  
## Examples  
 この例では`ChDir` 、関数を使用して、現在のディレクトリまたはフォルダーを変更します。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> が空です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">方法 : Visual Basic でファイル パスを解析する</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Visual Basic でのファイルおよびディレクトリの作成、削除、および移動</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のドライブを変更します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDrive(char Drive) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必須です。 既存のドライブを指定する文字列式。 長さ 0 の文字列 ("") を指定した場合、現在のドライブは変更されません。 <paramref name="Drive" /> 引数が複数の文字で構成される文字列の場合、<see langword="ChDrive" /> は先頭の文字だけを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`ChDrive`にはアンマネージコードのアクセス許可が必要です。これは、部分信頼状況での実行に影響する可能性があります。 詳細については<xref:System.Security.Permissions.SecurityPermission> 、「」および「[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
   
  
## Examples  
 この例では`ChDrive` 、関数を使用して現在のドライブを変更します。 この関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChDrive(string Drive) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必須です。 既存のドライブを指定する文字列式。 長さ 0 の文字列 ("") を指定した場合、現在のドライブは変更されません。 <paramref name="Drive" /> 引数が複数の文字で構成される文字列の場合、<see langword="ChDrive" /> は先頭の文字だけを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`ChDrive`にはアンマネージコードのアクセス許可が必要です。これは、部分信頼状況での実行に影響する可能性があります。 詳細については<xref:System.Security.Permissions.SecurityPermission> 、「」および「[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
   
  
## Examples  
 この例では`ChDrive` 、関数を使用して現在のドライブを変更します。 この関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CurDir() cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では`CurDir` 、関数を使用して現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CurDir(char Drive) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">任意。 既存のドライブを指定する <see langword="Char" /> 式です。 ドライブが指定されていない場合、または <paramref name="Drive" /> が長さ 0 の文字列 ("") である場合は、<see langword="CurDir" /> により現在のドライブのパスが返されます。</param>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では`CurDir` 、関数を使用して現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir() cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
        <returns>指定されたパターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Dir`は、複数のファイルを指定するため`*`に複数の文字 ()`?`と1文字の () ワイルドカードの使用をサポートしています。  
  
 `VbVolume`特定のファイル名ではなく、ドライブのボリュームラベルを返します。  
  
 `Dir`関数を初めて`PathName`呼び出すときは、を指定する必要があります。 次の項目を取得するには、パラメーターを指定せ`Dir`ずに関数の後続の呼び出しを行うことができます。  
  
> [!IMPORTANT]
>  `Dir`関数を正しく実行するには、 <xref:System.Security.Permissions.FileIOPermissionAccess.Read>の<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>フラグと<xref:System.Security.Permissions.FileIOPermission>フラグを実行中のコードに付与する必要があります。 詳細については<xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>「」、「」、および「[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
 引数`Attributes`の列挙値は次のとおりです。  
  
|[値]|定数|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定モード。 属性のないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|読み取り専用ファイルと、属性のないファイルを指定します。|  
|`Hidden`|`vbHidden`|隠しファイル、および属性のないファイルを指定します。|  
|`System`|`vbSystem`|システムファイル、および属性のないファイルを指定します。|  
|`Volume`|`vbVolume`|ボリュームラベルを指定します。他の属性が指定され`vbVolume`ている場合、は無視されます。|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダー、および属性のないファイルを指定します。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
  
> [!NOTE]
>  これらの列挙は Visual Basic 言語によって指定され、実際の値の代わりにコード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では`Dir` 、関数を使用して、特定のファイルとディレクトリが存在するかどうかを確認します。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">任意。 ファイル名、ディレクトリまたはフォルダー名、あるいはドライブ ボリューム ラベルを指定する文字列式です。 <paramref name="PathName" /> が見つからない場合は、長さ 0 の文字列 (<see langword="&quot;&quot;" />) が返されます。</param>
        <param name="Pathname">任意。 ファイル名、ディレクトリまたはフォルダー名、あるいはドライブ ボリューム ラベルを指定する文字列式です。 <paramref name="Pathname" /> が見つからない場合は、長さ 0 の文字列 (<see langword="&quot;&quot;" />) が返されます。</param>
        <param name="Attributes">任意。 値がファイル属性を指定する列挙式または数式。 省略した場合、<see langword="Dir" /> は、<paramref name="Pathname" /> に一致する、属性のないファイルを返します。</param>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
        <returns>指定されたパターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Dir`は、複数のファイルを指定するため`*`に複数の文字 ()`?`と1文字の () ワイルドカードの使用をサポートしています。  
 `VbVolume`特定のファイル名ではなく、ドライブのボリュームラベルを返します。  
 `Dir`関数を初めて`PathName`呼び出すときは、を指定する必要があります。 次の項目を取得するには、パラメーターを使用せ`Dir`ずに関数の後続の呼び出しを行うことができます。  
> [!IMPORTANT]
>  `Dir`関数を正しく実行するには、 <xref:System.Security.Permissions.FileIOPermissionAccess.Read>の<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>フラグと<xref:System.Security.Permissions.FileIOPermission>フラグを実行中のコードに付与する必要があります。 詳細については<xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>「」、「」、および「[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
 引数`Attributes`の列挙値は次のとおりです。  
|[値]|定数|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定モード。 属性を持たないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|属性を持たないファイルに加えて、読み取り専用ファイルを指定します。|  
|`Hidden`|`vbHidden`|属性を持たないファイルに加えて、隠しファイルを指定します。|  
|`System`|`vbSystem`|属性を持たないファイルに加えて、システムファイルを指定します。|  
|`Volume`|`vbVolume`|ボリュームラベルを指定します。他の属性が指定され`vbVolume`ている場合、は無視されます。|  
|`Directory`|`vbDirectory`|属性を持たないファイルに加えて、ディレクトリまたはフォルダーを指定します。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
> [!NOTE]
>  これらの列挙は Visual Basic 言語によって指定され、実際の値の代わりにコード内の任意の場所で使用できます。  
## Examples  
 この例では`Dir` 、関数を使用して、特定のファイルとディレクトリが存在するかどうかを確認します。  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EOF(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <summary><see langword="True" /> モードまたはシーケンシャル <see langword="Random" /> モードで開いたファイルの現在位置がファイルの末尾に達している場合、ブール値 <see langword="Input" /> を返します。</summary>
        <returns><see langword="True" /> モードまたはシーケンシャル <see langword="Random" /> モードで開いたファイルの現在位置がファイルの末尾に達している場合、ブール値 <see langword="Input" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイル`EOF`の末尾を越えて入力を取得しようとすることによって生成されるエラーを回避するには、を使用します。  
  
 関数`EOF`は、 `False`ファイルの末尾に到達するまでを返します。 `Random`または`EOF` `False` `FileGet`にアクセスするためにファイルを開くと、最後に実行された関数がレコード全体を読み取ることができなくなるまで、が返されます。 `Binary`  
  
 ファイルがアクセス用`Binary`に開かれた状態で、が返さ`True`れるまで`Input` `EOF` 、関数を使用してファイルを読み取ろうとすると、エラーが生成されます。 `Loc` `EOF` `LOF`でバイナリ`Input`ファイルを`Get`読み取るときには、関数と関数を使用します。`EOF`関数を使用する場合は、を使用します。 用に`Output`開かれたファイルで`True`は、 `EOF`常にを返します。  
  
   
  
## Examples  
 この例では`EOF` 、関数を使用してファイルの末尾を検出します。 この例では`Testfile` 、が複数行のテキストを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 <see langword="Integer" />。 任意の有効なファイル数。</param>
        <summary><see langword="FileOpen" /> 関数を使用して開いたファイルのファイル モードを表す列挙体を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="FileAttr" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>次の列挙型値は、ファイルのアクセス モードを示します。 
 <list type="table"><item><term> [値] 
 </term><description> モード 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、 `FileOpen`関数を使用して開かれたファイルのファイルモードを表す列挙体を返します。  
  
   
  
## Examples  
 この例では`FileAttr` 、関数を使用して、開いているファイルのファイルモードを返します。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileClose(int32[] FileNumbers) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">任意。 閉じる対象となる、0 以上のチャネルで構成されるパラメーター配列。</param>
        <summary><see langword="FileOpen" /> 関数で開いたファイルへの入出力を終了して、ファイルを閉じます。 <see langword="My" /> を使用すると、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`FileClose`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「[方法 :StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)を使用してファイルからテキスト[を読み取る、方法:StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)を使用してファイルにテキストを[書き込む方法とチュートリアル:Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)内のファイルとディレクトリを操作します。  
  
 を省略`FileNumbers`した場合は、 `FileOpen`関数によって開かれたすべてのアクティブなファイルが閉じられます。  
  
 または`Output` `Append`用に開かれたファイルを閉じると、出力の最終的なバッファーがそのファイルのオペレーティングシステムバッファーに書き込まれます。 閉じたファイルに関連付けられているすべてのバッファー領域が解放されます。  
  
 `FileClose`関数を実行すると、ファイルとファイル番号の関連付けが終了します。  
  
   
  
## Examples  
 この例では`FileClose` 、関数を使用して、 `Input`で開かれたファイルを閉じます。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> は存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End ステートメント</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop ステートメント (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileCopy(string Source, string Destination) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必須です。 コピーするファイルの名前を指定する文字列式です。 <paramref name="Source" /> には、コピー先ファイルのディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Destination">必須です。 コピー先のファイルの名前を指定する文字列式です。 <paramref name="Destination" /> には、コピー先ファイルのディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルをコピーします。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="FileCopy" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在開いているファイルで`FileCopy`関数を使用しようとすると、エラーが発生します。  
  
 `FileCopy`ローカルドライブで動作するには、完全な信頼が必要です。  
  
   
  
## Examples  
 この例では`FileCopy` 、関数を使用して、あるファイルを別のファイルにコピーします。 この例では、がデータを`SrcFile`含むファイルであることを想定しています。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> または <paramref name="Destination" /> が無効であるか、指定されていません。</exception>
        <exception cref="T:System.IO.IOException">ファイルは既に開いています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">方法 : Visual Basic でファイルのコピーを別のディレクトリに作成する</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">方法 : Visual Basic でファイルのコピーを同じディレクトリに作成する</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">方法 : Visual Basic でディレクトリを別のディレクトリにコピーする</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime FileDateTime(string PathName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 ファイル名を指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルへの書き込み日時を示す <see langword="Date" /> 値を返します。 <see langword="My" /> 機能を使用すると、<see langword="FileDateTime" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>ファイルの作成日時または最終変更日時を示す <see langword="Date" /> 値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では`FileDateTime` 、関数を使用して、ファイルが作成された日時または最後に変更された日時を確認します。 表示される日付と時刻の形式は、システムのロケール設定に基づいています。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" /> が無効です。またはワイルドカードを含んでいます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は。 次に、に`FileGet`渡される配列のサイズと境界によって、読み取る内容が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、`FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="ArrayIsDynamic">任意。 文字列を書き込む場合のみ適用します。 配列を動的として扱うかどうか、およびサイズと境界を表す配列記述子が必要かどうかを指定します。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGet`読み取られるデータは、通常、を使用`FilePut`してファイルに書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、最後`FileGet`のまた`FilePut`は関数 (または最後`Seek`の関数によって参照される) に続く次のレコードまたはバイトが読み取られます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGet`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量はいかなる確実性でも判断できないため、通常は、レコードの長さを読み取り中のデータの長さと一致させることをお勧めします。  
  
-   既定では、に読み込む変数が文字列`FileGet`である場合、は文字列の長さを含む2バイトの記述子を読み取り、変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長文字列がサポートされています。ファイルに書き込む場合、長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合は、配列のサイズと次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を読み取るときは、配列の記述方法と一致する必要があります。 記述子を使用して記述されている場合は、記述子を読み取る必要があります。 記述子が使用されていない場合は、に`FileGet`渡される配列のサイズと境界によって、読み取る対象が決まります。  
  
     記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218バイトは次のように分散されます。  
  
    -   記述子の18バイト:(2 + 8 * 2)  
  
    -   データの200バイト:(5 * 10 * 4)。  
  
-   読み取り先の変数が、可変長文字列またはオブジェクトではなく、他の型の変数である場合、 `FileGet`は変数データだけを読み取ります。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、読み取るデータの長さ以上である必要があります。  
  
-   `FileGet`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePut`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、個々の要素を読み取るために必要なすべてのバイトの合計以上である必要があります。 これには、すべての配列とその記述子が含まれます。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGet`すべての変数をディスクから連続して読み取ります。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGet`データだけを読み取ります。 記述子が読み取られません。  
  
-   `FileGet`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
    > [!IMPORTANT]
    >  `FileGet`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。  <see langword="My" /> 機能を使用すると、<see langword="FileGetObject" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Integer` `Object` `FileGet` 、 `FileGetObject` 、など、別の型ではなく型が返される場合、コンパイル時のあいまいさを避けるために、関数はの代わりに使用されます。`Long` `Short`  
  
 `Variant`型を書き出す場合は、 `FileGetObject`が必要です。 2番目のパラメーターにオブジェクトを使用している場合は、常にと`FilePutObject` `FileGetObject`を使用することをお勧めします。  
  
 `FileGetObject`は、および`Binary`モード`Random`でのみ有効です。  
  
 で`FileGetObject`読み取られるデータは、通常`FilePutObject`、を使用して書き込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した`FileGetObject`場合、は最後`FileGetObject`の関数または`FilePutObject`関数の後 (または最後`Seek`の関数が指す) のレコードまたはバイトを読み取ります。  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   読み取られるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも少ない場合、 `FileGetObject`は、レコード長の境界の後続のレコードを読み取ります。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は正確には特定できないため、レコードの長さは、読み取るデータの長さと一致させることをお勧めします。  
  
-   に読み取る変数が文字列の場合、既定`FileGetObject`では、文字列の長さを含む2バイトの記述子を読み取り、次に変数に入力されたデータを読み取ります。 したがって、 `RecordLength` `FileOpen`関数の句で指定されるレコードの長さは、文字列の実際の長さよりも2バイト以上である必要があります。 Visual Basic 6.0 以前のバージョンでは固定長の文字列がサポートされており、ファイルに読み取るときに長さ記述子は書き込まれません。 記述子を含まない文字列を読み取る場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   に読み取る変数が配列の場合、 `RecordLength` `FileOpen`関数のパラメーターで指定したレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。2 + 8 * NumberOfDimensions。  
  
     たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要になります。  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218バイトは次のように分散されます。記述子の場合は18バイト (2 + 8 * 2)、データの場合は100バイト (5 * 10 * 4)。  
  
-   `FileGetObject`は、それぞれが個別に読み取られているかのように、構造体の要素を読み取ります。ただし、要素間にパディングはありません。 ディスク上では、(を使用して記述された) `FilePutObject`ユーザー定義型の動的配列に、長さが 2 + 次元数の8倍の値を持つ記述子がプレフィックスとして付けられます。2 + 8 * NumberOfDimensions。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列とその記述子を含む、個々の要素の読み取りに必要なすべてのバイトの合計以上である必要があります。 クラス<xref:Microsoft.VisualBasic.VBFixedStringAttribute>は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合、 `Random`すべてのルールが適用されます。ただし、次のような例外があります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FileGetObject`ディスクからすべての変数を連続して読み取ります。つまり、レコード間に埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FileGetObject`データだけを読み取ります。 記述子が読み取られません。  
  
 `FileGetObject`2バイト長記述子を予期せずに、構造体の要素ではない可変長文字列を読み取ります。 読み取るバイト数は、既に文字列に含まれている文字数と同じです。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
   
  
## Examples  
 次の例では、レコードをテストファイルに読み込んで取得します。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 FileLen(string PathName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 ファイルを指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルの長さをバイト数で指定する値を返します。 <see langword="My" /> 機能を使用すると、<see langword="FileLen" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>バイト単位のファイルの長さです。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileLen`関数が呼び出されたときに、指定したファイルが開いている場合、返される値は、ファイルが開かれたときのファイルのサイズを表します。  
  
> [!NOTE]
>  開いているファイルの現在の長さを取得するに`LOF`は、関数を使用します。  
  
   
  
## Examples  
 この例では`FileLen` 、関数を使用して、ファイルの長さをバイト単位で返します。 この例では、がデータを`TestFile`含むファイルであることを想定しています。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。 <see langword="FreeFile" /> 関数を使用して、次に使用できるファイル番号を取得します。</param>
        <param name="FileName">必須です。 ファイル名を指定する文字列式。ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Mode">必須です。 ファイル モード (<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" />、または <see langword="Random" />) を指定する列挙体。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenMode" />」を参照してください。</param>
        <param name="Access">任意。 開いているファイルで許可されている操作 (<see langword="Read" />、<see langword="Write" />、または <see langword="ReadWrite" />) を示す列挙体。 既定値は <see langword="ReadWrite" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenAccess" />」を参照してください。</param>
        <param name="Share">任意。 他のプロセスによって開かれたファイルで許可されていない操作 (<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" />、および <see langword="Lock Read Write" />) を指定する列挙体。 既定値は <see langword="Lock Read Write" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenShare" />」を参照してください。</param>
        <param name="RecordLength">任意。 32,767 以下の値 (バイト単位)。 ランダム アクセス ファイルの場合は、レコード長を表します。 シーケンシャル ファイルの場合は、バッファー内の文字数を表します。</param>
        <summary>ファイルを開いて入出力を行います。 <see langword="My" /> 機能を使用すると、<see langword="FileOpen" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`FileOpen`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 I/o 操作を実行する前に、ファイルを開く必要があります。 `FileOpen`i/o 用のバッファーをファイルに割り当て、バッファーで使用するアクセスモードを決定します。  
  
> [!IMPORTANT]
>  ファイルに書き込むときに、書き込み先のファイルが存在しない場合、アプリケーションでファイルを作成する必要がある場合があります。 これを行うには、ファイルを作成するディレクトリに対するアクセス許可が必要です。 ただし、で指定したファイル`FileName`が存在する場合、アプリケーション`Write`はファイル自体に対してのみアクセス許可を必要とします。 可能な限り、セキュリティを強化するために、展開中にファイル`Write`を作成し、ディレクトリ全体ではなく、そのファイルに対してのみアクセス許可を付与します。 セキュリティを強化するために、ルートディレクトリや Program Files ディレクトリではなく、ユーザーディレクトリにデータを書き込みます。  
  
 開くチャネルは、 `FreeFile()`関数を使用して見つけることができます。  
  
> [!IMPORTANT]
>  関数`FileOpen`は、 `Read`部分信頼状況`FileIOPermissionAccess`での実行に影響する可能性がある列挙からのアクセスを必要とします。 詳細については<xref:System.Security.Permissions.FileIOPermissionAccess> 、「列挙型」を参照してください。  
  
   
  
## Examples  
 この例では、 `FileOpen`ファイルへの入力と出力を有効にする関数のさまざまな使用方法を示します。  
  
 次のコードでは、 `TestFile`ファイル`Input`をモードで開きます。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 この例では、書き込み`Binary`操作のみを行うモードでファイルを開きます。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 次の例では、ファイル`Random`をモードで開きます。 このファイルには、構造体`Person`のレコードが含まれています。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 このコード例では、ファイル`Output`をモードで開きます。すべてのプロセスでファイルの読み取りまたは書き込みを行うことができます。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 このコード例では、読み取り`Binary`用にモードでファイルを開きます。他のプロセスはファイルを読み取ることができません。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">レコード長が、-1 ではない負の値です。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" /> が既に開かれています。または <paramref name="FileName" /> が無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、`RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, RecordNumber As Object)" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FilePut(System::Object ^ FileNumber, System::Object ^ Value, System::Object ^ RecordNumber);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="ArrayIsDynamic">任意。 文字列を書き込む場合のみ適用します。 配列を動的として扱うかどうか、および長さを表す文字列の配列記述子を書き込むかどうかを指定します。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 を省略`RecordNumber`した場合、 `FilePut`最後`FileGet`の`Seek`関数または関数の後にある次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePut`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、で`FileGet`同じことを行う必要があり、文字列が必要な長さに初期化されていることを確認する必要があります。 `FilePut`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePut`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は確実性によって判断できないため、通常は、記録されるデータの長さとレコードの長さを一致させることをお勧めします。 書き込まれるデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が文字列の場合、 `FilePut`は文字列の長さを含む2バイトの記述子を書き込み、変数に入力されたデータを書き込みます。 したがって、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、文字列の実際の長さより2バイト以上である必要があります。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePut`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePut`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePut` 、オブジェクトのを`VarType(8)`識別する2バイト記述子、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込まれている変数が配列の場合は、配列のサイズと次元の記述子を書き込むかどうかを選択できます。 Visual Basic 6.0 以前のバージョンでは、固定サイズの配列ではなく、動的配列のファイル記述子を書き込みます。 Visual Basic 2005 では、既定で記述子を書き込まないようになっています。 記述子を書き込むには、 `ArrayIsDynamic`パラメーターをに`True`設定します。 配列を書き込むときは、配列が読み取られる方法と一致する必要があります。記述子を使用して読み取る場合は、記述子を書き込む必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 たとえば、次の配列宣言では、配列がディスクに書き込まれるときに218バイトが必要です。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (可変長文字列またはオブジェクトではない) である`FilePut`場合、は変数データのみを書き込みます。 `FileOpen`関数の`RecordLength`句で指定されたレコードの長さは、書き込まれるデータの長さ以上である必要があります。  
  
-   `FilePut`は、それぞれが個別に記述されているかのように構造体の要素を書き込みます。ただし、要素間にパディングはありません。 属性`VBFixedString`は、ディスクに書き込まれるときに文字列のサイズを示すために、構造体の文字列フィールドに適用できます。  
  
    > [!NOTE]
    >  `VBFixedString`属性で指定されたよりも多くのバイトを持つ文字列フィールドは、ディスクに書き込まれるときに切り捨てられます。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルの場合は`Random` 、ほとんどのモードルールが適用されますが、例外もあります。 モードで`Binary`開かれたファイルの次の規則は、モード`Random`の規則とは異なります。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePut`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
-   構造体の配列以外の配列の場合、は`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut`2バイト長記述子を含まない構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数は、文字列の文字数と同じです。 たとえば、次のステートメントは11バイトをファイル番号1に書き込みます。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   `FilePut`関数を使用してファイルに書き込むに`Write`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`FilePut` 、関数を使用してファイルにデータを書き込みます。 構造体`Person`の5つのレコードがファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。  <see langword="My" /> 機能を使用すると、<see langword="FilePutObject" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Integer` `Object` `FilePut` 、 `FilePutObject` 、など、別の型ではなく型が渡された場合、コンパイル時のあいまいさを避けるために、関数はの代わりに使用されます。`Long` `Short`  
  
 `FilePutObject`オブジェクトを記述する記述子を書き込み、読み取ります。 `Variant`型を書き出す場合は、 `FilePutObject`が必要です。 不明な場合は、2番目のパラメーターにオブジェクトを使用している場合は、常`FilePutObject`に`FileGetObject`とを使用することをお勧めします。  
  
 `FilePutObject`は、および`Binary`モード`Random`でのみ有効です。  
  
 `FilePutObject` を使用して書き込まれたデータは通常、`FileGetObject` を使用してファイルから読み込まれます。  
  
 ファイル内の最初のレコードまたはバイトの位置は1、2番目のレコード、またはバイトの位置は2になります。 `RecordNumber`を省略した`FilePutObject`場合、最後`FileGetObject`のまた`FilePutObject`は関数 (または最後`Seek`の関数が指すレコードまたはバイト) の後に、次のレコードまたはバイトが書き込まれます。  
  
 引数`StringIsFixedLength`は、関数が文字列を変数または固定長として解釈するかどうかを制御します。 `FilePutObject`引数が`True`の場合、は長さ記述子を書き込みません。 をと共`StringIsFixedLength`  =  `True`に使用する場合は、と`FileGetObject`同じ操作を行う必要があります。また、文字列が必要な長さに初期化されていることを確認する必要もあります。 `FilePutObject`  
  
## <a name="random-mode"></a>ランダムモード  
 モードで`Random`開かれたファイルの場合、次の規則が適用されます。  
  
-   書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さよりも小さい`FilePutObject`場合、は後続のレコードをレコード長の境界に書き込みます。 1つのレコードの末尾と次のレコードの先頭との間のスペースは、ファイルバッファーの既存の内容に埋め込まれます。 埋め込みデータの量は正確には特定できないため、通常は、レコードの長さを、書き込まれるデータの長さと一致させることをお勧めします。 書き込まれているデータの長さが、 `RecordLength` `FileOpen`関数の句で指定された長さを超える場合は、例外がスローされます。  
  
-   書き込み中の変数が数値型を含むオブジェクトの場合、 `FilePutObject`はオブジェクトのを`VarType`識別する2バイトを書き込み、変数を書き込みます。 たとえば、整数を含むオブジェクトを書き込む場合、 `FilePutObject`は6バイトを書き込みます。 `VarType(3)`オブジェクトを識別する2バイト (`Integer`) とデータを格納する4バイトです。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、変数を格納するために必要な実際のバイト数よりも2バイト以上である必要があります。  
  
-   書き込み中の変数が文字列を含むオブジェクトの場合、は`FilePutObject` 、オブジェクトのを`VarType(8)`識別する2バイト記述子と、文字列の長さを示す2バイト記述子を書き込み、文字列データを書き込みます。 `FileOpen`関数の`RecordLength`パラメーターによって指定されたレコードの長さは、文字列の実際の長さよりも少なくとも4バイト以上である必要があります。 記述子を含まない文字列を指定する場合は、 `True` `StringIsFixedLength`パラメーターにを渡す必要があります。また、読み取る文字列は正しい長さである必要があります。  
  
-   書き込む変数が配列の場合、 `RecordLength` `FileOpen`関数の句で指定されたレコードの長さは、配列データと配列記述子の書き込みに必要なすべてのバイトの合計以上である必要があります。 記述子は、配列のランク、サイズ、および各ランクの下限を指定します。 長さは 2 + 次元数の8倍になります。(2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>バイナリモード  
 モードで`Binary`開かれたファイルについ`Random`ては、次の場合を除き、すべてのモード規則が適用されます。  
  
-   関数内の句は無効です。 `RecordLength` `FileOpen` `FilePutObject`すべての変数を連続してディスクに書き込みます。つまり、レコード間の埋め込みは行われません。  
  
   
  
## Examples  
 この例では`FilePutObject` 、関数を使用して、ファイルに文字列を書き込みます。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="RecordWidth">必須です。 改行される前に 1 行に表示できる文字数を表す 0 から 255 の範囲の数式。 <paramref name="RecordWidth" /> が 0 の場合は、行の長さに制限がないことを示します。 <paramref name="RecordWidth" /> の既定値は 0 です。</param>
        <summary><see langword="FileOpen" /> 関数を使用して開いたファイルに出力行の桁数を割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では`FileWidth` 、関数を使用して、ファイルの出力線の幅を設定します。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FreeFile() cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="Integer" /> 関数で使用できる次のファイル番号を表す <see langword="FileOpen" /> 値を返します。</summary>
        <returns><see langword="FileOpen" /> 関数で使用できる次のファイル番号を表す整数値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 まだ`FreeFile`使用されていないファイル番号を指定するには、を使用します。  
  
   
  
## Examples  
 この例では`FreeFile` 、関数を使用して、次に使用可能なファイル番号を返します。 ループ内の出力用に5つのファイルが開かれ、いくつかのサンプルデータがそれぞれに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">使用中のファイルが 255 個を超えています。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 ファイル、ディレクトリ、またはフォルダーの名前を指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイル、ディレクトリ、またはフォルダーの属性を表す <see langword="FileAttribute" /> 型の値を返します。 <see langword="My" /> 機能を使用すると、<see langword="FileAttribute" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>列挙値のビットごとの組み合わせ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの属性が設定され`And` `GetAttr`ているかを判断するには、演算子を使用して、関数によって返される値と、必要な個々のファイル属性の値のビットごとの比較を実行します。 結果が0でない場合は、その属性が名前付きファイルに対して設定されます。 たとえば、次`And`の式の戻り値は、 `Archive`属性が設定されていない場合は0になります。  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 属性が設定されて`Archive`いる場合は、0以外の値が返されます。  
  
   
  
## Examples  
 この例では`GetAttr` 、関数を使用して、ファイル、ディレクトリ、またはフォルダーの属性を決定します。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" /> が無効です。またはワイルドカードを含んでいます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And 演算子 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, bool&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用してデータの一部の行が書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * byte -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用してデータの一部の行が書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, char&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * DateTime -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * decimal -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, float64&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * double -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int16&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int16 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int32&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, int64&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, object&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, float32&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * single -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Input(int32 FileNumber, string&amp; Value) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Value">必須です。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Input`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`Input`読み取られるデータは、通常、を使用`Write`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic 2005 ソースファイルにすることはできません。  
  
 読み取り時に、標準の文字列または数値データが変更されずに変数に割り当てられます。 次の表は、他の入力データがどのように処理されるかを示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行の区切り|Empty|  
|#NULL#|`DBNull`|  
|#TRUE # または #FALSE#|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|式で表される日付/時刻|  
|#ERROR`errornumber`#|`errornumber`(変数はエラーとしてタグ付けされたオブジェクトです)|  
  
 データ項目の入力中にファイルの末尾に近づいた場合は、入力が停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語版では、3, 14159 を入力した場合、3だけが返されます。これは、コンマが小数点としてではなく変数区切り記号として扱われるためです。  
  
> [!IMPORTANT]
>  `Input`関数を使用してファイルから読み取るに`Read`は、 `FileIOPermissionAccess`列挙からのアクセスが必要です。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Input` 、関数を使用して、ファイルから2つの変数にデータを読み取ります。 この例では`TestFile` 、 `Write`関数を使用して複数行のデータが書き込まれたファイルであることを前提としています。各行には、引用符で区切った文字列と、コンマで区切られた数値 ("Hello"、234など) が含まれています。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string InputString(int32 FileNumber, int32 CharCount) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="CharCount">必須です。 読み込む文字数を指定する有効な任意の数式。</param>
        <summary><see langword="String" /> モードまたは <see langword="Input" /> モードで開いたファイルから読み取る文字を表す文字列型 (<see langword="Binary" />) の値を返します。 <see langword="My" /> 機能を使用すると、<see langword="InputString" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns><see langword="Input" /> モードまたは <see langword="Binary" /> モードで開いたファイルからの文字が格納された文字列です。 <see langword="My" /> 機能を使用すると、<see langword="InputString" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`InputString`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 `InputString`関数で読み取られるデータは、通常、または`FilePut`を使用`Print`してファイルに書き込まれます。 この関数は、または`Input` `Binary`モードで開かれたファイルでのみ使用してください。  
  
 関数とは異なり、 `InputString`関数は読み取るすべての文字を返します。 `Input` これには、コンマ、キャリッジリターン、ラインフィード、引用符、および先頭のスペースが含まれます。  
  
 ファイルがアクセス用`Binary`に開かれた状態で、が返さ`True`れるまで`EOF` 、 `InputString`関数を使用してファイルを読み取ろうとすると、エラーが生成されます。 `Loc` `EOF` `FileGet` `EOF`を使用して`LOF` バイナリファイルを読み取る場合や、関数を使用する場合はを使用するのではなく、関数と関数を`InputString`使用します。  
  
> [!NOTE]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいて、ファイルの内容に関するセキュリティ上の決定を行うことは避けてください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
   
  
## Examples  
 この例では`InputString` 、関数を使用して、ファイルから一度に1つの文字を`Output`読み取り、それをウィンドウに出力します。 この例では`MyFile` 、が、いくつかのサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> は存在しません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" /> は &lt; 0 または &gt; 214 です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Kill(string PathName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 削除する 1 つ以上のファイル名を指定する文字列式です。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルをディスクから削除します。 <see langword="My" /> 機能を使用すると、<see langword="Kill" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill`複数のファイルを指定するために`*`、複数文字 () と`?`1 文字の () ワイルドカードの使用をサポートしています。  
  
 **セキュリティ**に関する注意を実行するために、 `Kill`関数は、 `PathDiscovery`実行中<xref:System.Security.Permissions.FileIOPermission>のコードにとのフラグを与える必要が`Read`あります。 詳細については<xref:System.Security.SecurityException>、「[コードアクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)」を参照してください。  
  
   
  
## Examples  
 この例では`Kill` 、関数を使用して、ディスクからファイルを削除します。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">対象のファイルが開かれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LineInput(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <summary>開かれたシーケンシャル ファイルから 1 行を読み込み、<see langword="String" /> 変数に割り当てます。</summary>
        <returns>開かれたシーケンシャル ファイルから 1 行を読み込み、<see langword="String" /> 変数に割り当てます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`LineInput`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 で`LineInput`読み取られるデータは、通常、を使用`Print`してファイルに書き込まれます。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合は、ファイル名拡張子に基づいてファイルの内容を決定しないでください。 たとえば、Form1.vb という名前のファイルを Visual Basic ソースファイルにすることはできません。  
  
 関数`LineInput`は、キャリッジリターン (`Chr(13)`) またはキャリッジリターン/ラインフィード (`Chr(13) + Chr(10)`) シーケンスが検出されるまで、一度に1文字ずつファイルを読み取ります。 キャリッジリターン/ラインフィードシーケンスは、文字列に追加されるのではなく、スキップされます。  
  
> [!IMPORTANT]
>  `LineInput`関数を使用してファイルから読み取るに`Read`は、 <xref:System.Security.Permissions.FileIOPermissionAccess>列挙からのアクセスが必要です。  
  
   
  
## Examples  
 この例では`LineInput` 、関数を使用して、シーケンシャルファイルから行を読み取り、変数に割り当てます。 この例では`TestFile` 、が、いくつかのサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">ファイルの終端に達しました。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> は存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Loc(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 有効な任意の <see langword="Integer" /> 型のファイル番号。</param>
        <summary>開かれたファイル内の現在の読み込みと書き込みの位置を指定する値を返します。</summary>
        <returns>開かれたファイル内の現在の読み取り/書き込み位置です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`関数は0から始まります。これを使用してファイル内の最初のバイトを取得すると、0が返されます。  
  
 関数`Loc`は、旧バージョンとの互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 次に、各ファイルアクセスモードの戻り値について説明します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|ファイルから読み取られた、またはファイルに書き込まれた最後のレコードの番号。|  
|`Sequential`|ファイル内の現在のバイト位置を128で割った値。 ただし、シーケンシャルファイルに`Loc`対してによって返される情報は、使用も必須でもありません。|  
|`Binary`|読み取りまたは書き込みが最後に読み取られたバイトの位置。|  
  
   
  
## Examples  
 この例では`Loc` 、関数を使用して、開いているファイル内の現在の読み取り/書き込み位置を返します。 この例では`MyFile` 、が、いくつかのサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 および`Lock`関数`Unlock`は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock`関数`Unlock`と関数は、常にペアで使用されます。 `Lock` および`Unlock`の引数は、同一である必要があります。  
  
 、 `Record` `FromRecord` 、`ToRecord`またはが指定されていない場合、ファイル全体のロックがになります。 単独`Record`のを指定した場合、1つのレコードはロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力`Lock`または出力用に開かれている場合は、とで`Unlock` `FromRecord` `ToRecord`指定された範囲に関係なく、ファイル全体に影響します。  
  
   
  
## Examples  
 この例では、関数`Lock`と`Unlock`関数の使用方法を示します。 この例では`People.txt` 、が構造体`Person`のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Record">任意。 ロックまたはアンロックされる唯一のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 および`Lock`関数`Unlock`は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock`関数`Unlock`と関数は、常にペアで使用されます。 `Lock` および`Unlock`の引数は、同一である必要があります。  
  
 、 `Record` `FromRecord` 、`ToRecord`またはが指定されていない場合、ファイル全体のロックがになります。 単独`Record`のを指定した場合、1つのレコードはロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力`Lock`または出力用に開かれている場合は、とで`Unlock` `FromRecord` `ToRecord`指定された範囲に関係なく、ファイル全体に影響します。  
  
   
  
## Examples  
 この例では、関数`Lock`と`Unlock`関数の使用方法を示します。 この例では`People.txt` 、が構造体`Person`のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="FromRecord">任意。 ロックまたはアンロックされる最初のレコードまたはバイトの番号。</param>
        <param name="ToRecord">任意。 ロックまたはアンロックされる最後のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 および`Lock`関数`Unlock`は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock`関数`Unlock`と関数は、常にペアで使用されます。 `Lock` および`Unlock`の引数は、同一である必要があります。  
  
 、 `Record` `FromRecord` 、`ToRecord`またはが指定されていない場合、ファイル全体のロックがになります。 単独`Record`のを指定した場合、1つのレコードはロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力`Lock`または出力用に開かれている場合は、とで`Unlock` `FromRecord` `ToRecord`指定された範囲に関係なく、ファイル全体に影響します。  
  
   
  
## Examples  
 この例では、関数`Lock`と`Unlock`関数の使用方法を示します。 この例では`People.txt` 、が構造体`Person`のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LOF(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 有効なファイル番号が格納された整数です。</param>
        <summary><see langword="FileOpen" /> 関数を使用して開かれたファイルのサイズをバイト単位で返します。 <see langword="My" /> 機能を使用すると、<see langword="LOF" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns><see langword="FileOpen" /> 関数を使用して開かれたファイルのサイズ (バイト単位)。 <see langword="My" /> 機能を使用すると、<see langword="LOF" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開かれ`FileLen`ていないファイルの長さを取得するには、関数を使用します。  
  
   
  
## Examples  
 この例では`LOF` 、関数を使用して、開いているファイルのサイズを決定します。 この例では`TestFile` 、がサンプルデータを含むテキストファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MkDir(string Path) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須です。 作成されるディレクトリを識別する文字列式です。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="MkDir" /> は現在のドライブに新しいディレクトリを作成します。</param>
        <summary>新しいディレクトリを作成します。 <see langword="My" /> 機能を使用すると、<see langword="MkDir" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、新しいディレクトリを作成します。  
  
   
  
## Examples  
 この例では`MkDir` 、関数を使用してディレクトリを作成します。 ドライブが指定されていない場合は、現在のドライブに新しいディレクトリが作成されます。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> が指定されていません。または空です。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
        <exception cref="T:System.IO.IOException">ディレクトリが既に存在しています。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">方法 : Visual Basic でディレクトリを作成する</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Print(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Output">任意。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
<paramref name="Output" /> 引数の設定は以下の通りです。 
 <see langword="T:System.IO.IOException" />:ファイル モードが無効です。  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> が存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Print` と`PrintLine`関数は、下位互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 `Print`行の末尾に改行が含まれていません。ただし、 `PrintLine`にはラインフィードが含まれます。  
  
 で書き込まれ`Print`たデータは、通常、または`LineInput` `Input`を使用してファイルから読み取ります。  
  
 でを省略`Output` `PrintLine`した場合は、空白行がファイルに出力さ`Print`れます。の場合は、何も出力されません。 コンマで区切られた複数の式はタブ境界に沿って配置され`TAB`ますが、コンマが混在していると結果が矛盾する可能性があります。  
  
 データ`Boolean`の場合`True`は、 `False`またはが出力されます。 ロケールに`False`関係なく、キーワードとキーワードは翻訳されません。`True`  
  
 日付データは、システムによって認識される標準の短い日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
 データが空の場合`Output` 、ファイルには何も書き込まれません。 ただし、リスト`Output`データ`DBNull`がの場合、はファイルに書き込まれます。`Null`  
  
 データ`Error`の場合、出力はと`Error errorcode`して表示されます。 `Error`キーワードは、ロケールに関係なく翻訳されません。  
  
 を使用`Print`してファイルに書き込まれるすべてのデータは、国際的に認識されます。つまり、適切な小数点区切り記号を使用してデータが正しく書式設定されます。 ユーザーが複数のロケールで使用するためにデータを出力`Write`する場合は、を使用する必要があります。  
  
 関数`Print`または関数を使用して`PrintLine`ファイルに書き込むには`FileIOPermissionAccess` 、列挙からアクセスする必要があり`Write`ます。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Print` 、 `PrintLine`関数と関数を使用して、ファイルにデータを書き込みます。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrintLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Output">任意。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
<paramref name="Output" /> 引数の設定は以下の通りです。 
 <see langword="T:System.IO.IOException" />:ファイル モードが無効です。  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> が存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Print` と`PrintLine`関数は、下位互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 `Print`行の末尾に改行が含まれていません。ただし、`PrintLine`にはラインフィードが含まれます。  
  
 で書き込まれ`Print`たデータは、通常、または`LineInput` `Input`を使用してファイルから読み取ります。  
  
 でを省略`Output` `PrintLine`した場合は、空白行がファイルに出力さ`Print`れます。の場合は、何も出力されません。 コンマで区切られた複数の式はタブ境界に沿って配置され`TAB`ますが、コンマが混在していると結果が矛盾する可能性があります。  
  
 データ`Boolean`の場合`True`は、 `False`またはが出力されます。 ロケールに`False`関係なく、キーワードとキーワードは翻訳されません。`True`  
  
 日付データは、システムによって認識される標準の短い日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
 データが空の場合`Output` 、ファイルには何も書き込まれません。 ただし、リスト`Output`データ`DBNull`がの場合、はファイルに書き込まれます。`Null`  
  
 データ`Error`の場合、出力はと`Error errorcode`して表示されます。 `Error`キーワードは、ロケールに関係なく翻訳されません。  
  
 を使用`Print`してファイルに書き込まれるすべてのデータは、国際的に認識されます。つまり、適切な小数点区切り記号を使用してデータが正しく書式設定されます。 ユーザーが複数のロケールで使用するためにデータを出力`Write`する場合は、を使用する必要があります。  
  
 関数`Print`または関数を使用して`PrintLine`ファイルに書き込むには`FileIOPermissionAccess` 、列挙からアクセスする必要があり`Write`ます。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Print` 、 `PrintLine`関数と関数を使用して、ファイルにデータを書き込みます。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Rename(string OldPath, string NewPath) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必須です。 既存のファイルの名前と場所を指定する文字列式です。 <paramref name="OldPath" /> には、ファイルのディレクトリおよびドライブを含めることができます。</param>
        <param name="NewPath">必須です。 新しいファイルの名前と場所を指定する文字列式です。 <paramref name="NewPath" /> には、出力先のディレクトリおよびドライブを含めることができます。 <paramref name="NewPath" /> には、既に存在しているファイル名は指定できません。</param>
        <summary>ディスク ファイルまたはディレクトリの名前を変更します。 <see langword="My" /> 機能を使用すると、<see langword="Rename" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Rename`は、ファイルの名前を変更し、必要に応じて別のディレクトリに移動します。 関数`Rename`は、ドライブ間でファイルを移動できますが、と`OldPath`の両方`NewPath`が同じドライブに配置されている場合にのみ、既存のディレクトリの名前を変更できます。 `Rename`新しいファイルまたはディレクトリを作成できません。  
  
 開いているファイルで関数を使用すると、エラーが生成されます。`Rename` 名前を変更する前に、開いているファイルを閉じる必要があります。 `Rename`引数には、複数の文字 (*) と1文字 (?) のワイルドカードを含めることはできません。  
  
> [!IMPORTANT]
>  を使用`Rename`して保護されていない場所から保護された場所にファイルをコピーする場合、ファイルは制限の緩い権限を保持します。 セキュリティリスクが生じる可能性がないことを確認してください。  
  
   
  
## Examples  
 この例では`Rename` 、関数を使用してファイルの名前を変更します。 この例では、指定されたディレクトリが既に存在することを前提としています。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが無効です。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="OldPath" /> ファイルが存在しません。</exception>
        <exception cref="T:System.IO.IOException">異なるデバイスには名前を変更できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">方法 : Visual Basic でファイルの名前を変更する</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reset() cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="FileOpen" /> 関数を使用して開いたすべてのディスク ファイルを閉じます。 <see langword="My" /> 機能を使用すると、<see langword="Reset" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数は、 `FileOpen`関数によって開かれたすべてのアクティブなファイルを`FileClose()`閉じ、パラメーターを指定せずに関数と同じ機能を持ちます。 `Reset`  
  
   
  
## Examples  
 この例では`Reset` 、関数を使用して、開いているすべてのファイルを閉じ、すべてのファイルバッファーの内容をディスクに書き込みます。 `Object` 変数`FileNumber`を文字列と数値の両方として使用することに注意してください。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End ステートメント</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RmDir(string Path) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須です。 削除するディレクトリまたはフォルダーを識別する文字列式です。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="RmDir" /> は現在のドライブのディレクトリを削除します。</param>
        <summary>既存のディレクトリを削除します。 <see langword="My" /> 機能を使用すると、<see langword="RmDir" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルが格納されているディレクトリ`RmDir`でを使用しようとすると、エラーが発生します。 関数を`Kill`使用して、ディレクトリを削除する前にすべてのファイルを削除します。  
  
   
  
## Examples  
 この例では`RmDir` 、関数を使用して、既存のディレクトリを削除します。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> が指定されていません。または空です。</exception>
        <exception cref="T:System.IO.IOException">対象のディレクトリにファイルが存在しています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ディレクトリが存在していません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Seek(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <summary><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" />。または、<see langword="FileOpen" /> 関数を使用して開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`1 ~ 2147483647 の範囲の値を返します (2 ^ 31-1 と同じ)。  
  
 次に、各ファイルアクセスモードの戻り値について説明します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りまたは書き込みの番号|  
|`Binary`, `Input`, `Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイトの位置は1で、2番目のバイトは2の位置にあります。|  
  
   
  
## Examples  
 この例では`Seek` 、関数を使用して、現在のファイルの位置を返します。 この例で`TestFile`は、構造体`Record`のレコードを含むファイルがであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 モードで`Random`開かれたファイル`Seek`の場合、は次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 モード以外`Random`のモードで開かれたファイル`Seek`の場合、は次の操作が行われるバイト位置を返します。 は`TestFile` 、複数行のテキストを含むファイルであると仮定します。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では`Seek` 、関数を使用して、ファイル内の次の読み取りまたは書き込みの位置を設定します。  
  
 モード以外`Random`のモードで開かれたファイル`Seek`の場合、次の操作が行われるバイト位置がによって設定されます。 は`TestFile` 、複数行のテキストを含むファイルであると仮定します。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Seek(int32 FileNumber, int64 Position) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <param name="Position">必須です。 次の読み書き操作が発生する場所を示す 1 から 2,147,483,647 の範囲の数値。</param>
        <summary><see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`1 ~ 2147483647 の範囲の値を返します (2 ^ 31-1 と同じ)。  
  
 次に、各ファイルアクセスモードの戻り値について説明します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りまたは書き込みの番号|  
|`Binary`, `Input`, `Output`, `Append`|次の操作が発生するバイト位置。 ファイルの最初のバイトの位置は1で、2番目のバイトは2の位置にあります。|  
  
   
  
## Examples  
 この例では`Seek` 、関数を使用して、現在のファイルの位置を返します。 この例で`TestFile`は、構造体`Record`のレコードを含むファイルがであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 モードで`Random`開かれたファイル`Seek`の場合、は次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 モード以外`Random`のモードで開かれたファイル`Seek`の場合、は次の操作が行われるバイト位置を返します。 は`TestFile` 、複数行のテキストを含むファイルであると仮定します。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では`Seek` 、関数を使用して、ファイル内の次の読み取りまたは書き込みの位置を設定します。  
  
 モード以外`Random`のモードで開かれたファイル`Seek`の場合、次の操作が行われるバイト位置がによって設定されます。 は`TestFile` 、複数行のテキストを含むファイルであると仮定します。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必須です。 ファイル名を指定する文字列式です。 <paramref name="PathName" /> にはディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Attributes">必須です。 定数式または数式の合計がファイル属性を指定する場合の定数式または数式。</param>
        <summary>ファイルの属性情報を設定します。 <see langword="My" /> 機能を使用すると、<see langword="SetAttr" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開いているファイルの属性を設定しようとすると、実行時エラーが発生します。  
  
 引数`Attributes`の列挙値は次のとおりです。  
  
|[値]|定数|説明|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (既定値)。|  
|`ReadOnly`|`vbReadOnly`|読み取り専用。|  
|`Hidden`|`vbHidden`|非表示。|  
|`System`|`vbSystem`|システム ファイル。|  
|`Volume`|`vbVolume`|ボリューム ラベル|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダー。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
  
> [!NOTE]
>  これらの列挙体は Visual Basic 言語によって指定されています。 名前は、実際の値ではなく、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では`SetAttr` 、関数を使用して、ファイルの属性を設定します。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Attribute" /> の型が無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必須です。 リストの次の式を表示または出力する前に挿入する空白の数。</param>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が`Count`出力線の幅より小さい場合は、次の印刷位置が、印刷されるスペースの数の直後に続きます。 が`Count`出力線の幅を超える場合は`SPC` 、次の式を使用して次の印刷位置を計算します。  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 たとえば、現在の印刷位置が24で、出力線の幅が80で、を指定`SPC(90)`した場合、次の印刷は位置 34 (現在の印刷位置 + 90/80 の残り) から開始されます。 現在の印刷位置と出力行の幅の差が ( `Count`または`Count` `Mod` *幅*) よりも小さい場合、 `SPC`関数は次の行の先頭にスキップし、と等しい`Count`スペースを生成します。-(*width* - *currentprintposition*)。  
  
> [!NOTE]
>  表形式の列に、ワイド文字を許可するのに十分な幅があることを確認します。  
  
   
  
## Examples  
 この例では`SPC` 、関数を使用して、出力をファイルと**出力**ウィンドウに配置します。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行の現在の印刷位置がより`Column`大きい場合は、 `TAB`次の出力行のと`Column`等しい列値に対してスキップします。 が`Column` 1 未満の場合は`TAB` 、印刷位置を列1に移動します。 が`Column`出力線の幅より大きい場合は`TAB` 、次の式を使用して次の印刷位置を計算します。  
  
 列の Mod の幅  
  
 たとえば、 *width*が80で、を指定`TAB(90)`した場合、次の印刷は列 10 (90/80 の剰余) から開始されます。 が`Column`現在の印刷位置より小さい場合は、計算された印刷位置の次の行で印刷が開始されます。 計算された印刷位置が現在の印刷位置より大きい場合は、同じ行の計算された印刷位置から印刷が開始されます。  
  
 出力行の左端の印刷位置は常に1です。 関数`Print`または`PrintLine`関数を使用してファイルに出力すると、出力ファイルの現在の幅が右端の印刷位置になります。これ`FileWidth`は、関数を使用して設定できます。  
  
 関数は、 `WriteLine`関数と共に使用することもできます。 `TAB` または<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>と共に使用することはできません。  
  
> [!NOTE]
>  表形式の列に、ワイド文字を格納するのに十分な幅があることを確認します。  
  
   
  
## Examples  
 この例では`TAB` 、関数を使用して、出力をファイルと**出力**ウィンドウに配置します。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">任意。 リスト内の次の式を表示または出力する前に移動する先の列番号。 省略した場合、<see langword="TAB" /> は挿入位置を次の印字領域の最初に移動します。</param>
        <summary><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns><see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行の現在の印刷位置がより`Column`大きい場合は、 `TAB`次の出力行のと`Column`等しい列値に対してスキップします。 が`Column` 1 未満の場合は`TAB` 、印刷位置を列1に移動します。 が`Column`出力線の幅を超える場合は`TAB` 、次の式を使用して次の印刷位置を計算します。  
  
 列の Mod の幅  
  
 たとえば、 *width*が80で、を指定`TAB(90)`した場合、次の印刷は列 10 (90/80 の剰余) から開始されます。 が`Column`現在の印刷位置より小さい場合は、計算された印刷位置の次の行で印刷が開始されます。 計算された印刷位置が現在の印刷位置より大きい場合は、同じ行の計算された印刷位置から印刷が開始されます。  
  
 出力行の左端の印刷位置は常に1です。 関数`Print`または`PrintLine`関数を使用してファイルに出力すると、出力ファイルの現在の幅が右端の印刷位置になります。これ`FileWidth`は、関数を使用して設定できます。  
  
 関数は、 `WriteLine`関数と共に使用することもできます。 `TAB` または<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>と共に使用することはできません。  
  
> [!NOTE]
>  表形式の列に、ワイド文字を格納するのに十分な幅があることを確認します。  
  
   
  
## Examples  
 この例では`TAB` 、関数を使用して、出力をファイルと**出力**ウィンドウに配置します。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 および`Lock`関数`Unlock`は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock`関数`Unlock`と関数は、常にペアで使用されます。 `Lock` および`Unlock`の引数は、同一である必要があります。  
  
 、 `Record` `FromRecord` 、`ToRecord`またはが指定されていない場合、ファイル全体のロックがになります。 単独`Record`のを指定した場合、1つのレコードはロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力`Lock`または出力用に開かれている場合は、とで`Unlock` `FromRecord` `ToRecord`指定された範囲に関係なく、ファイル全体に影響します。  
  
   
  
## Examples  
 この例では、関数`Lock`と`Unlock`関数の使用方法を示します。 この例では`People.txt` 、が構造体`Person`のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="Record">任意。 ロックまたはアンロックされる唯一のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 および`Lock`関数`Unlock`は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock`関数`Unlock`と関数は、常にペアで使用されます。 `Lock` および`Unlock`の引数は、同一である必要があります。  
  
 、 `Record` `FromRecord` 、`ToRecord`またはが指定されていない場合、ファイル全体のロックがになります。 単独`Record`のを指定した場合、1つのレコードはロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力`Lock`または出力用に開かれている場合は、とで`Unlock` `FromRecord` `ToRecord`指定された範囲に関係なく、ファイル全体に影響します。  
  
   
  
## Examples  
 この例では、関数`Lock`と`Unlock`関数の使用方法を示します。 この例では`People.txt` 、が構造体`Person`のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netcore-3.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数。</param>
        <param name="FromRecord">任意。 ロックまたはアンロックされる最初のレコードまたはバイトの番号。</param>
        <param name="ToRecord">任意。 ロックまたはアンロックされる最後のレコードまたはバイトの番号。</param>
        <summary><see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 および`Lock`関数`Unlock`は、複数のプロセスが同じファイルへのアクセスを必要とする環境で使用されます。  
  
 `Lock`関数`Unlock`と関数は、常にペアで使用されます。 `Lock` および`Unlock`の引数は、同一である必要があります。  
  
 、 `Record` `FromRecord` 、`ToRecord`またはが指定されていない場合、ファイル全体のロックがになります。 単独`Record`のを指定した場合、1つのレコードはロックまたはロック解除されます。  
  
 ファイルがシーケンシャル入力`Lock`または出力用に開かれている場合は、とで`Unlock` `FromRecord` `ToRecord`指定された範囲に関係なく、ファイル全体に影響します。  
  
   
  
## Examples  
 この例では、関数`Lock`と`Unlock`関数の使用方法を示します。 この例では`People.txt` 、が構造体`Person`のレコードを含むファイルであることを前提としています。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">任意。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、<see langword="Input" /> を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Write` と`WriteLine`関数は、下位互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 を省略`Output`した場合は、空白行がファイルに出力されます。 複数の式は、コンマで区切ることができます。  
  
 関数とは異なり、 `Write`関数は、ファイルに書き込まれる文字列の前後に、項目間にコンマを挿入します。 `Print` 明示的な区切り記号を一覧に含める必要はありません。 を`Write`使用してファイルにデータを書き込む場合、数値、 `Boolean`、日付、null、および`Error`データ形式のみがサポートされます。 次の一般的な仮定に従うと、ロケールに関係なく、データは常`Input`にを使用して読み取ることができ、正しく解釈されます。  
  
-   数値データは、常に小数点区切り文字としてピリオドを使用して書き込まれます。  
  
-   データ`Boolean`の場合`#TRUE#`は、 `#FALSE#`またはが出力されます。 ロケールに`False`関係なく、キーワードとキーワードは翻訳されません。`True`  
  
-   日付データは、ユニバーサル日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
-   データが空の場合`Output` 、ファイルには何も書き込まれません。 ただし、null データ`#NULL#`の場合は、が書き込まれます。  
  
-   データ`Error`の場合、出力はと`#ERROR errorcode#`して表示されます。 `Error`キーワードは、ロケールに関係なく、変換されません。  
  
 `WriteLine`最後の`Chr(13) + Chr(10)` `Output`文字をファイルに書き込んだ後に、改行文字 (つまり、復帰/ラインフィード、または) を挿入します。  
  
 二重引用符または "" を使用して、文字列に引用符を埋め込むことができます。 たとえば、オブジェクトに適用された  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 の`Double quotation marks aren't "difficult" to handle`値を持つ文字列を返します。  
  
 関数`Write`または関数を使用して`WriteLine`ファイルに書き込むには`FileIOPermissionAccess` 、列挙からアクセスする必要があり`Append`ます。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Write` 、関数を使用して、シーケンシャルファイルに生データを書き込みます。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須です。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">任意。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、<see langword="Input" /> を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 関数`Write` と`WriteLine`関数は、下位互換性のために用意されており、パフォーマンスに影響を与える可能性があります。 レガシ以外のアプリケーションでは、 `My.Computer.FileSystem`オブジェクトのパフォーマンスが向上します。 詳細については、「 [Visual Basic を使用したファイルアクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)」を参照してください。  
  
 を省略`Output`した場合は、空白行がファイルに出力されます。 複数の式は、コンマで区切ることができます。  
  
 関数とは異なり、 `Write`関数は、ファイルに書き込まれる文字列の前後に、項目間にコンマを挿入します。 `Print` 明示的な区切り記号を一覧に含める必要はありません。 を`Write`使用してファイルにデータを書き込む場合、数値、 `Boolean`、日付、null、および`Error`データ形式のみがサポートされます。 次の一般的な仮定に従うと、ロケールに関係なく、データは常`Input`にを使用して読み取ることができ、正しく解釈されます。  
  
-   数値データは、常に小数点区切り文字としてピリオドを使用して書き込まれます。  
  
-   データ`Boolean`の場合`#TRUE#`は、 `#FALSE#`またはが出力されます。 ロケールに`False`関係なく、キーワードとキーワードは翻訳されません。`True`  
  
-   日付データは、ユニバーサル日付形式を使用してファイルに書き込まれます。 日付または時刻コンポーネントが見つからないかゼロの場合は、指定された部分だけがファイルに書き込まれます。  
  
-   データが空の場合`Output` 、ファイルには何も書き込まれません。 ただし、null データ`#NULL#`の場合は、が書き込まれます。  
  
-   データ`Error`の場合、出力はと`#ERROR errorcode#`して表示されます。 `Error`キーワードは、ロケールに関係なく、変換されません。  
  
 `WriteLine`最後の`Chr(13) + Chr(10)` `Output`文字をファイルに書き込んだ後に、改行文字 (つまり、復帰/ラインフィード、または) を挿入します。  
  
 二重引用符または "" を使用して、文字列に引用符を埋め込むことができます。 たとえば、オブジェクトに適用された  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 の`Double quotation marks aren't "difficult" to handle`値を持つ文字列を返します。  
  
 関数`Write`または関数を使用して`WriteLine`ファイルに書き込むには`FileIOPermissionAccess` 、列挙からアクセスする必要があり`Append`ます。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では`Write` 、関数を使用して、シーケンシャルファイルに生データを書き込みます。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を使用してファイルにテキストを書き込む</related>
      </Docs>
    </Member>
  </Members>
</Type>
