<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aea33b9e902b909e4adf9f543fadb5190ce68f9b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69109974" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Reflection.Emit.ILGenerator" /> クラス メンバー (<see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> など) による出力に対する MSIL (Microsoft Intermediate Language) 命令のフィールド表現を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーオペコードの詳細については、共通言語基盤 (CLI) のドキュメント (特に「パーティション III:CIL 命令セットとパーティション II:メタデータの定義とセマンティクス "。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
   
  
## Examples  
 次の例は、を使用して<xref:System.Reflection.Emit.ILGenerator>に出力`OpCodes` <xref:System.Reflection.Emit.MethodBuilder>する動的メソッドを構築する方法を示しています。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を加算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|58|add|2つの数値を加算して、新しい数値を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`value1`がに`value2`追加されます。  
  
4.  結果がスタックにプッシュされます。  
  
 整数演算のオーバーフローは検出されません (適切なオーバーフロー <xref:System.Reflection.Emit.OpCodes.Add_Ovf>処理の場合は、「」を参照してください)。  
  
 整数の加算は、飽和度ではなく、ラップします。 たとえば、が255に設定され、 `value1`が1に設定さ`value2`れている8ビット整数と想定した場合、ラップされた結果は256ではなく0になります。  
  
 浮動小数点オーバーフローは`+inf` 、`PositiveInfinity`() `-inf`また`NegativeInfinity`は () を返します。  
  
 許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。 特定の型の組み合わせ (や`int32` `float`など) のエントリがない場合は。`int32` また`int64`、無効な Microsoft 中間言語 (MSIL) であり、エラーが生成されます。  
  
|オペランド|value1 型|value2 型|結果の種類|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `add`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数を加算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D6|ovf を追加します。|オーバーフローチェック付きの2つの符号付き整数値を追加します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。は、オーバーフロー `value2`のチェックを使用してに追加されます。 `value1`  
  
4.  結果がスタックにプッシュされます。  
  
 <xref:System.OverflowException>結果が結果型に表示されない場合は、がスローされます。  
  
 この操作は、符号付き整数に対して実行できます。 浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Add>、を使用します。  
  
 許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。 特定の型の組み合わせ (や`int32` `float`など) のエントリがない場合は。`int32` また`int64`、これは無効な MSIL (Microsoft 中間言語) 命令であり、エラーが生成されます。  
  
|オペランド|value1 型|value2 型|結果の種類|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `add.ovf`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を加算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|オーバーフローチェック付きの2つの符号なし整数値を追加します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。は、オーバーフロー `value2`のチェックを使用してに追加されます。 `value1`  
  
4.  結果がスタックにプッシュされます。  
  
 <xref:System.OverflowException>結果が結果型に表示されない場合は、がスローされます。  
  
 この操作は、符号付き整数に対して実行できます。 浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Add>、を使用します。  
  
 許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。 特定の型の組み合わせ (や`int32` `float`など) のエントリがない場合は。`int32` また`int64`、これは無効な MSIL (Microsoft 中間言語) 命令であり、エラーが生成されます。  
  
|オペランド|value1 型|value2 型|結果の種類|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `add.ovf.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値のビットごとの AND を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|命令|説明|  
|------------|-----------------|-----------------|  
|5F (|and|2つの整数値のビットごとの AND を決定します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value1`と`value2`はスタックからポップされ、2つの値のビットごとの and が計算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`and`は、スタックの上位2つの値のビットごとの and を計算し、結果をスタックに残します。  
  
 `And`は整数固有の演算です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `and`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドの引数リストへのアンマネージ ポインターを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 00|arglist|現在のメソッドの引数リストハンドルを返します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 命令`arglist`は、現在のメソッドの引数リストを表す不透明な`native int`ハンドル (型のアンマネージポインター) を返します。 このハンドルは、現在のメソッドの有効期間中にのみ有効です。 ただし、現在のメソッドがコントロールのスレッド上にある限り、ハンドルを他のメソッドに渡すことができます。 この命令は`arglist` 、可変個の引数を受け取るメソッド内でのみ実行できます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `arglist`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq`target`|2つの値が等しい場合`target`は、オフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がに`value2`等しい場合は、分岐演算が実行されます。  
  
 が`beq`と等しい`value1`場合、命令は、指定されたターゲット命令に制御を転送します。`value2` 効果は、命令の`ceq`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 許容されるオペランドの型は、次のようにカプセル化されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。  
  
 `try` 、`catch`、、および<xref:System.Reflection.Emit.OpCodes.Leave>ブロックとの間の制御転送は、この命令では実行できません (このような転送は厳しく制限されており、代わりに命令を使用する必要があります)。 `finally` `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `beq`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|同じ、短い形式の場合は`target` 、オフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がに`value2`等しい場合は、分岐演算が実行されます。  
  
 が`beq.s`と等しい`value1`場合、命令は、指定されたターゲット命令に制御を転送します。`value2` 効果は、命令の`ceq`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 許容されるオペランドの型は、次のようにカプセル化されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。  
  
 `try` 、`catch`、、および<xref:System.Reflection.Emit.OpCodes.Leave>ブロックとの間の制御転送は、この命令では実行できません (このような転送は厳しく制限されており、代わりに命令を使用する必要があります)。 `finally` `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `beq.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge`target`|最初の値が2番目の値以上の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。  
  
 命令`bge`は、が以上の`value1`場合に、指定されたターゲット命令に制御を転送します。`value2` 効果は、命令の`clt.un`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|.2F`<int8>`|bge.s `target`|最初の値が2番目の値 (短い形式) 以上の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。  
  
 命令`bge.s`は、が以上の`value1`場合に、指定されたターゲット命令に制御を転送します。`value2` 効果は、命令の`clt.un`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge`target`|最初の値が2番目の値 (符号なしの値) 以上の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。  
  
 命令`bge.un`は、符号なし整数または順序なし`value1` float 値を使用して`value2`比較した場合、が以上の場合に、指定されたターゲット命令に制御を転送します。 効果は、命令の`clt`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|最初の値が2番目の値 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。  
  
 命令`bge.un.s`は、符号なし整数または順序なし`value1` float 値を使用して`value2`比較した場合、が以上の場合に、指定されたターゲット命令に制御を転送します。 効果は、命令の`clt`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge.un.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt`target`|最初の値が2番目の値よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。  
  
 が`bgt` `value1`より大きい`value2`場合、命令は、指定されたターゲット命令に制御を転送します。 効果は、命令の`cgt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|最初の値が2番目の値 (短い形式) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。  
  
 が`bgt.s` `value1`より大きい`value2`場合、命令は、指定されたターゲット命令に制御を転送します。 効果は、命令の`cgt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|最初の値が2番目の値 (符号なしの値) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。  
  
 命令は、符号なし整数または順序なし`value1` float 値を`value2`使用して比較した場合、がより大きい場合は、指定されたターゲット命令に制御を転送します。 `bgt.un` 効果は、命令の`cgt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|最初の値が2番目の値 (符号なしの値) (短い形式) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。  
  
 命令は、符号なし整数または順序なし`value1` float 値を`value2`使用して比較した場合、がより大きい場合は、指定されたターゲット命令に制御を転送します。 `bgt.un.s` 効果は、命令の`cgt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt.un.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3E`<int32>`|ble`target`|最初の値が2番目の値以下の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。  
  
 が`ble` 以下の`value1`場合、命令は、指定されたターゲット命令に制御を転送します。`value2` 効果は、 `cgt`命令 (`cgt.un` `brfalse` float) を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|31 `<int8>`|. s`target`|最初の値が2番目の値 (短い形式) 以下の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。  
  
 が`ble.s` 以下の`value1`場合、命令は、指定されたターゲット命令に制御を転送します。`value2` 効果は、 `cgt`命令 (`cgt.un` float`brfalse` ) 命令を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|43 `<int32>`|un`target`|最初の値が2番目の値 (符号なしの値) 以下の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。  
  
 命令は、 `value1`が符号なし整数または順序なし float 値を使用し`value2`て比較した場合に、指定されたターゲット命令に制御を転送します。 `ble.un` 効果は、 `cgt.un`命令 (`cgt` `brfalse` float) を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|36 `<int8>`|un. s`target`|最初の値が2番目の値 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。  
  
 命令は、 `value1`が符号なし整数または順序なし float 値を使用し`value2`て比較した場合に、指定されたターゲット命令に制御を転送します。 `ble.un.s` 効果は、 `cgt.un`命令 (`cgt` `brfalse` float) を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble.un.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt`target`|最初の値が2番目の値より小さい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。  
  
 が`blt` 以下の`value1`場合、命令は、指定されたターゲット命令に制御を転送します。`value2` 効果は、命令の`clt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt`target`|最初の値が2番目の値 (短い形式) より小さい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。  
  
 が`blt.s` `value1`より小さい`value2`場合、命令は、指定されたターゲット命令に制御を転送します。 効果は、命令の`clt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt`target`|最初の値が2番目の値 (符号なしの値) より小さい場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。  
  
 命令`blt.un`は、符号なし整数または順序なし float 値を`value2`使用して比較した場合、がより小さい場合`value1`は、指定されたターゲット命令に制御を転送します。 効果は、命令の`clt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|最初の値が2番目の値 (符号なしの値) (短い形式) よりも小さい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。  
  
 命令`blt.un`は、符号なし整数または順序なし float 値を`value2`使用して比較した場合、がより小さい場合`value1`は、指定されたターゲット命令に制御を転送します。 効果は、命令の`clt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt.un.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne`target`|2つの符号なし整数値が等しくない場合 (符号なしの値)、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がと等しく`value2`ない場合は、分岐演算が実行されます。  
  
 命令は、符号なし整数または順序なし`value1` float 値を使用`value2`して比較した場合、がと等しくない場合は、指定されたターゲット命令に制御を転送します。 `bne.un` 効果は、命令の`ceq`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bne.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne`target`|2つの符号なし整数値が等しくない場合 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます`value1` 。がと等しく`value2`ない場合は、分岐演算が実行されます。  
  
 命令は、符号なし整数または順序なし`value1` float 値を使用`value2`して比較した場合、がと等しくない場合は、指定されたターゲット命令に制御を転送します。 `bne.un` 効果は、命令の`ceq`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bne.un.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型をオブジェクト参照 (<see langword="O" /> 型) に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8C < `T` >|箱`valTypeToken`|(で`valTypeToken`指定された型の) 値型を true オブジェクト参照に変換します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型がスタックにプッシュされます。  
  
2.  値の型がスタックからポップされます。`box`操作が実行されます。  
  
3.  結果の "ボックス化された" 値型へのオブジェクト参照がスタックにプッシュされます。  
  
 値型には、共通言語基盤 (CLI) 内の2つの異なる表現があります。  
  
-   値型が別のオブジェクトまたはスタックに埋め込まれている場合に使用される ' 未加工 ' フォーム。  
  
-   ' ボックス化された ' フォーム。値型のデータは、独立したエンティティとして存在できるように、オブジェクトにラップ (ボックス化) されます。  
  
 命令`box`は、' raw ' (ボックス化が解除された) 値型を`O`オブジェクト参照 (型) に変換します。 これは、新しいオブジェクトを作成し、値型から新しく割り当てられたオブジェクトにデータをコピーすることで実現されます。 `valTypeToken`スタック上の値型の型を示すメタデータトークンです。  
  
 <xref:System.OutOfMemoryException>要求を満たすのに十分なメモリがない場合は、がスローされます。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `box`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br`target`|指定されたオフセットでターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 命令`br`は無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `br`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|指定されたオフセット (短い形式) でターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 命令`br.s`は無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `br.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブレークポイントがトリップしたことをデバッガーに通知するように、共通言語基盤 (CLI) に通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|01|break|ブレークポイントに達したことをデバッガーに通知します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 この`break`命令は、デバッグをサポートするためのものです。 これは、ブレークポイントがトリップしたことをデバッガーに通知するよう CLI に通知します。 インタープリターの状態に他の影響はありません。  
  
 `break`命令には、ブレークポイントを使用してコードを修正し、周囲のコードへの影響を最小限に抑えることができる、最小限の命令サイズがあります。  
  
 命令`break`は、デバッガーへのトラップ、何も行わない、またはセキュリティ例外の発生を行うことができます。 実際の動作は実装定義です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `break`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="false" />、null 参照 (Visual Basic の場合は <see langword="Nothing" />)、または 0 の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse`target`<br /><br /> brnull`target`<br /><br /> brzero`target`|の場合`false`、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`は、前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。`target`が`value` の場合`false`は、をに分岐します。  
  
 命令`brfalse` (およびそのエイリアス`brnull`および`brzero`) は、(型`int32`、 `int64`、オブジェクト参照`O`、 `value`マネージポインター) の場合、指定されたターゲット命令に制御を転送します。、transient `*`ポインター) が 0 (`false`) です。 `native int` `&` が`value` 0 以外の場合 (`true`)、次の命令で実行が続行されます。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brfalse`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="false" />、null 参照または 0 の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse`target`<br /><br /> brnull.s `target`<br /><br /> brzero s`target`|、短い形式の場合は`false`、指定したオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`は、前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。`target`が`value` の場合`false`は、をに分岐します。  
  
 命令`brfalse.s` (およびそのエイリアス`brnull`および`brzero`) は、(型`int32`、 `int64`、オブジェクト参照`O`、 `value`マネージポインター) の場合、指定されたターゲット命令に制御を転送します。、transient `*`ポインター) が 0 (`false`) です。 `native int` `&` が`value` 0 以外の場合 (`true`)、次の命令で実行が続行されます。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brfalse.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue`target`<br /><br /> brinst`target`|0`true`以外の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`は、前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。`target`が`value` の場合`true`は、をに分岐します。  
  
 命令`brtrue`は、(type `native int`) が0以外 ( `value` `true`) の場合に、指定されたターゲット命令に制御を転送します。 が`value` 0 (`false`) の場合、次の命令で実行が続行されます。  
  
 が`value`オブジェクト参照 (型`O`) `brinst`である場合、(の`brtrue`別名) は、オブジェクトのインスタンスを表す場合に制御を転送します (たとえば、null オブジェクト参照でない場合は<xref:System.Reflection.Emit.OpCodes.Ldnull>、「」を参照してください)。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brtrue`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst. s`target`|0以外 (`true`)、短い形式の場合は、指定されたオフセットでターゲット命令に分岐します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`は、前の操作によってスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。`target`が`value` の場合`true`は、をに分岐します。  
  
 命令`brtrue.s`は、(type `native int`) が0以外 ( `value` `true`) の場合に、指定されたターゲット命令に制御を転送します。 が`value` 0 (`false`) の場合、次の命令で実行が続行されます。  
  
 が`value`オブジェクト参照 (型`O`) `brinst`である場合、(の`brtrue`別名) は、オブジェクトのインスタンスを表す場合に制御を転送します (たとえば、null オブジェクト参照でない場合は<xref:System.Reflection.Emit.OpCodes.Ldnull>、「」を参照してください)。  
  
 ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brtrue.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>渡されたメソッド記述子によって示されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|28 < `T` >|発信`methodDesc`|「」で説明さ`methodDesc`れているメソッドを呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `arg1` から`argN`のメソッド引数はスタックにプッシュされます。  
  
2.  を介し`arg1` `argN`たメソッド引数はスタックからポップされます。メソッドの呼び出しはこれらの引数を使用して実行され、制御はメソッド記述子によって参照されるメソッドに転送されます。 完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。  
  
3.  戻り値はスタックにプッシュされます。  
  
 命令`call`は、命令で渡されたメソッド記述子によって示されるメソッドを呼び出します。 メソッド記述子は、呼び出すメソッドと、そのメソッドに渡されるスタックに配置された引数の数、型、および順序、および使用される呼び出し規約を示すメタデータトークンであり、 命令`call`の前には、 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックス命令を指定して、現在のメソッドの状態を解放してから制御を転送するように指定できます。 呼び出しが、元のメソッドよりも高い信頼のメソッドに制御を転送する場合、スタックフレームは解放されません。 代わりに、が`tail`指定されていないかのように実行が自動的に続行されます。 メタデータトークンは、呼び出しが静的メソッド、インスタンスメソッド、仮想メソッド、またはグローバル関数のいずれであるかを判断するために十分な情報を保持します。 これらのすべてのケースでは、宛先アドレスはメソッド記述子から完全に決定されます<xref:System.Reflection.Emit.OpCodes.Callvirt> (これは仮想メソッドを呼び出すための命令と比較します。宛先アドレスもインスタンスのランタイム型に依存します。参照がの前<xref:System.Reflection.Emit.OpCodes.Callvirt>にプッシュされました。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。 次の3つの重要な特殊なケースがあります。  
  
 1. インスタンス (または仮想) メソッドの呼び出しでは、ユーザーに表示される引数の前に、そのインスタンス参照をプッシュする必要があります。 インスタンス参照を null 参照にすることはできません。 メタデータに格納されているシグネチャには、 `this`ポインターのパラメーターリストにエントリが含まれていません。代わりに、ビットを使用して、メソッドが`this`ポインターを渡す必要があるかどうかを示します。  
  
 2. `call` (`callvirt`ではなく) を使用して仮想メソッドを呼び出すことができます。これは、メソッドが、呼び出されるオブジェクトから動的に指定されるのではなく、メソッドによって指定されたクラスを使用して解決されることを示します。  
  
 3. デリゲートの`Invoke`メソッドは、 `call`命令または`callvirt`命令を使用して呼び出すことができます。  
  
 <xref:System.Security.SecurityException>呼び出されたメソッドへのアクセスがシステムセキュリティによって付与されていない場合にスローされる可能性があります。 セキュリティチェックは、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に発生する可能性があります。  
  
> [!NOTE]
>  値型に対して system.object のメソッドを呼び出す場合は、 `constrained`命令を`call`出力`callvirt`する代わりに、命令と共にプレフィックスを使用することを検討してください。 これにより、値型がメソッドをオーバーライドするかどうかによって異なる IL を生成する必要がなくなり、バージョン管理の問題が発生する可能性がなくなります。 インターフェイスメソッドを`constrained`実装する値型のメソッドはを`MethodImpl`使用して変更できるため、値型に対してインターフェイスメソッドを呼び出すときは、プレフィックスを使用することを検討してください。 これらの問題の詳細については<xref:System.Reflection.Emit.OpCodes.Constrained> 、「オペコード」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `call`オペコードを使用できます。  
  
-   ILGenerator (オペコード, MethodInfo)  
  
-   ILGenerator EmitCall (オペコード、MethodInfo、型 [])  
  
> [!NOTE]
>  メソッド<xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>は、呼び出し用`varargs`に用意されています。 通常の<xref:System.Reflection.Emit.ILGenerator.Emit%2A>呼び出しにはメソッドを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し規約によって記述されている引数を使用して、評価スタックで (エントリ ポイントへのポインターとして) 指定されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|29 < `T` >|呼び出し`callSiteDescr`|呼び出し規約によって記述された引数を使用して、が指すメソッドを呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `arg1` から`argN`のメソッド引数はスタックにプッシュされます。  
  
2.  メソッドのエントリポインターがスタックにプッシュされます。  
  
3.  メソッドの`arg1`引数`argN`とメソッドのエントリポインターはスタックからポップされ、メソッドの呼び出しが実行されます。 完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。  
  
4.  戻り値はスタックにプッシュされます。  
  
 命令`calli`は、を通じて`argN`引数`arg1`を指定してメソッドのエントリポインターを呼び出します。 これらの引数の型は、特定の呼び出し規則 (`callSiteDesc`) によって記述されます。 命令`calli`の前`tail`にプレフィックス (<xref:System.Reflection.Emit.OpCodes.Tailcall>) を付けると、コントロールを転送する前に現在のメソッドの状態を解放するように指定できます。 呼び出しによって、元のメソッドより高い信頼のメソッドに制御が転送される場合、スタックフレームは解放されません。代わりに、が`tail`指定されていないかのように、実行は暗黙的に続行されます。  
  
 メソッドのエントリポインターは、(ターゲットコンピューターの) ネイティブコードへの特定のポインターと見なされます。このポインターは、呼び出し規約 (スタンドアロン署名の場合はメタデータトークン) で記述された引数を使用して、正規的に呼び出すことができます。 このようなポインターは、 <xref:System.Reflection.Emit.OpCodes.Ldftn>命令また<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>は命令を使用して作成することも、ネイティブコードから渡すこともできます。  
  
 呼び出し規約は動的にチェックされないため、指定さ`calli`れた呼び出し規約を変換先が実際に使用していない場合、命令を使用するコードは正常に機能しません。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。 インスタンスまたは仮想メソッドの引数作成コードシーケンスは、ユーザーに表示される引数の前に、そのインスタンス参照 (null 参照ではない必要があります) をプッシュする必要があります。  
  
 <xref:System.Security.SecurityException>呼び出されたメソッドへの呼び出し元アクセスがシステムセキュリティによって付与されていない場合にスローされる可能性があります。 セキュリティチェックは、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に発生する可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>のメソッドを使用して、スタック`calli`で命令を実行できます。 は、 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>クラスを使用して命令を直接スタックに配置するのではなく、以下のメソッドを通じて呼び出す必要があります。`calli`  
  
-   マネージ呼び出し規約を使用した呼び出しの場合は、ILGenerator EmitCalli (オペコード、CallingConventions、Type、Type []、Type [])。  
  
-   アンマネージ呼び出し規約を使用した呼び出しの場合は、ILGenerator EmitCalli (オペコード、CallingConvention、Type、Type [])。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト上で遅延バインディング メソッドを呼び出し、戻り値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|に`obj`関連付けられた特定のメソッドを呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`obj`がスタックにプッシュされます。  
  
2.  `arg1` から`argN`のメソッド引数はスタックにプッシュされます。  
  
3.  とオブジェクト`arg1`参照`argN`を介したメソッド引数はスタックからポップされます。メソッド呼び出しはこれらの引数を使用`obj`して実行され、メソッドによって参照されるメソッドに制御が移ります。 `obj`メタデータトークン。 完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。  
  
4.  戻り値はスタックにプッシュされます。  
  
 この`callvirt`命令は、オブジェクトに対して遅延バインディングメソッドを呼び出します。 つまり、メソッドは、メソッドポインターで参照できるコンパイル時クラス`obj`ではなく、のランタイム型に基づいて選択されます。 `Callvirt`を使用すると、仮想メソッドとインスタンスメソッドの両方を呼び出すことができます。 命令`callvirt`の直前に`tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックスを付けて、コントロールを転送する前に現在のスタックフレームを解放するように指定することができます。 呼び出しによって、元のメソッドよりも高い信頼のメソッドに制御が転送される場合、スタックフレームは解放されません。  
  
 メソッドメタデータトークンは、呼び出すメソッドの名前、クラス、および署名を提供します。 に`obj`関連付けられているクラスは、それがインスタンスであるクラスです。 クラスが、指定されたメソッド名とシグネチャに一致する非静的メソッドを定義している場合、このメソッドが呼び出されます。 それ以外の場合は、このクラスの基底クラスチェーンにあるすべてのクラスが順番にチェックインされます。 メソッドが見つからない場合、エラーになります。  
  
 `Callvirt`メソッドを呼び出す前に、オブジェクトと関連する引数を評価スタックからポップします。 メソッドに戻り値がある場合、メソッドの完了時にスタックにプッシュされます。 呼び出し先側`obj`では、パラメーターは引数0として`arg1` 、引数1などとしてアクセスされます。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。 インスタンス参照`obj` (では`callvirt`常に必須) は、ユーザーが参照できる引数のいずれかの前にプッシュする必要があります。 (メタデータトークンに含まれる) シグネチャには、このポインターのパラメーターリストにエントリが含まれていてはなりません。  
  
 仮想メソッドは、 <xref:System.Reflection.Emit.OpCodes.Call>命令を使用して呼び出すこともできます。  
  
 <xref:System.MissingMethodException>は、指定された名前およびシグネチャを持つ非静的メソッドが、 `obj`またはその基底クラスに関連付けられているクラスで見つからなかった場合にスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 <xref:System.NullReferenceException>obj が null の場合にスローされます。  
  
 <xref:System.Security.SecurityException>呼び出されたメソッドへのアクセスがシステムセキュリティによって付与されていない場合は、がスローされます。 セキュリティチェックは、CIL が実行時ではなくネイティブコードに変換されたときに発生する可能性があります。  
  
> [!NOTE]
>  値型に対して system.object のメソッドを呼び出すときは、と`constrained`いう`callvirt`命令でプレフィックスを使用することを検討してください。 これにより、値型がメソッドをオーバーライドするかどうかによって異なる IL を生成する必要がなくなり、バージョン管理の問題が発生する可能性がなくなります。 インターフェイスメソッドを`constrained`実装する値型のメソッドはを`MethodImpl`使用して変更できるため、値型に対してインターフェイスメソッドを呼び出すときは、プレフィックスを使用することを検討してください。 これらの問題の詳細については<xref:System.Reflection.Emit.OpCodes.Constrained> 、「オペコード」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `callvirt`オペコードを使用できます。  
  
-   ILGenerator (オペコード, MethodInfo)  
  
-   ILGenerator EmitCall (オペコード、MethodInfo、型 [])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したクラスへの参照により渡されたオブジェクトをキャストしようとします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass`class`|オブジェクトを型`class`の新しいオブジェクトにキャストします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされます。参照先のオブジェクトは、指定さ`class`れたとしてキャストされます。  
  
3.  成功すると、新しいオブジェクト参照がスタックにプッシュされます。  
  
 命令`castclass`は、スタックの一番上にあるオブジェクト`O`参照 (型) を指定されたクラスにキャストしようとします。 新しいクラスは、必要なクラスを示すメタデータトークンによって指定されます。 スタックの一番上にあるオブジェクトのクラスが新しいクラスを実装していない (新しいクラスがインターフェイスであると仮定している) 場合、が新しいクラスの派生クラス<xref:System.InvalidCastException>ではない場合は、がスローされます。 オブジェクト参照が null 参照の場合、 `castclass`は成功し、新しいオブジェクトを null 参照として返します。  
  
 <xref:System.InvalidCastException>obj をクラスにキャストできない場合は、がスローされます。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `castclass`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 2 つの値が等しい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 01|ceq|がに等しい`value1` `value2`場合は1をプッシュします。それ以外の場合は0をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。はと比較されます。`value1` `value2`  
  
4.  が`value1` に`value2`等しい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 命令`ceq`はと`value1` を`value2`比較します。 が`value1`に`value2`等しい場合、1 (型`int32`) がスタックにプッシュされます。 それ以外の場合は`int32`、0 (型) がスタックにプッシュされます。  
  
 浮動小数点数の場合、 `ceq`は、数値が順序付けられていない場合は0を返します (または両方が NaN)。 無限値は、それ自体と同じです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ceq`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 02|cgt|がより`value1` `value2`大きい場合は1を、それ以外の場合は0をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`cgt`が`value1`より大きい`value2`かどうかをテストします。  
  
4.  が`value1` より`value2`大きい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 命令`cgt`はと`value1` を`value2`比較します。 が`value1`厳密により`value2`大きい場合、 `int32`値1がスタックにプッシュされます。 それ以外の`int32`場合、値0がスタックにプッシュされます。  
  
-   浮動小数点数の場合、 `cgt`数値が順序付けられていない場合 (つまり、引数の一方または両方が NaN の場合) は、0を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cgt`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値または順序なしの値を比較します。 最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|がより`value1` `value2`大きい場合は1を、それ以外の場合は 0 (符号なしの値) をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`cgt.un`が`value1`より大きい`value2`かどうかをテストします。  
  
4.  が`value1` より`value2`大きい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 次のいずれかに該当する場合は、 `int32`値1がスタックにプッシュされます。 `true`  
  
 浮動小数点数値の場合`value1` 、はに`value2`対して順序付けられません。  
  
 整数値の場合`value1` 、は符号なし`value2`数値として見なされる場合より厳密に大きくなります。  
  
 それ以外`int32`の場合、値0がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cgt.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値が有限数ではない場合は、<see cref="T:System.ArithmeticException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|C3|ckfinite|値<xref:System.ArithmeticException>が有限数でない場合は、をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。 
  
2.  `value`がスタック`ckfinite`からポップされ、命令が実行されます。  
  
3.  `value`例外がスローされない場合は、がスタックに戻されます。  
  
 ( `ckfinite instruction`浮動小数`value`点数) が "not no `+-` number" 値 (NaN) または無限大値の場合、はをスロー <xref:System.ArithmeticException>します。 `Ckfinite`例外がスローされない場合は、スタックの値をそのままにします。 が浮動小数点数`value`でない場合、実行は指定されません。  
  
 <xref:System.ArithmeticException>が ' normal `value` ' の数値でない場合は、がスローされます。  
  
 特別な例外またはの<xref:System.ArithmeticException>派生クラスがより適切である可能性があることに注意してください。例外ハンドラーに間違った値を渡します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ckfinite`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が 2 番目の値より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 04|clt|がより`value1` `value2`小さい場合は1をプッシュします。それ以外の場合は0をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。 

1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`clt`が`value1`より小さい`value2`かどうかをテストします。  
  
4.  が`value1` より`value2`小さい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 命令`clt`はと`value1` を`value2`比較します。 が`value1`厳密により`value2`小さい場合、 `int32`値1がスタックにプッシュされます。 それ以外の`int32`場合、値0がスタックにプッシュされます。  
  
-   浮動小数点数の場合、 `clt`数値が順序付けられていない場合 (つまり、引数の一方または両方が NaN の場合) は、0を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `clt`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値または順序なしの値である <paramref name="value1" /> と <paramref name="value2" /> を比較します。 <paramref name="value1" /> が <paramref name="value2" /> より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|がより`value1` `value2`小さい場合は1を、それ以外の場合は 0 (符号なしの値) をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`clt.un`が`value1`より小さい`value2`かどうかをテストします。  
  
4.  が`value1` より`value2`小さい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。  
  
 命令`clt.un`はと`value1` を`value2`比較します。 次のいずれかに該当する場合は、値1がスタックにプッシュされます。`int32`  
  
-   `value1`は (の場合`value2`と同様に`clt`) より厳密にはありません。  
  
-   浮動小数点数値の場合`value1` 、はに`value2`対して順序付けられません。  
  
-   整数値の場合`value1` 、は符号なし`value2`数値として見なされる場合より厳密には小さくなります。  
  
 それ以外の`int32`場合、値0がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `clt.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想メソッド呼び出しをする対象の型を制約します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|制約付き. `thisType`|型`T`として制約されている型に対して仮想メソッドを呼び出します。|  
  
 プレフィックスは、 `callvirt`命令でのみ許可されます。 `constrained`  
  
 この時点での MSIL スタックの状態は、次のようにする必要があります。  
  
1.  マネージポインター `ptr`がスタックにプッシュされます。 の型は`ptr` 、のマネージポインター (`&`) `thisType`である必要があります。 これは、プレフィックス`callvirt`のない命令の場合とは異なることに注意してください。これは、の`thisType`参照を想定しています。  
  
2.  `callvirt`から`arg1` のメソッド`argN`引数は、プレフィックスのない命令と同様にスタックにプッシュされます。  
  
 プレフィックスは、が値型`callvirt`と参照型のどちらであるか`thisType`に関係なく、一貫した方法で命令を行うことができるように設計されています。 `constrained`  
  
 命令の前にが付いている場合、命令は次のように実行されます。`thisType` `constrained` `callvirt` `method`  
  
-   が`thisType`参照型 (値型ではない`ptr` ) の場合、はを逆参照し、 `callvirt`のへの`method`' this ' ポインターとして渡されます。  
  
-   が`thisType`値`call` `ptr` `method` `method`型であり、を`method`実装している場合、によるの実装について、は、命令への ' this ' ポインターとして未変更のまま渡されます。 `thisType` `thisType`.  
  
-   が`thisType`値`ptr` `method` `callvirt`型であり、を実装`method`していない場合は、を逆参照してボックス化し、命令への ' this ' ポインターとして渡します。 `thisType`  
  
 この最後のケースは、が`method` 、 <xref:System.ValueType>、また<xref:System.Object>は<xref:System.Enum>で定義されており`thisType`、でオーバーライドされていない場合にのみ発生します。 この場合、ボックス化によって元のオブジェクトのコピーが作成されます。 ただし、、 <xref:System.Object> <xref:System.ValueType>、および<xref:System.Enum>のいずれのメソッドもオブジェクトの状態を変更しないので、このファクトを検出することはできません。  
  
 この`constrained`プレフィックスは、ジェネリックコードを作成する IL ジェネレーターをサポートしています。 通常、 `callvirt`命令は値型では無効です。 代わりに、IL コンパイラは、の`ptr`型および呼び出されるメソッドに応じて、コンパイル時に上記で説明した ' this ' 変換を効果的に実行する必要があります。 ただし、が`ptr`コンパイル時に不明なジェネリック型である場合、コンパイル時にこの変換を行うことはできません。  
  
 オペコードを使用すると、IL コンパイラは、が値型か参照型か`ptr`にかかわらず、同じ方法で仮想関数を呼び出すことができます。 `constrained` `thisType`はジェネリック型の変数`constrained`であることを目的としていますが、プレフィックスは非ジェネリック型に対しても機能し、値の型の区別を隠す言語での仮想呼び出しの生成の複雑さを軽減できます。参照型。  
  
 また、 `constrained`プレフィックスを使用すると、値の型に関する潜在的なバージョン管理の問題を回避できます。 プレフィックスを`constrained`使用しない場合は、値型が system.object のメソッドをオーバーライドするかどうかに応じて、異なる IL を生成する必要があります。 たとえば、値`V`型がオブジェクトの ToString () メソッド`Object.ToString()` `call` `V.ToString()`をオーバーライドする場合、命令が`box`生成されます。 `callvirt`そうでない場合は、命令と命令が生成されます。 前のケースでは、オーバーライドが後で削除された場合は、バージョン管理の問題が発生する可能性があります。後者の場合は、オーバーライドが後で追加されます。  
  
 インターフェイスメソッドを実装する値型のメソッドはを`MethodImpl`使用して変更できるため、プレフィックスを使用して値型のインターフェイスメソッドを呼び出すこともできます。`constrained` `constrained`プレフィックスを使用しない場合、コンパイラはコンパイル時にバインドする値型のメソッドを強制的に選択します。 `constrained`プレフィックスを使用すると、コンパイル時ではなく、実行時にインターフェイスメソッドを実装するメソッドに MSIL をバインドできます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `constrained`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="native int" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D3|conv. i|をに`native int`変換し`native int` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.i`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int8" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|67|conv|をに`int8`変換し`int32` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.i1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int16" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|68|i2|をに`int16`変換し`int32` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.i2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|69|conv.i4|をに`int32`変換し`int32` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.i4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int64" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6A|i8|をに`int64`変換し`int64` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.i8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|を`native int` (`native int`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|符号なしの値を`native int` (として`native int`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|を`int8` (`int32`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|符号なしの値を`int8` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i1.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i1.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int16" /> に変換し、変換した値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|を`int16` (`int32`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|符号なしの値を`int16` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i2.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i2.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|を`int32` (`int32`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|符号なしの値を`int32` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i4.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i4.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|を`int64` (`int64`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|符号なしの値を`int64` (として`int64`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.i8.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i8.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|を`unsigned native int` (`native int`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|アン unsigned 値を`unsigned native int` ( `native int`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.uvf.u.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|を`unsigned int8` (`int32`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|符号なしの値を`unsigned int8` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u1.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u1.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|を`unsigned int16` (`int32`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|符号なしの値を`unsigned int16` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u2.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u2.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|を`unsigned int32` (`int32`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|符号なしの値を`unsigned int32` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u4.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u4.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|を`unsigned int64` (`int64`スタック上の) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|符号なしの値を`unsigned int64` (として`int64`スタック上で) に変換し、オーバーフロー時に例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。 オーバーフローが発生した場合は、例外がスローされます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.ovf.u8.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。 値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u8.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の符号なし整数値を <see langword="float32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|76|conv.r.un|符号なし整数を浮動小数点型に`F`変換し、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.r.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生`result`した場合、返されるは指定されません。 この`conv.r.un`操作は、スタックから整数を取得し、それを符号なしとして解釈し、整数を表す浮動小数点数に置き換えます`float32`。この値が有効桁数が大きい場合、整数を表すのに十分な幅である場合は、それ以外の場合はです`float64`。  
  
 このフィールドを使用する場合、例外はスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.r.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="float32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6B|conv.r4|をに`float32`変換し`F` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.r4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.r4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="float64" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6C|conv.r8|をに`float64`変換し`F` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.r8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.r8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned native int" /> に変換し、その値を <see langword="native int" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|E0|conv|をに`unsigned native int`変換し`native int` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.u`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D2|conv|をに`int8`変換し`int32` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.u1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D1|conv. u2|をに`int16`変換し`int32` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.u2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int32" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6D|u4|をに`unsigned int32`変換し`int32` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.u4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int64" /> に変換し、その値を <see langword="int64" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|6E|u8|をに`int64`変換し`int64` 、スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`がスタックからポップされ、変換操作が試行されます。  
  
3.  変換が成功した場合、結果の値はスタックにプッシュされます。  
  
 オペコード`conv.u8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。 4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。 浮動小数点値は`F`型に変換されます。  
  
 浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。 `float64` から`float32`に変換する場合、有効桁数が失われる可能性があります。 が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。 ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。 結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。  
  
 浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。  
  
 このフィールドを使用する場合、例外はスローされません。 結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>始点アドレスからエンド ポイント アドレスに指定した数のバイトをコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|メモリブロック間でデータをコピーします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  宛先アドレスはスタックにプッシュされます。  
  
2.  ソースアドレスはスタックにプッシュされます。  
  
3.  コピーするバイト数がスタックにプッシュされます。  
  
4.  バイト数、送信元アドレス、および宛先アドレスがスタックからポップされます。指定されたバイト数が、転送元アドレスから宛先アドレスにコピーされます。  
  
 命令`cpblk`は、 `&` `*` `unsigned int32` `&` `native int`送信元アドレス(、、または)から宛先アドレス(型、型、または型)に、バイトの数(型)をコピーします。`native int` `*` コピー元と`cpblk`コピー先の領域が重複する場合、の動作は指定されません。  
  
 `cpblk`送信元と送信先の両方がコンピューターの自然サイズに合わせて配置されていることを前提としています。 命令は、転送元または転送`unaligned.<prefix>`先のどちらかが整列していないことを示す命令の直前に記述できます。 `cpblk`  
  
 `cpblk`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cpblk`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にある値型をコピー先のオブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|ソースオブジェクトから変換先オブジェクトに値型をコピーします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  ターゲットオブジェクト参照がスタックにプッシュされます。  
  
2.  ソースオブジェクト参照がスタックにプッシュされます。  
  
3.  2つのオブジェクト参照がスタックからポップされます。ソースオブジェクトのアドレスの値の型が、コピー先のオブジェクトのアドレスにコピーされます。  
  
 ソースオブジェクトと`cpobj`ターゲットオブジェクトの参照が、クラストークン`classTok` ( `typeref`または`typedef`) によって表されるクラスのインスタンスへのポインターではない場合、また`classTok`はがを表していない場合、の動作は指定されません。値の型。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cpobj`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値の除算を実行し、結果を浮動小数点値 (<see langword="F" /> 型) または商 (<see langword="int32" /> 型) として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5B|div|2つの値を除算して、商または浮動小数点の結果を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。はによっ`value2`て除算されます。 `value1`  
  
4.  結果がスタックにプッシュされます。  
  
 `result` = `value1`div value2 は、次の条件を満たしています。  
  
 &#124;`result` &#124; = &#124; / &#124;、および: &#124; &#124; `value1` `value2`  
  
 `value2``value1``value2`sign () = +、`value1`sign () = sign ()、または-、if sign () ~ = sign ()`result`  
  
 命令`div`は、結果を計算してスタックにプッシュします。  
  
 整数除算は0方向に切り捨てられます。  
  
 有限数を0で除算すると、正しい符号付きの無限値が生成されます。  
  
 0をゼロまたは無限大で除算すると、NaN (非数) 値が生成されます。 任意の数を無限大で除算すると、ゼロ値が生成されます。  
  
 結果が結果<xref:System.ArithmeticException>の型で表現できない場合、整数演算はをスローします。 これは、が`value1`負の最大値`value2`で、が-1 の場合に発生する可能性があります。  
  
 が0の<xref:System.DivideByZeroException>場合`value2` 、整数演算がスローされます。  
  
 Intel ベースのプラットフォームでは、( <xref:System.OverflowException> minint div-1) を計算すると、がスローされることに注意してください。 浮動小数点演算では、例外がスローされることはありません (代わりに Nan または無限大が生成されます)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `div`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を除算し、結果 (<see langword="int32" />) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5C|div.un|2つの値を符号なしで除算して商を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。はによっ`value2`て除算されます。 `value1`  
  
4.  結果がスタックにプッシュされます。  
  
 命令は`div.un` 、符号なし`value2`整数として`result`取得されたによって除算され、をスタックにプッシュします。`value1`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `div.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値をコピーし、そのコピーを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|25|dup|スタックの一番上の値を複製します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`複製のためにスタックからポップされます。  
  
3.  `value`はスタックに戻されます。  
  
4.  重複する値がスタックにプッシュされます。  
  
 命令`dup`はスタックの最上位要素を複製し、2つの同一の値をその上に残します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `dup`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外の <see langword="filter" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|SEH 例外処理のフィルター句を終了します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`スタックからポップされます。`endfilter`が実行され、制御が例外ハンドラーに転送されます。  
  
 `Value`(型`int32`であり、特定の値のセットの1つである必要があります) は、フィルター句から返されます。 次のいずれかである必要があります。  
  
-   `exception_continue_search`(`value` = 0) 例外ハンドラーの検索を続行します。  
  
-   `exception_execute_handler`(`value` = 1) 例外処理の2番目のフェーズを開始します。 finally ブロックは、このフィルター句に関連付けられているハンドラーが見つかるまで実行されます。 検出が完了すると、ハンドラーが実行されます。  
  
 その他の整数値は、指定されていない結果を生成します。  
  
 フィルターのエントリポイントは、メソッドの例外テーブルに示されているように、フィルターのコードブロックの最初の命令である必要があります。 命令`endfilter`は、フィルターのコードブロックの最後の命令である必要があります (したがって`endfilter` 、1つのフィルターブロックには1つしか存在できません)。 `endfilter`命令を実行した後、制御は CLI 例外処理機構に論理的に戻ります。  
  
 例外メカニズムを使用する場合を除き、コントロールをフィルターブロックに転送することはできません。 命令を使用する場合`throw` 、または最後`endfilter`の命令を実行する場合を除き、コントロールをフィルターブロックの外に移動することはできません。 ブロックを`filter`ブロック内`try`に埋め込むことはできません。 `filter`ブロック内で例外がスローされると、その例外はインターセプトされ、値`exception_continue_search`0 () が返されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `endfilter`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外ブロックの <see langword="fault" /> 句または <see langword="finally" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|例外ブロック`finally`の`fault`句または句を終了します。|  
  
 この命令に対するスタック移行の動作はありません。  
  
 `Endfinally`と`endfault`は、例外ハンドラーが`finally`呼び出されるまでスタックアンワインドが続行されるように、または`fault`句の末尾を通知します。 また`endfinally` は`endfault`命令は、CLI 例外機構に制御を戻します。 次に、leave 命令で保護`finally`されたブロックが終了した場合に、チェーン内の次の句を検索します。 例外を使用して保護されたブロックが終了した場合、CLI `finally`は`fault`次のまたはを検索します。または、例外処理の最初のパス中に選択された例外ハンドラーを入力します。  
  
 命令`endfinally`は、 `finally`ブロック内で構文的にのみ表示される場合があります。 命令とは異なり、ブロックが`endfinally`命令で終了する必要はありません。また、ブロック内に`endfinally`必要な数の命令を指定することもできます。 `endfilter` これらの同じ制限は`endfault` 、命令`fault`とブロックにも適用されます。  
  
 例外メカニズムを使用する場合`finally`を除き`fault`、コントロールを (または) ブロックに転送することはできません。 `finally` `fault`命令を`throw`使用するか(また`endfault`は) 命令を実行する場合を除き、(または) ブロックから制御を転送することはできません。 `endfinally` 特に`finally` 、(または`fault`) <xref:System.Reflection.Emit.OpCodes.Ret>ブロックを "フォールアウト" したり、 `finally` ( `fault`または) <xref:System.Reflection.Emit.OpCodes.Leave>ブロック内でまたは命令を実行したりすることはできません。  
  
 `endfault` と`endfinally`の手順はエイリアスであり、同じオペコードに対応していることに注意してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `endfinally` (`endfault`) オペコードと`ILGenerator`メソッド<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>を使用できます。  
  
-   ILGenerator (オペコード)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したアドレスの指定したメモリ ブロックを指定のサイズと初期値に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 18|initblk|メモリブロック内の各場所を特定の値に設定します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  開始アドレスがスタックにプッシュされます。  
  
2.  初期化値がスタックにプッシュされます。  
  
3.  初期化するバイト数がスタックにプッシュされます。  
  
4.  バイト数、初期化値、および開始アドレスがスタックからポップされ、その値に従って初期化が実行されます。  
  
 命令`initblk`は、指定され`unsigned int32`たアドレス (型、型、 `&`または`*`型`native int`) から始まるバイトの数 () を初期化値 ( `unsigned int8`型) に設定します。 `initblk`では、開始アドレスがマシンの自然サイズにアラインされることを前提としています。  
  
 `initblk`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの命令によって変更できます。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `initblk`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したアドレスにある値型の各フィールドを null 参照または適切なプリミティブ型の 0 に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|値型を初期化します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  初期化する値の型のアドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。指定されたアドレスの値型は、型`typeTok`として初期化されます。  
  
 命令`initobj`は、プッシュされたアドレス (型、型`&`、または`*`型`native int`) によって指定された値型の各フィールドを null 参照または適切なプリミティブ型の0に初期化します。 このメソッドが呼び出されると、インスタンスは、コンストラクターメソッドを呼び出すことができる状態になります。 が`typeTok`参照型の場合、この命令はの後に`stind.ref`続く`ldnull`場合と同じ効果があります。  
  
 と<xref:System.Reflection.Emit.OpCodes.Newobj>は`initobj`異なり、はコンストラクターメソッドを呼び出しません。 `Initobj`は、値型を`newobj`初期化するためのものです。を使用して、オブジェクトの割り当てと初期化を行います。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `initobj`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照 (<see langword="O" /> 型) が特定のクラスのインスタンスかどうかをテストします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst`class`|オブジェクト参照がの`class`インスタンスであるかどうかをテストし、null 参照またはそのクラスまたはインターフェイスのインスタンスを返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照はスタックからポップされ、渡されたクラスのインスタンスで`class`あるかどうかをテストします。  
  
3.  結果 (オブジェクト参照または null 参照) がスタックにプッシュされます。  
  
 `Class`は、必要なクラスを示すメタデータトークンです。 スタックの一番上にあるオブジェクトのクラスがを`class`実装している場合 (がインターフェイスである場合`class` )、また`class`はの`class`派生クラスである場合 (が通常のクラスの`class`場合)、型にキャストされ、結果がスタックにプッシュされます。が呼び出され<xref:System.Reflection.Emit.OpCodes.Castclass>た場合とまったく同じです。 それ以外の場合は、null 参照がスタックにプッシュされます。 オブジェクト参照自体が null 参照`isinst`の場合は、同様に null 参照が返されます。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `isinst`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドを終了し、指定したメソッドにジャンプします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|現在のメソッドを終了し、指定したメソッドにジャンプします。|  
  
 この命令に対するスタック移行の動作はありません。  
  
 ( `jmp`ジャンプ) 命令は、メソッド参照のメタデータトークン`method`であるによって指定されたメソッドに制御を転送します。 現在の引数は、転送先のメソッドに転送されます。  
  
 この命令の実行時には、評価スタックが空である必要があります。 呼び出し規約、宛先アドレスの引数の数と型は、現在のメソッドの引数と一致している必要があります。  
  
 `jmp`命令は`try`、 `filter` 、、`finally` 、またはブロックから制御を転送するためには使用できません。 `catch`  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `jmp`オペコードを使用できます。  
  
-   ILGenerator (オペコード, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したインデックス値によって参照される引数をスタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg`index`|引数をスタック`index`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  の引数値`index`はスタックにプッシュされます。  
  
 命令`ldarg`は、にインデックスが設定`index`された引数をプッシュします。引数は0以降から評価スタックにインデックスが付けられます。 `ldarg`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 可変長の引数リストを受け取るプロシージャの場合、命令は`ldarg` 、シグネチャの変数部分に含まれるものではなく、初期の固定引数に対してのみ使用でき<xref:System.Reflection.Emit.OpCodes.Arglist>ます (詳細については、「」を参照してください)。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg`オペコードを使用できます。  
  
-   ILGenerator (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|02|ldarg.0|引数0をスタックに読み込みます|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス0の引数値はスタックにプッシュされます。  
  
 `ldarg.0`命令は、インデックス0で引数値を読み込むための効率的なエンコードです。  
  
 命令`ldarg.0`は、0にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.0`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.0`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|03|ldarg|引数1をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス1の引数値がスタックにプッシュされます。  
  
 命令`ldarg.1`は、インデックス1で引数値を読み込むための効率的なエンコードです。  
  
 命令`ldarg.1`は、1にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.1`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|04|ldarg|引数2をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス2の引数値がスタックにプッシュされます。  
  
 命令`ldarg.2`は、インデックス2で引数値を読み込むための効率的なエンコードです。  
  
 命令`ldarg.2`は、2にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.2`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|05|ldarg|引数3をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス3の引数値がスタックにプッシュされます。  
  
 `ldarg.3`命令は、インデックス3で引数値を読み込むための効率的なエンコードです。  
  
 命令`ldarg.3`は、3にインデックスが付けられた引数を評価スタックにプッシュします。 `ldarg.3`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.3`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した短い形式のインデックスによって参照される引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|引数`index`をスタック (短い形式) に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  の引数値`index`はスタックにプッシュされます。  
  
 命令`ldarg.s`は、4 ~ 255 のインデックスが付けられた引数を読み込むための効率的なエンコーディングです。  
  
 命令`ldarg.s`は、にインデックスが設定`index`された引数をプッシュします。引数は0以降から評価スタックにインデックスが付けられます。 `ldarg.s`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。 引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。  
  
 可変長の引数リストを受け取るプロシージャの場合、命令は`ldarg.s` 、シグネチャの変数部分に含まれるものではなく、初期の固定引数に対してのみ使用でき<xref:System.Reflection.Emit.OpCodes.Arglist>ます (詳細については、「」を参照してください)。  
  
 長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード、byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga`index`|によって`index`インデックス付けされた引数のアドレスを取得します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  によっ`addr`て`index`インデックス付けされた引数のアドレスがスタックにプッシュされます。  
  
 命令`ldarga`は、によって`index`インデックスが`*`作成された引数のアドレス (型) をフェッチします。引数のインデックスは0以降です。 アドレス`addr`は、常にターゲットコンピューターの自然な境界に合わせて調整されます。  
  
 可変長の引数リストを受け取るプロシージャの場合、命令は`ldarga` 、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 `ldarga`は、ref パラメーターを渡すために使用されます。 その他の場合<xref:System.Reflection.Emit.OpCodes.Ldarg>は<xref:System.Reflection.Emit.OpCodes.Starg> 、とを使用する必要があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarga`オペコードを使用できます。  
  
-   ILGenerator (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレス (短い形式) を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|によって`index`インデックス付けされた引数のアドレスを短縮形でフェッチします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  によっ`addr`て`index`インデックス付けされた引数のアドレスがスタックにプッシュされます。  
  
 `ldarga.s`(の`ldarga`短い形式) は、0 ~ 255 の引数の数値に使用する必要があり、より効率的なエンコードです。  
  
 命令`ldarga.s`は、によって`index`インデックスが`*`作成された引数のアドレス (型) をフェッチします。引数のインデックスは0以降です。 アドレス`addr`は、常にターゲットコンピューターの自然な境界に合わせて調整されます。  
  
 可変長の引数リストを受け取るプロシージャの場合、命令は`ldarga.s` 、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 `ldarga.s`は、ref パラメーターを渡すために使用されます。 その他の場合<xref:System.Reflection.Emit.OpCodes.Ldarg_S>は<xref:System.Reflection.Emit.OpCodes.Starg_S> 、とを使用する必要があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarga.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード、byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc i4`num`|値`num`をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値`num`はスタックにプッシュされます。  
  
 整数-128 ~ 127、特に-1 ~ 8 の短いエンコーディングには、特別な短い (つまり、効率的な) エンコーディングがあることに注意してください。 すべての短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。 長いエンコーディングは、8バイトの整数、4および8バイトの浮動小数点数、および短い形式には適合しない4バイトの値に使用されます。 8バイトの整数定数をスタックにプッシュするには、3つの方法があります。  
  
 1. 32ビット<xref:System.Reflection.Emit.OpCodes.Ldc_I8>を超える定数を表現する必要がある場合は、この命令を使用します。  
  
 2. 9 ~ <xref:System.Reflection.Emit.OpCodes.Ldc_I4> 32 ビットが必要<xref:System.Reflection.Emit.OpCodes.Conv_I8>な定数には、命令の後にを使用します。  
  
 3. 短い形式の命令を使用して<xref:System.Reflection.Emit.OpCodes.Conv_I8> 、8以下のビットで表現できる定数を指定します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4`オペコードを使用できます。  
  
-   ILGenerator (オペコード, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 0 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|0をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値0はスタックにプッシュされます。  
  
 これは、整数値0のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.0`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 1 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|1をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値1がスタックにプッシュされます。  
  
 これは、整数値1をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 2 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|2をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値2がスタックにプッシュされます。  
  
 これは、整数値2のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 3 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|3をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値3がスタックにプッシュされます。  
  
 これは、整数値3をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.3`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 4 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|4をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値4がスタックにプッシュされます。  
  
 これは、整数値4のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 5 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|5をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値5がスタックにプッシュされます。  
  
 これは、整数値5をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.5`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 6 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|6をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値6がスタックにプッシュされます。  
  
 これは、整数値6のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.6`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 7 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|7をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値7がスタックにプッシュされます。  
  
 これは、整数値7のプッシュに対する特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.7`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 8 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|8をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値8がスタックにプッシュされます。  
  
 これは、整数値8をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 -1 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|-1 をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値-1 がスタックにプッシュされます。  
  
 これは、整数値-1 をプッシュするための特殊な短いエンコーディングです。 すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.m1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int8" /> 値を <see langword="int32" /> として評価スタックにプッシュします (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|`int32`は、短い形式でスタックにプッシュ`num`します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値`num`はスタックにプッシュされます。  
  
 `ldc.i4.s`は、-128 から127への整数を評価スタックにプッシュするためのより効率的なエンコードです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード、byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc. i8`num`|を`num`として`int64`スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値`num`はスタックにプッシュされます。  
  
 このエンコーディングは`int64` 、値をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i8`オペコードを使用できます。  
  
-   ILGenerator.Emit(OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc. r4`num`|を`num`として`F`スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値`num`はスタックにプッシュされます。  
  
 このエンコーディングは`float32` 、値をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.r4`オペコードを使用できます。  
  
-   ILGenerator (オペコード、single)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|を`num`として`F`スタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値`num`はスタックにプッシュされます。  
  
 このエンコーディングは`float64` 、値をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.r8`オペコードを使用できます。  
  
-   ILGenerator (オペコード、double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの要素を命令で指定された型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem`typeTok`|の要素`index`を、型`typeTok`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであり、したがって型`O`の値によって表されます。  
  
 戻り値の型は、命令のトークン`typeTok`によって指定されます。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`上限より大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="native int" /> 型の要素を <see langword="native int" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|97|ldelem.i|の`native int` 型`native int`の要素をとしてスタックの一番上に読み込みます`index` 。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.i`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.i`戻り値は`native int`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|の型`int8` `int32`の要素をとしてスタックの一番上に読み込みます。`index`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.i1`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.i1`戻り値は`int8`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|の型`int16` `int32`の要素をとしてスタックの一番上に読み込みます。`index`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.i2`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.i2`戻り値は`int16`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|の型`int32` `int32`の要素をとしてスタックの一番上に読み込みます。`index`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.i4`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.i4`戻り値は`int32`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int64" /> 型の要素を <see langword="int64" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|の型`int64` `int64`の要素をとしてスタックの一番上に読み込みます。`index`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.i8`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.i8`戻り値は`int64`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="float32" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|の型`float32` `F`の要素を、型としてスタックの一番上に読み込みます。`index`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.r4`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.r4`戻り値は`float32`です。  
  
 浮動小数点値は、評価スタック`F`に読み込まれるときに型に変換されます。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.r4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="float64" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|の型`float64` `F`の要素を、型としてスタックの一番上に読み込みます。`index`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.r8`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.r8`戻り値は`float64`です。  
  
 浮動小数点値は、評価スタック`F`に読み込まれるときに型に変換されます。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.r8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスのオブジェクト参照を格納している要素を <see langword="O" /> 型 (オブジェクト参照) として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|のオブジェクト参照`index`を持つ要素を、型`O`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.ref`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.ref`戻り値は、型`O` (オブジェクト参照) です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.ref`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|の型`unsigned int8` `int32`の要素をとしてスタックの一番上に読み込みます。`index`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.u1`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.u1`戻り値は`int8`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.u1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|インデックスの型`unsigned int16`の要素を`int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.u2`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.u2`戻り値は`int16`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.u2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|インデックスの型`unsigned int32`の要素を`int32`としてスタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。  
  
4.  値はスタックにプッシュされます。  
  
 命令`ldelem.u4`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。  
  
 の`ldelem.u4`戻り値は`int32`です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、配列が必要な型の要素を保持していない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.u4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスにある配列要素のアドレスを <see langword="&amp;" /> 型 (マネージド ポインター) として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema`class`|の`index`配列要素のアドレスを型`&` (マネージポインター) として評価スタックの一番上に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index`と`array`はスタックからポップされ、の`array`位置`index`に格納されているアドレスが検索されます。  
  
4.  アドレスはスタックにプッシュされます。  
  
 は`ldelema` 、オブジェクトの配列 (型`class`) の特定のインデックス位置にあるオブジェクトのアドレスを取得するために使用されます。 命令`ldelema`は、0から始まる1次元配列`array`の`index`インデックス ( `native int`型) に値のアドレスを読み込み、スタックの一番上に配置します。 配列はオブジェクトであるため、型`O`の値によって表されます。 この値は、命令で`class`渡された型である必要があります。  
  
 の`ldelema`戻り値はマネージポインター (型`&`) です。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelema`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドの値を検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld`field`|指定したオブジェクトのフィールドの値をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 (またはポインター) がスタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクト内の指定されたフィールドの値が見つかりました。  
  
3.  フィールドに格納されている値がスタックにプッシュされます。  
  
 命令`ldfld`は、オブジェクトにあるフィールドの値をスタックにプッシュします。 オブジェクトは、 `O`オブジェクト参照 (型)、マネージポインター (型`&`)、アンマネージポインター ( `native int`型)、遷移ポインター (型`*`)、または値型のインスタンスとしてスタック上にある必要があります。 アンマネージポインターを使用することは、検証可能なコードでは許可されていません。 オブジェクトのフィールドは、フィールドメンバーを参照する必要があるメタデータトークンによって指定されます。 戻り値の型は、フィールドに関連付けられているものと同じです。 フィールドは、インスタンスフィールド (この場合は、オブジェクトを null 参照にすることはできません) または静的フィールドのいずれかになります。  
  
 命令`ldfld`の前に、プレフィックス<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックスのどちらかまたは両方を付けることができます。  
  
 <xref:System.NullReferenceException>オブジェクトが null で、フィールドが静的でない場合は、がスローされます。  
  
 <xref:System.MissingFieldException>指定したフィールドがメタデータ内に見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldfld`オペコードを使用できます。  
  
-   ILGenerator (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドのアドレスを検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|指定したオブジェクト`field`ののアドレスをスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照 (またはポインター) がスタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクト内の指定されたフィールドのアドレスが見つかりました。  
  
3.  指定されたフィールドのアドレスがスタックにプッシュされます。  
  
 命令`ldflda`は、オブジェクトにあるフィールドのアドレスをスタックにプッシュします。 オブジェクトは、 `O`オブジェクト参照 (型)、マネージポインター (型`&`)、アンマネージポインター ( `native int`型)、遷移ポインター (型`*`)、または値型のインスタンスとしてスタック上にある必要があります。 アンマネージポインターを使用することは、検証可能なコードでは許可されていません。 オブジェクトのフィールドは、フィールドメンバーを参照する必要があるメタデータトークンによって指定されます。  
  
 によって`ldflda`返される値は、オブジェクトが`&`アンマネージポインターとしてスタックにプッシュされない限り、マネージポインター (型) です。この場合、戻りアドレスも`native int`アンマネージポインター (型) になります。  
  
 命令`ldflda`の前に、プレフィックス<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックスのどちらかまたは両方を付けることができます。  
  
 <xref:System.InvalidOperationException>オブジェクトがアクセス元のアプリケーションドメイン内にない場合は、がスローされます。 アクセスしているアプリケーションドメインに含まれていないフィールドのアドレスを読み込むことができません。  
  
 <xref:System.NullReferenceException>オブジェクトが null で、フィールドが静的でない場合は、がスローされます。  
  
 <xref:System.MissingFieldException>指定したフィールドがメタデータ内に見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldflda`オペコードを使用できます。  
  
-   ILGenerator (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のメソッドを実装しているネイディブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|スタック上のによって`method`参照されるメソッドへのポインターをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  特定のメソッドへのアンマネージポインターがスタックにプッシュされます。  
  
 特定のメソッド (`method`) は、マネージメソッド ( <xref:System.Reflection.Emit.OpCodes.Calli>またはマネージコードからアンマネージコードに遷移するスタブ) を参照する場合は、命令を使用して呼び出すことができます。  
  
 返される値は、CLR 呼び出し規約を使用してネイティブコードを指します。 このメソッドポインターは、アンマネージネイティブコードにコールバックルーチンとして渡すことはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldftn`オペコードを使用できます。  
  
-   ILGenerator (オペコード, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="native int" /> 型の値を <see langword="native int" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4D|ldind.i|`native int`アドレス`native int` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.i`は、指定さ`native int`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`native int`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|46|ldind.i1|`int32`アドレス`int8` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。 
  
 命令`ldind.i1`は、指定さ`int8`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`int32`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|48|ldind.i2|`int32`アドレス`int16` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.i2`は、指定さ`int16`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`int32`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|`int32`アドレス`int32` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.i4`は、指定さ`int32`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`int32`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|`int64`アドレス`int64` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.i8`は、指定さ`int64`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`int64`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|`F`アドレス`float32` の値を型としてスタックに読み込みます。`addr`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.r4`は、指定さ`float32`れたアドレス (型、型`native int`、 `&`または *) からの値を、型`F`としてスタックに間接的に読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.r4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|`F`アドレス`float64` の値を型としてスタックに読み込みます。`addr`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.r8`は、指定さ`float64`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`float64`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.r8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照を <see langword="O" /> 型 (オブジェクト参照) として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|50|ldind.ref|アドレス`addr`にあるオブジェクト参照を型としてスタックに読み込みます`O`|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにあるオブジェクト参照がフェッチされます。  
  
3.  フェッチされた参照がスタックにプッシュされます。  
  
 命令`ldind.ref`は、指定されたアドレス (型`native int`、 `&`、または *) のオブジェクト参照を、型`O`としてスタックに間接的に読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.ref`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|47|ldind.u1|`int32`アドレス`unsigned int8` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.u1`は、指定さ`unsigned int8`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`int32`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.u1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|49|ldind.u2|`int32`アドレス`unsigned int16` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.u2`は、指定さ`unsigned int16`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`int32`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.u2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|`int32`アドレス`unsigned int32` の値をとしてスタック`addr`に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされます。アドレスにある値がフェッチされます。  
  
3.  フェッチされた値はスタックにプッシュされます。  
  
 命令`ldind.u4`は、指定さ`unsigned int32`れたアドレス (型、型`native int`、 `&`または *) からの値をとし`int32`て間接的にスタックに読み込みます。  
  
 すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。  
  
 4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。 浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。  
  
 正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。  
  
 最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。 アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。 1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。 バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。  
  
 <xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.u4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス番号が 0 から始まる 1 次元配列の要素数を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8E|ldlen|配列の長さ (型`natural unsigned int`) をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列へのオブジェクト参照がスタックにプッシュされます。  
  
2.  配列参照がスタックからポップされ、長さが計算されます。  
  
3.  長さはスタックにプッシュされます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 長さはとして`natural unsigned int`返されます。  
  
 <xref:System.NullReferenceException>配列参照が null 参照の場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldlen`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc`index`|インデックス`index`位置にあるローカル変数をスタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数の値がスタックにプッシュされます。  
  
 命令`ldloc`は、渡されたインデックスのローカル変数番号の内容を評価スタックにプッシュします。この場合、ローカル変数の番号は0以降になります。 ローカル変数は、メソッドの initialize フラグが true の場合にのみ、メソッドに入る前に0に初期化されます。 65535 (2 ^ 16-1) ローカル変数を使用できます (0 ~ 65534)。 インデックス65535は有効ではありません。実装では、2バイトの整数を使用して、ローカルのインデックスと、特定のメソッドのローカルの合計数が追跡されるためです。 65535のインデックスが有効になっている場合は、このようなメソッドでローカルの数を追跡するために、より広い整数が必要になります。  
  
 、 、、および`ldloc.0`の`ldloc.3`各命令は、最初の4つのローカル変数にアクセスするための効率的なエンコーディングを提供します。 `ldloc.2` `ldloc.1`  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 「パーティション I」を参照してください。長さが4バイトより小さいローカル`int32`変数は、スタックに読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc`オペコードを使用できます。  
  
-   ILGenerator (オペコード、LocalBuilder)  
  
-   ILGenerator (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|06|ldloc.0|インデックス 0 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス0のローカル変数値はスタックにプッシュされます。  
  
 `ldloc.0`は、インデックス0のローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.0`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|07|ldloc|インデックス 1 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス1のローカル変数値がスタックにプッシュされます。  
  
 `ldloc.1`は、インデックス1のローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|08|ldloc|インデックス 2 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス2のローカル変数値がスタックにプッシュされます。  
  
 `ldloc.2`は、インデックス2でローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|09|ldloc|インデックス 3 のローカル変数を評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  インデックス3のローカル変数値がスタックにプッシュされます。  
  
 `ldloc.3`は、インデックス3でローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.3`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|インデックス`index`でローカル変数をスタックに読み込みます (短い形式)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数の値がスタックにプッシュされます。  
  
 命令`ldloc.s`は、渡されたインデックスのローカル変数番号の内容を評価スタックにプッシュします。この場合、ローカル変数の番号は0以降になります。 メソッドの initialize フラグが true の場合は、メソッドに入る前にローカル変数が0に初期化されます。 短い形式では、256 (2 ^ 8) ローカル変数 (0-255) が使用できます。これはより`ldloc`効率的なエンコードです。  
  
 値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。 「パーティション I」を参照してください。長さが4バイトより小さいローカル`int32`変数は、スタックに読み込まれるときに型に拡張されます。 浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード、LocalBuilder)  
  
-   ILGenerator (オペコード、byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE OD < `unsigned int16` >|ldloca`index`|のローカル変数`index`のアドレスを評価スタックに読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数に格納されているアドレスがスタックにプッシュされます。  
  
 命令`ldloca`は、渡されたインデックスにあるローカル変数番号のアドレスをスタックにプッシュします。ローカル変数には、0以降の番号が付けられます。 スタックにプッシュされた値は、や<xref:System.Reflection.Emit.OpCodes.Ldind_I> <xref:System.Reflection.Emit.OpCodes.Stind_I>などの命令で使用するために、既に正しく調整されています。 結果は、遷移ポインター (型`*`) です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloca`オペコードを使用できます。  
  
-   ILGenerator (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|のローカル変数`index`のアドレスを評価スタック (短い形式) に読み込みます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定したインデックス位置にあるローカル変数に格納されているアドレスがスタックにプッシュされます。  
  
 命令`ldloca.s`は、渡されたインデックスにあるローカル変数番号のアドレスをスタックにプッシュします。ローカル変数には、0以降の番号が付けられます。 スタックにプッシュされた値は、や<xref:System.Reflection.Emit.OpCodes.Ldind_I> <xref:System.Reflection.Emit.OpCodes.Stind_I>などの命令で使用するために、既に正しく調整されています。 結果は、遷移ポインター (型`*`) です。  
  
 命令`ldloca.s`は、ローカル変数 0 ~ 255 で使用するための効率的なエンコードを提供します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloca.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード、byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>null 参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|14|ldnull|null 参照をスタックにプッシュします|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  Null オブジェクト参照がスタックにプッシュされます。  
  
 `ldnull`null 参照 (型`O`) をスタックにプッシュします。 これは、データを格納する前に、または非推奨になったときに、場所を初期化するために使用されます。  
  
 `ldnull`サイズに依存しない null 参照を提供します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldnull`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレスが指す値型オブジェクトを評価スタックの一番上にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|値の型`class`のインスタンスをスタックにコピーします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型のオブジェクトのアドレスがスタックにプッシュされます。  
  
2.  アドレスはスタックからポップされ、その特定のアドレスのインスタンスが検索されます。  
  
3.  そのアドレスに格納されているオブジェクトの値がスタックにプッシュされます。  
  
 `ldobj`命令は、値型をパラメーターとして渡すために使用されます。  
  
 命令`ldobj`は、(、 `addrOfValObj` `&` `native int`、または型の) によってポイントされた値をスタックの一番上にコピーします。 `*` コピーされるバイト数は、 `class`パラメーターによって指定されたクラスのサイズによって異なります。 `class`パラメーターは、値の型を表すメタデータトークンです。  
  
 `ldobj`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldobj`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld`field`|スタックでの`field`値をプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  特定のフィールドの値がスタックにプッシュされます。  
  
 命令`ldsfld`は、静的 (クラスのすべてのインスタンスで共有される) フィールドの値をスタックにプッシュします。 戻り値の型は、渡されたメタデータ`field`トークンに関連付けられています。  
  
 命令`ldsfld`はプレフィックスを<xref:System.Reflection.Emit.OpCodes.Volatile>持つことができます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldsfld`オペコードを使用できます。  
  
-   ILGenerator (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドのアドレスを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|スタック上のの`field`アドレスをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  特定のフィールドのアドレスがスタックにプッシュされます。  
  
 命令`ldsflda`は、スタック上の静的 (クラスのすべてのインスタンス間で共有される) フィールドのアドレスをプッシュします。 メタデータトークン`field`が、メモリが管理されて`*`いる型を参照している場合は、このアドレスを transient ポインター (型) として表すことができます。 それ以外の場合は、アンマネージポインター ( `native int`型) に対応します。 は、割り当てられた相対仮想アドレス (それを含む PE ファイルがメモリに読み込まれるベースアドレスからのフィールドのオフセット) を持つ静的グローバルで、メモリが管理されていないことに注意してください。`field`  
  
 命令`ldsflda`はプレフィックスを<xref:System.Reflection.Emit.OpCodes.Volatile>持つことができます。  
  
 <xref:System.MissingFieldException>メタデータ内にフィールドが見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldsflda`オペコードを使用できます。  
  
-   ILGenerator (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータに格納されているリテラル文字列への新しいオブジェクト参照をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|メタデータ文字列トークン`mdToken`の文字列オブジェクトをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  文字列へのオブジェクト参照がスタックにプッシュされます。  
  
 命令`ldstr`は、メタデータに格納さ`O`れている特定の文字列リテラルを表す新しい文字列オブジェクトにオブジェクト参照 (型) をプッシュします。 命令`ldstr`は、必要な量のメモリを割り当て、ファイルで使用されている形式の文字列リテラルを実行時に必要な文字列形式に変換するために必要な任意の形式変換を実行します。  
  
 共通言語基盤 (CLI) では、2つの`ldstr`命令の結果、同じ文字シーケンスを持つ2つのメタデータトークンを参照すると、正確に同じ文字列オブジェクト ("文字列インターン" と呼ばれるプロセス) が返されることが保証されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldstr`オペコードを使用できます。  
  
-   ILGenerator (オペコード, string)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ トークンをそのランタイム表現に変換し、評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|メタデータトークンをそのランタイム表現に変換します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  渡されたトークンはに`RuntimeHandle`変換され、スタックにプッシュされます。  
  
 命令`ldtoken`は、指定`RuntimeHandle`されたメタデータトークンのをプッシュします。 には、、 `fieldref/fielddef`、また`methodref/methoddef`は`typeref/typedef`を指定できます。`RuntimeHandle`  
  
 スタックにプッシュされた値は、システムクラスライブラリ`Reflection`のメソッドの呼び出しで使用できます。  
  
 ランタイムハンドルの詳細については、 <xref:System.RuntimeFieldHandle>、 <xref:System.RuntimeTypeHandle>、および<xref:System.RuntimeMethodHandle>の各クラスを参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldtoken`オペコードを使用できます。  
  
-   ILGenerator (オペコード, MethodInfo)  
  
-   ILGenerator (オペコード、FieldInfo)  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したオブジェクトに関連付けられた特定の仮想メソッドを実装しているネイティブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|オブジェクトの仮想メソッド`method`へのポインターをスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、(メタデータトークン`method`によって指定された) メソッドへのエントリポイントのアドレスが検索されます。  
  
3.  へ`method`のポインターがスタックにプッシュされます。  
  
 `ldvirtftn`命令によってスタックにプッシュされたアンマネージポインターは、マネージ<xref:System.Reflection.Emit.OpCodes.Calli>メソッド (またはマネージコードからアンマネージコードに遷移するスタブ) を参照する場合、命令を使用して呼び出すことができます。  
  
 アンマネージポインターは、CLR 呼び出し規約を使用してネイティブコードを指します。 このメソッドポインターは、アンマネージネイティブコードにコールバックルーチンとして渡すことはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldvirtftn`オペコードを使用できます。  
  
-   ILGenerator (オペコード, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御を特定のターゲット命令に無条件で転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DD < `int32` >|出る`target`|コードの保護された領域を終了します。|  
  
 この命令にはスタック移行動作が指定されていません。  
  
 命令`leave`は無条件で特定のターゲット命令に制御を転送します。これは、現在の命令の後に続く命令の先頭から4バイト符号付きオフセットとして表されます。  
  
 `br` `try` `filter`命令は命令に似ていますが、、、または`catch`ブロックを終了するために使用できます。一方、通常の分岐命令は、このようなブロック内でのみ使用できます。 `leave`し. 命令`leave`によって、評価スタックが空になり、 `finally`適切な周辺ブロックが実行されます。  
  
 命令を`leave`使用してブロックを`finally`終了することはできません。 例外ハンドラーのコード生成を簡単にするために、catch ブロック内から有効な`leave`のは、関連付けられている`try`ブロック内の任意の命令に制御を転送する命令を使用することです。  
  
 命令にプレフィックスコードが1つ以上含まれている場合は、これらのプレフィックスの最初の部分にのみ制御を転送できます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `leave`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御をターゲット命令に無条件で転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DE < `int8` >|そのままにします。`target`|コードの保護された領域 (短い形式) を終了します。|  
  
 この命令にはスタック移行動作が指定されていません。  
  
 命令`leave.s`は、渡されたターゲット命令に無条件で制御を転送します。これは、現在の命令の後に続く命令の先頭から1バイト符号付きオフセットとして表されます。  
  
 `br` `try` `filter`命令は命令に似ていますが、、、または`catch`ブロックを終了するために使用できます。一方、通常の分岐命令は、このようなブロック内でのみ使用できます。 `leave.s`し. 命令`leave.s`によって、評価スタックが空になり、 `finally`適切な周辺ブロックが実行されます。  
  
 命令を`leave.s`使用してブロックを`finally`終了することはできません。 例外ハンドラーのコード生成を簡単にするために、catch ブロック内から有効な`leave.s`のは、関連付けられている`try`ブロック内の任意の命令に制御を転送する命令を使用することです。  
  
 命令にプレフィックスコードが1つ以上含まれている場合は、これらのプレフィックスの最初の部分にのみ制御を転送できます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `leave.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル動的メモリ プールから特定のバイト数を割り当て、最初に割り当てたバイトのアドレス (遷移ポインター、<see langword="*" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|ローカルヒープから領域を割り当てます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  割り当てられるバイト数はスタックにプッシュされます。  
  
2.  スタックからポップされたバイト数。サイズに対応するメモリ量は、ローカルヒープから割り当てられます。  
  
3.  割り当てられたメモリの最初のバイトへのポインターがスタックにプッシュされます。  
  
 命令`localloc`は、ローカルの`natural unsigned int`動的メモリプールから (型) バイトを割り当て`size` 、最初に割り当てられたバイト`*`のアドレス (遷移ポインター、型) を返します。 返されるメモリブロックは、メソッドの initialize フラグが`true`の場合にのみ、0に初期化されます。 現在のメソッドがを<xref:System.Reflection.Emit.OpCodes.Ret>実行すると、ローカルメモリプールを再利用できるようになります。  
  
 生成された`stind`アドレスは、命令 ( <xref:System.Reflection.Emit.OpCodes.Stind_I4>など`ldind` ) を使用してそのデータ型を格納し、命令 ( <xref:System.Reflection.Emit.OpCodes.Ldind_I4>など) を使用して読み込むことができるように、配置されます。  
  
 命令`localloc` `filter`は、 `catch` 、、`fault` 、またはブロック内では実行できません。 `finally`  
  
 <xref:System.StackOverflowException>は、要求を処理するためのメモリが不足している場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `localloc`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型のインスタンスへの型指定された参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany`class`|型`class`の型指定された参照をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  データへのポインターがスタックにプッシュされます。  
  
2.  ポインターがポップされ、型の型`class`指定された参照に変換されます。  
  
3.  型指定された参照がスタックにプッシュされます。  
  
 この`mkrefany`命令は、動的に型指定された参照を渡すことをサポートしています。 ポインターの型`&` `*`は、、、または`native int`で、データの有効なアドレスを保持している必要があります。 `Class`は、ポインターによって参照されるデータの型を記述するクラストークンです。 `Mkrefany`型指定された参照をスタックにプッシュし、ポインターと型`class`の不透明な記述子を提供します。  
  
 型指定された参照に対して許可される有効な操作は、パラメーターとして型指定された参照を必要とするメソッドに渡すことだけです。 呼び出し先は、 <xref:System.Reflection.Emit.OpCodes.Refanytype>および<xref:System.Reflection.Emit.OpCodes.Refanyval>命令を使用して、それぞれ型 (クラス) とアドレスを取得できます。  
  
 <xref:System.TypeLoadException>が見つからない`class`場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mkrefany`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を乗算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5A|mul|スタックの2つの値を乗算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`value1`にを`value2`乗算します。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`mul`はを`value1`乗算し、結果をスタックにプッシュします。`value2` 整数演算では、オーバーフロー時に上位ビットが自動的に切り捨てられます。  
  
 オーバーフロー <xref:System.Reflection.Emit.OpCodes.Mul_Ovf>処理を伴う整数固有の乗算演算については、「」を参照してください。  
  
 浮動小数点型の場合は 0 * 無限大 = NaN。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mul`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数を乗算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D8|ovf|オーバーフローチェックを使用して、スタック上の2つの整数値を乗算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`value1`にを`value2`乗算し、オーバーフローチェックを行います。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`mul.ovf`は整数`value1`を整数`value2`で乗算し、結果をスタックにプッシュします。 結果が結果の型に合わない場合は、例外がスローされます。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mul.ovf`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数を乗算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|オーバーフローチェックを使用して、スタック上の2つの符号なしの値を乗算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`value1`にを`value2`乗算し、オーバーフローチェックを行います。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`mul.ovf.un`は、符号なし`value1`整数を符号`value2`なし整数で乗算し、結果をスタックにプッシュします。 結果が結果の型に合わない場合は、例外がスローされます。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mul.ovf.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値を無効にし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|65|neg|スタックの現在の上にある値を否定します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  値はスタックからポップされ、否定されます。  
  
3.  結果がスタックにプッシュされます。  
  
 命令`neg`は、値を否定し、結果をスタックの一番上にプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 整数値の否定は、標準の2の補数否定です。 特に、負の数 (正の値に対応する正の数値) を否定すると、最も負の数値が得られます。 このオーバーフローを検出するに<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>は、代わりに命令を使用します (つまり、0から減算します)。  
  
 浮動小数点数を否定することはできません。また、NaN を否定すると NaN が返されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `neg`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型の要素を持つ、インデックス番号が 0 から始まる新しい 1 次元配列へのオブジェクト参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr`etype`|型`etype`の要素を使用して、新しい配列を作成します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列内の要素の数がスタックにプッシュされます。  
  
2.  要素の数がスタックからポップされ、配列が作成されます。  
  
3.  新しい配列へのオブジェクト参照がスタックにプッシュされます。  
  
 命令`newarr`は、オブジェクト参照 (型`O`) を、要素が型`etype` (型を記述するメタデータトークン) である、新しい0から始まる1次元配列にプッシュします。 新しい配列内の要素の数は、 `native int`として指定する必要があります。 有効な配列のインデックスの範囲は、0から最大で1を引いた数までです。  
  
 配列の要素は、値型を含む任意の型にすることができます。  
  
 0から始まる、数値の1次元配列は、適切な値型 (<xref:System.Int32>など) を参照するメタデータトークンを使用して作成されます。 配列の要素は、適切な型の0に初期化されます。  
  
 0以外のベースの1次元配列と多次元配列は、 <xref:System.Reflection.Emit.OpCodes.Newobj> `newarr`ではなくを使用して作成されます。 一般的には、.NET Framework の<xref:System.Array>クラスのメソッドを使用して作成されます。  
  
 <xref:System.OutOfMemoryException>要求を満たすのに十分なメモリがない場合は、がスローされます。  
  
 <xref:System.OverflowException>が0未満`numElems`の場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `newarr`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいオブジェクトまたは値型の新しいインスタンスを作成し、オブジェクト参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj`ctor`|初期化されていないオブジェクトまたは値型`ctor`を割り当て、コンストラクターメソッドを呼び出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `arg1` から`argn`の引数は、順番にスタックにプッシュされます。  
  
2.  から`argn` `ctor`の引数はスタックからポップされ、オブジェクトの作成のためにに渡されます。 `arg1`  
  
3.  新しいオブジェクトへの参照がスタックにプッシュされます。  
  
 命令`newobj`は、新しいオブジェクトまたは値型の新しいインスタンスを作成します。 `Ctor`は、呼び出すコンストラクターの名前`methodref` 、 `methoddef`クラス、およびシグネチャを示すメタデータトークン (またはコンストラクターとしてマークされる必要がある) です。  
  
 命令`newobj`は、に関連付けられたクラスの`ctor`新しいインスタンスを割り当て、新しいインスタンス内のすべてのフィールドを 0 (適切な型の) または null 参照 (適切な場合) に初期化します。 次に、新しく作成`ctor`されたインスタンスと共に、指定された引数を使用してコンストラクターを呼び出します。 コンストラクターが呼び出されると、現在初期化されているオブジェクト参照`O`(型) がスタックにプッシュされます。  
  
 コンストラクターの観点からは、初期化されていないオブジェクトは引数0であり、newobj に渡される他の引数は順に続きます。  
  
 0から始まるすべての1次元配列は、では<xref:System.Reflection.Emit.OpCodes.Newarr>なく`newobj`、を使用して作成されます。 一方、を使用して`newobj`、他のすべての配列 (複数の次元、または1次元であるが0から始まらない配列) が作成されます。  
  
 値型は、通常はを`newobj`使用して作成されません。 通常、これらは引数またはローカル変数として`newarr` 、(0 から始まる、1次元の配列の場合)、またはオブジェクトのフィールドとして割り当てられます。 割り当てられると、を使用<xref:System.Reflection.Emit.OpCodes.Initobj>して初期化されます。 ただし、 `newobj`命令を使用して、スタック上に値型の新しいインスタンスを作成し、そのインスタンスを引数として渡したり、ローカルに格納したりすることができます。  
  
 <xref:System.OutOfMemoryException>要求を満たすのに十分なメモリがない場合は、がスローされます。  
  
 <xref:System.MissingMethodException>は、指定された`ctor`名前、クラス、およびシグネチャを持つコンストラクターメソッドが見つからない場合にスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `newobj`オペコードを使用できます。  
  
-   ILGenerator (オペコード, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペコードがパッチされている場合は、領域を補完します。 循環参照の処理を利用することはできますが、意味のある演算は行われません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|00|nop|動作を指定せずに操作を実行します。|  
  
 この命令には、スタック移行動作は定義されていません。  
  
 `nop`操作は何も行いません。 これは、オペコードにパッチが適用されている場合に領域を埋めることを目的としています。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `nop`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある整数値のビットごとの補数を計算し、結果を同じ型として評価スタックの一番上にプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|66|not|値のビットごとの補数を計算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value`はスタックにプッシュされます。  
  
2.  `value`スタックからポップされ、ビットごとの補数が計算されます。  
  
3.  結果がスタックにプッシュされます。  
  
 命令`not`は、整数値のビットごとの補数を計算し、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `not`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある 2 つの整数値のビットごとの補数を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|60|or|2つの整数値のビットごとの OR を計算し、整数を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされ、ビットごとの or 演算が計算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`or`は、スタックの一番上にある2つの値のビットごとの or を計算し、結果をスタックにプッシュします。  
  
 `Or`は整数固有の演算です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `or`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|26|pop|スタックから上位の値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  最上位の値がスタックからポップされます。  
  
 命令`pop`は、スタックから最上位の要素を削除します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `pop`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以降の配列アドレス演算で、実行時に型チェックを実行しないこと、および変更可能性が制限されたマネージド ポインターを返すことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1E|readonly.|後続の配列アドレス操作が実行時に型チェックを実行しないことと、制限された可能性が制限されたマネージポインターを返すことを指定します。|  
  
 このプレフィックスは、命令の`ldelema`直前にのみ表示され、配列で特別な`Address`メソッドを呼び出すことができます。 後続の操作に対する影響は次のようになります。  
  
1.  実行時には、型チェック操作は実行されません。 参照型の配列で使用する場合は、通常`ldelema` 、 `stelem`および命令に対して暗黙的な型チェックがあることに注意してください。 値クラスに対して実行時の型チェックが行われること`readonly`はありません。そのため、その場合は no op が使用されます。  
  
2.  検証ツールは、アドレス操作の結果を、相互実行性が制限されたマネージポインターとして扱います。  
  
 ポインターは、値を変換できるかどうかを定義する型によって制御されるので、このポインターは、制限性が制限されていると言います。 パブリックフィールドまたは値を更新するメソッドを公開しない値クラスの場合、ポインターは読み取り専用になります (したがって、プレフィックスの名前)。 特に、プリミティブ型 (system.string など) を表すクラスは、ミューテーターを公開しないため、読み取り専用です。  
  
 この方法で制限されているマネージポインターは、次の方法でのみ使用できます。  
  
-   `ldfld` `object` 、 、、`call`、の各命令のパラメーターとして。`constrained callvirt` `ldflda` `stfld`  
  
-   `ldobj`命令の`ldind`パラメーターとして、またはいずれかの命令に指定します。 `pointer`  
  
-   命令の`source` `cpobj`パラメーターとして指定します。  
  
 `stobj`、 `stind` 、または`mkrefany`操作、またはいずれかの命令を含む、許可されていない他のすべての操作。 `initobj`  
  
 `readonly`プレフィックスの目的は、ジェネリックコードで配列から要素をフェッチするときに型チェックが行われないようにすることです。 たとえば、という式`arr[i].m()`では、配列`arr`の要素型は、メソッド`m`を使用してインターフェイスを持つように制約されたジェネリック型であるため、次の MSIL にコンパイルされる可能性があります。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 プレフィックスが`readonly`ない場合、 `ldelema`命令は、! 0 が参照型である場合に型チェックを実行します。 この型チェックは非効率的ですが、意味が正しくありません。 の`ldelema`型チェックは厳密に一致していますが、これは厳密なものではありません。 配列に型! 0 のサブクラスが保持されている場合、上記のコードは型チェックに失敗します。  
  
 配列要素のアドレスは、要素自体ではなく、値型と参照型の両方で動作する`arr[i]`のハンドルを持つためにフェッチされます。したがって、 `constrained callvirt`命令に渡すことができます。  
  
 一般に、参照型の要素が配列に保持されている場合、実行時チェックをスキップすることは安全ではありません。 安全にするには、このポインターを使用して配列を変更しないようにする必要があります。 検証規則によってこのことが保証されます。 制限付きマネージポインターは、インスタンスメソッド呼び出しのオブジェクトとして渡すことができるため、厳密には値型の読み取り専用ではありませんが、値型にはタイプセーフの問題はありません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `readonly`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれている型トークンを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|型指定された参照に格納されている型トークンをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型参照がスタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップされ、対応する型トークンが取得されます。  
  
3.  型トークンがスタックにプッシュされます。  
  
 型指定された参照には、型トークンとオブジェクトインスタンスへのアドレスが含まれています。  
  
 命令`refanytype`は、型指定された参照に埋め込まれている型トークンを取得します。 型指定<xref:System.Reflection.Emit.OpCodes.Mkrefany>された参照の作成については、「」の手順を参照してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `refanytype`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれているアドレス (<see langword="&amp;" /> 型) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval`type`|型指定された参照に格納されているアドレスをプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値型参照がスタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップされ、対応するアドレスが取得されます。  
  
3.  アドレスはスタックにプッシュされます。  
  
 型指定された参照には、型トークンとオブジェクトインスタンスへのアドレスが含まれています。  
  
 命令`refanyval`は、型指定された参照に埋め込まれているアドレスを取得します。 スタックに指定された型指定された参照に埋め込まれた`type`型は、によって指定`typedef`され`typeref`た型 (またはのいずれか) と一致する必要があります。 関連するコンテンツの指示を参照してください。<xref:System.Reflection.Emit.OpCodes.Mkrefany>  
  
 <xref:System.InvalidCastException>が型参照`type`に格納されている型と同一でない場合 (この場合`type`は、型指定され<xref:System.Reflection.Emit.OpCodes.Mkrefany>た参照を構築した命令に提供されるクラス)、がスローされます。  
  
 <xref:System.TypeLoadException>が見つからない`type`場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `refanyval`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5D|rem|`value1` で`value2`除算した剰余をスタックにプッシュします。|  
  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`がスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`および`value1`はスタックからポップされ、計算の`value1` `div` `value2`残りの部分からポップされます。  
  
4.  結果がスタックにプッシュされます。  
  
 `result` = `value1``rem` 次`value2`の条件を満たす:  
  
 `result` = `value1` - `value2``×` ()、`value1`および: `div` `value2`  
  
 0 = &#124; `result` &#124; < &#124; (`result`) = `div` sign (`value1`)。ここで、は0方向に切り捨てられる除算命令です。 `value2` &#124;  
  
 が`value2` 0 また`value1`は無限大の場合、結果は NaN になります。 が`value2`無限大の場合、結果`value1`はになり`-infinity`ます (に対しては否定されます)。  
  
 が0の<xref:System.DivideByZeroException>場合`value2` 、整数演算がスローされます。  
  
 Intel ベースのプラットフォームでは、(minint <xref:System.OverflowException> `rem` -1) を計算すると、がスローされることに注意してください。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `rem`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|5E|rem.un|符号なし`value1`のを符号`value2`なしで除算した剰余をスタックにプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`および`value1`はスタックからポップされ、計算の`value1` `div` `value2`残りの部分からポップされます。  
  
4.  結果がスタックにプッシュされます。  
  
 `result` = `value1``rem.un` 次`value2`の条件を満たす:  
  
 `result` = `value1` - `value2`x (`value1` `div.un` )、および`value2`:  
  
 0 = `result`  <  。ここ`div.un`で、は符号なし除算命令です。 `value2`  
  
 命令`rem.un`は、 `result`を計算してスタックにプッシュします。 `Rem.un`は、引数を符号なし整数と<xref:System.Reflection.Emit.OpCodes.Rem>して処理し、は符号付き整数として扱います。  
  
 `Rem.un`は、浮動小数点数では指定されていません。  
  
 が0の<xref:System.DivideByZeroException>場合`value2` 、整数演算がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `rem.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドから戻り、呼び出し先の評価スタックから呼び出し元の評価スタックに戻り値 (存在する場合) をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|2A>|ret|はメソッドからを返します。値を返す可能性があります。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  戻り値は、呼び出し先の評価スタックからポップされます。  
  
2.  手順 1. で取得した戻り値は、呼び出し元の評価スタックにプッシュされます。  
  
 呼び出し先の評価スタックに戻り値が存在しない場合、値は返されません (呼び出し先または呼び出し元のメソッドのスタック遷移動作はありません)。  
  
 現在のメソッドの戻り値の型によって、スタックの一番上からフェッチされ、現在のメソッドを呼び出したメソッドのスタックにコピーされる値の型が決まります。 返される値を除き、現在のメソッドの評価スタックは空である必要があります。  
  
 命令`ret`を使用して`try`、、 `filter` `catch`、、または`finally`ブロックから制御を移すことはできません。 `try`または`catch`内から、命令を<xref:System.Reflection.Emit.OpCodes.Leave> `ret` 、外側のすべての例外ブロックの外側にある命令の出力先と共に使用します。 `filter`ブロックと`finally`ブロックは論理的には例外処理の一部であり、コードが埋め込まれているメソッドではないため、正しく生成された Microsoft 中間言語 (MSIL) 命令は、内部からメソッドを返しません。`filter`または`finally`。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ret`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外を再スローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1A|スロー|現在の例外を再スローします|  
  
 この命令には、スタック移行動作は定義されていません。  
  
 命令`rethrow`は、 `catch`ハンドラーの本体内でのみ許可されます。 このハンドラーでキャッチされたのと同じ例外をスローします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `rethrow`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、0 を使用して左にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|62|shl|整数を左にシフトします (0 でシフト)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  シフトされるビットの量がスタックにプッシュされます。  
  
3.  シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ左にシフトされます。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`shl`は、指定されたビット`int64`数`native int`だけ左に値 (型、型、または型`int32`) をシフトします。 ビット数は、型または`int32` `native int`型の値です。 シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。  
  
 `Shl`各シフトの最小位置に0ビットを挿入します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `shl`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、符号を付けて右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|63|shr|整数を右にシフトします (符号でシフトします)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  シフトされるビットの量がスタックにプッシュされます。  
  
3.  シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ右にシフトされます。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`shr.un`は、指定されたビット`int64`数`native int`だけ右に値 (型、型、または型`int32`) をシフトします。 ビット数は、型または`int32` `native int`型の値です。 シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。  
  
 `Shr`各シフトの上位ビットをレプリケートし、の`result`元の値の符号を保持します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `shr`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値を指定したビット数だけ、0 を使用して右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|64|shr|整数を右にシフトします (0 でシフト)。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  シフトされるビットの量がスタックにプッシュされます。  
  
3.  シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ右にシフトされます。  
  
4.  結果がスタックにプッシュされます。  
  
 命令`shr.un`は、指定されたビット`int64`数`native int`だけ右に値 (型、型、または型`int32`) をシフトします。 ビット数は、 `int32` `int64`型または`native int`型の値です。 シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。  
  
 `Shr.un`各シフトの最大位置にゼロビットを挿入します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `shr.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された値型のサイズ (バイト単位) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof`valType`|値型のサイズをとして`unsigned int32`バイト単位でプッシュします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  指定した値の型 (`valType`) のサイズ (バイト単位) がスタックにプッシュされます。  
  
 `valType`は、値型、参照型`typeref` 、 `typedef`またはジェネリック型パラメーターを指定するメタデータトークン (または) である必要があります。  
  
 参照型の場合、返されるサイズは、対応する型の参照値のサイズ (32 ビットシステムでは4バイト) であり、参照値で参照されるオブジェクトに格納されているデータのサイズではありません。 ジェネリック型パラメーターは、それを定義する型またはメソッドの本体でのみ使用できます。 その型またはメソッドがインスタンス化されると、ジェネリック型パラメーターは値型または参照型に置き換えられます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sizeof`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg`num`|スタックから上位の値をポップし、引数スロット`num`に格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  現在スタックの一番上にある値がポップされ、引数スロット`num`に配置されます。  
  
 命令`starg`はスタックから値をポップし、引数スロット`num`に配置します。 値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致している必要があります。  
  
 可変個引数リストを受け取るプロシージャの場合、 `starg`命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 4バイト未満の整数値を保持する引数にストアを実行すると、スタックから引数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `starg`オペコードを使用できます。  
  
-   ILGenerator (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|スタックから最上位の値をポップし、引数スロット`num`(短い形式) に格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  現在スタックの一番上にある値がポップされ、引数スロット`num`に配置されます。  
  
 命令`starg.s`はスタックから値をポップし、引数スロット`num`に配置します。 値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致している必要があります。  
  
 命令`starg.s`は、最初の256引数で使用するための効率的なエンコーディングを提供します。  
  
 可変個引数リストを受け取るプロシージャの場合、 `starg.s`命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。  
  
 4バイト未満の整数値を保持する引数にストアを実行すると、スタックから引数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `starg.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード、byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの、命令で指定された型の値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem`typeTok`|指定したインデックス位置にある配列要素を、スタック上`typeTok`の型の値に置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`index` `array`要素へのインデックス値がスタックにプッシュされます。  
  
3.  命令で指定された型の値がスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem`は、1次元配列`array`内の指定された0から始まるインデックス位置にある要素の値を、値で置き換えます。 この値には、命令のトークン`typeTok`によって指定された型があります。  
  
 配列はオブジェクトであり、したがって型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="native int" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9B|stelem.i|指定したインデックス位置にある配列要素を`native int`スタックの値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.i`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`native int`された値に置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int8" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|指定したインデックス位置にある配列要素を`int8`スタックの値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.i1`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int8`された値に置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int16" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|指定したインデックス位置にある配列要素を`int16`スタックの値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.i2`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int16`された値に置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int32" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|指定したインデックス位置にある配列要素を`int32`スタックの値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.i4`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int32`された値に置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int64" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|指定したインデックス位置にある配列要素を`int64`スタックの値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.i8`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int64`された値に置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="float32" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|指定したインデックス位置にある配列要素を`float32`スタックの値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.r4`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`float32`された値に置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.r4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="float64" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|指定したインデックス位置にある配列要素を`float64`スタックの値で置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.r8`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`float64`された値に置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.r8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素をオブジェクト参照値 (<see langword="O" /> 型) に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|指定したインデックス位置にある配列要素を`ref`スタックの値`O`(型) に置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  配列`array`へのオブジェクト参照がスタックにプッシュされます。  
  
2.  内の`array`要素への有効なインデックスがスタックにプッシュされます。  
  
3.  値はスタックにプッシュされます。  
  
4.  値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。  
  
 命令`stelem.ref`は、1次元配列`array`内の指定されたインデックス位置にある要素の値を`ref` 、スタック`O`にプッシュされた (型) 値で置き換えます。  
  
 配列はオブジェクトであるため、型`O`の値によって表されます。 インデックスは type `native int`です。  
  
 は、 `stelem.ref`配列要素に値を代入する前に、 `array`指定された値をの要素型に暗黙的にキャストすることに注意してください。 検証されたコードの場合でも、このキャストは失敗する可能性があります。 したがって`stelem.ref` 、命令に<xref:System.InvalidCastException>よってスローされる可能性があります。 0から始まらない1次元配列、および多次元配列の場合、クラスに<xref:System.Array>はメソッドが<xref:System.Array.SetValue%2A>用意されています。  
  
 <xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。  
  
 <xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。  
  
 <xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.ref`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照またはポインターのフィールドに格納された値を新しい値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld`field`|オブジェクトのの`field`値を新しい値に置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照またはポインターがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とオブジェクト参照/ポインターがスタックからポップされます。オブジェクトのの`field`値は、指定された値に置き換えられます。  
  
 命令`stfld`は、オブジェクト (型`O`) のフィールドの値、またはポインター (型`native int`、 `&`、または`*`) を使用して、指定された値に置き換えます。 `Field`は、フィールドメンバー参照を参照するメタデータトークンです。 命令`stfld`は、 <xref:System.Reflection.Emit.OpCodes.Unaligned> と<xref:System.Reflection.Emit.OpCodes.Volatile>のいずれかまたは両方のプレフィックスを持つことができます。  
  
 <xref:System.NullReferenceException>オブジェクト参照またはポインターが null 参照で、フィールドが静的でない場合に、がスローされます。  
  
 <xref:System.MissingFieldException>メタデータに`field`が見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換される場合にチェックされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stfld`オペコードを使用できます。  
  
-   ILGenerator (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="native int" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DF|stind|指定さ`native int`れたアドレスに値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.i`は、指定`native int`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。  
  
 タイプセーフ操作では、 `stind.i`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.i`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int8" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|52|stind.i1|指定さ`int8`れたアドレスに値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.i1`は、指定`int8`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。  
  
 タイプセーフ操作では、 `stind.i1`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.i1`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int16" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|53|stind.i2|指定さ`int16`れたアドレスに値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.i2`は、指定`int16`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。  
  
 タイプセーフ操作では、 `stind.2i`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.i2`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int32" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|54|stind.i4|指定さ`int32`れたアドレスに値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.i4`は、指定`int32`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。  
  
 タイプセーフ操作では、 `stind.i4`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.i4`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int64" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|55|stind.i8|指定さ`int64`れたアドレスに値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.i8`は、指定`int64`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。  
  
 タイプセーフ操作では、 `stind.i8`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.i`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="float32" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|56|stind.r4|指定さ`float32`れたアドレスに値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.r4`は、指定`float32`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。  
  
 タイプセーフ操作では、 `stind.r4`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.r4`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.r4`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="float64" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|57|stind.r8|指定さ`float64`れたアドレスに値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.r8`は、指定`float64`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。  
  
 タイプセーフ操作では、 `stind.r8`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.r8`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.r8`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスにオブジェクト参照値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|51|stind.ref|指定されたアドレスに`O`オブジェクト参照 (型) の値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値はスタックにプッシュされます。  
  
3.  値とアドレスはスタックからポップされます。値はアドレスに格納されます。  
  
 命令`stind.ref`は、指定されたアドレス (型`*`、型、 `native int`または`&`型) にオブジェクト参照値を格納します。  
  
 タイプセーフ操作では、 `stind.ref`ポインターの型と一貫性のある方法で命令を使用する必要があります。 `stind.ref`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.ref`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、指定したインデックスのローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc`index`|スタックから値をポップし、ローカル変数`index`に格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、ローカル変数`index`に配置されます。  
  
 この`stloc`命令は、トップの値を評価スタックからポップし、ローカル変数の`index`数値に移動します。ローカル変数には、0以降の番号が付けられます。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 Microsoft 中間言語 (MSIL) 命令を修正する`index`には、有効なローカルインデックスである必要があります。 命令の場合、 `index`は 0 ~ 65534 の範囲で指定する必要があります (具体的には65535は無効です)。 `stloc` 65535を除外する理由は実用的であると考えられます。実装では、2バイトの整数を使用して、ローカルのインデックスと、特定のメソッドのローカルの合計数を追跡します。 65535のインデックスが有効になっている場合は、このようなメソッドでローカルの数を追跡するために、より広い整数が必要になります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc`オペコードを使用できます。  
  
-   ILGenerator (オペコード、LocalBuilder)  
  
-   ILGenerator (オペコード、short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 0 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0A|stloc|スタックからローカル変数0に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、0によってインデックスが作成されたローカル変数に配置されます。  
  
 この`stloc.0`命令は、トップ値を評価スタックからポップし、0によってインデックスが作成されたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.0`は、ローカル変数0に値を格納するための、特に効率的なエンコードです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.0`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 1 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0B|stloc|スタックからローカル変数1に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、1によってインデックスが作成されたローカル変数に配置されます。  
  
 この`stloc.1`命令は、トップ値を評価スタックからポップし、1でインデックス付けされたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.1`は、ローカル変数1に値を格納するための、特に効率的なエンコーディングです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.1`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 2 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0C|stloc|スタックからローカル変数2に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、2によってインデックスが作成されたローカル変数に格納されます。  
  
 この`stloc.2`命令は、トップ値を評価スタックからポップし、2によってインデックスが作成されたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.2`は、ローカル変数2に値を格納するための、特に効率的なエンコーディングです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.2`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 3 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|0D|stloc|スタックからローカル変数3に値をポップします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、3によってインデックスが作成されたローカル変数に格納されます。  
  
 この`stloc.3`命令は、トップ値を評価スタックからポップし、3によってインデックスが作成されたローカル変数に移動します。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 `stloc.3`は、ローカル変数3に値を格納するための、特に効率的なエンコードです。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.3`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、<paramref name="index" /> のローカル変数リストに格納します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|スタックから値をポップし、ローカル変数`index`である短い形式で格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックからポップされ、ローカル変数`index`に配置されます。  
  
 この`stloc.s`命令は、トップの値を評価スタックからポップし、ローカル変数の`index`数値に移動します。ローカル変数には、0以降の番号が付けられます。 値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。  
  
 命令`stloc.s`は、ローカル変数 0 ~ 255 の効率的なエンコードを提供します。  
  
 4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。 浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.s`オペコードを使用できます。  
  
-   ILGenerator (オペコード、LocalBuilder)  
  
-   ILGenerator (オペコード、byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックから提供されたメモリ アドレスに、指定した型の値をコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|スタックからメモリに型`class`の値を格納します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  型`class`の値型のオブジェクトがスタックにプッシュされます。  
  
3.  オブジェクトとアドレスがスタックからポップされます。値型のオブジェクトはアドレスに格納されます。  
  
 命令`stobj`は、アドレス (型`*`、型、または`&`型`native int`のポインター) によって指定されたアドレスに、値型オブジェクトをコピーします。 コピーされるバイト数は、によって表されるクラスの`class`サイズによって異なります。これは、値型を表すメタデータトークンです。  
  
 `stobj`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。  
  
 <xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stobj`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックの値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld`field`|の`field`値を指定された値に置き換えます。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  値はスタックからポップされ、に`field`格納されます。  
  
 命令`stsfld`は、静的フィールドの値をスタックの値に置き換えます。 `field`は、静的フィールドメンバーを参照する必要があるメタデータトークンです。  
  
 命令`stsfld`の先頭にを<xref:System.Reflection.Emit.OpCodes.Volatile>付けることができます。  
  
 <xref:System.MissingFieldException>メタデータ内にフィールドが見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stsfld`オペコードを使用できます。  
  
-   ILGenerator (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある値から別の値を減算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|59|sub|ある値を別の値から減算し、新しい数値を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。`value2`はから`value1`減算されます。  
  
4.  結果がスタックにプッシュされます。  
  
 整数演算のオーバーフローは検出されません (適切なオーバーフロー <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>処理の場合は、「」を参照してください)。  
  
 整数の減算は、によって飽和するのではなく、ラップします。 たとえば、 `value1`が0に設定され、が1に設定され`value2`ている場合は、8ビット整数と想定します。 "ラップされた" 結果は255になります。  
  
 浮動小数点オーバーフローは`+inf` 、`PositiveInfinity`() `-inf`また`NegativeInfinity`は () を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sub`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある整数値を別の整数値から減算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|オーディオ|ovf|オーバーフローチェックを使用して、ある整数値を別の整数値から減算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。は、オーバーフロー `value1`のチェックを使用してから減算されます。 `value2`  
  
4.  結果がスタックにプッシュされます。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 この操作は、符号付き整数に対して実行されます。浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Sub>、を使用します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sub.ovf`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある符号なし整数値を別の符号なし整数値から減算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|オーバーフローチェックを使用して、1つの符号なし整数値を別の符号なし整数値から減算します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされます。は、オーバーフロー `value1`のチェックを使用してから減算されます。 `value2`  
  
4.  結果がスタックにプッシュされます。  
  
 <xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。  
  
 この操作は、符号付き整数に対して実行されます。浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Sub>、を使用します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sub.ovf.un`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャンプ テーブルを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|スイッチ (`N`、 `t1`、 `t2`...`tN`)|値の`N`いずれかにジャンプします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  値はスタックにプッシュされます。  
  
2.  値はスタックからポップされ、値によってインデックス付けされたオフセットの命令に実行が転送されます。 `N`このとき、値はより小さくなります。  
  
 この`switch`命令は、ジャンプテーブルを実装します。 命令の形式は、ターゲット`unsigned int32` `N`の数を表すであり、その後`N`にジャンプターゲットを指定する int32 値が続きます。 これらのターゲットは、この`switch`命令に続く命令の先頭からのオフセット (正または負) として表されます。  
  
 命令`switch`は、値をスタックからポップし、符号なし整数としてに`N`比較します。 値が未満`N`の場合、実行は値でインデックス付けされたターゲットに転送されます。この場合、ターゲットは0から番号が付けられます (たとえば、0の値は最初のターゲットを、1は2番目のターゲットを受け取ります)。 値が以上の場合`N`、次の命令 (フォールスルー) で実行が続行されます。  
  
 ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。  
  
 `try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter` (このような転送は厳しく制限されており、代わりに leave 命令を使用する必要があります)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `switch`オペコードを使用できます。 引数`Label[]`は、32ビットオフセットを表すラベルの配列です。  
  
-   ILGenerator (オペコード, Label [])  
  
   
  
## Examples  
 次のコードサンプルは、の`Switch` <xref:System.Reflection.Emit.Label>配列を使用して、オペコードを使用してジャンプテーブルを生成する方法を示しています。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際の呼び出し命令が実行される前に、現在のメソッドのスタック フレームが削除されるように、後置のメソッド呼び出し命令を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 14|テイ.|後続の呼び出しは、現在のメソッドを終了します|  
  
 この命令には、スタック移行動作は定義されていません。  
  
 プレフィックス命令は<xref:System.Reflection.Emit.OpCodes.Call> <xref:System.Reflection.Emit.OpCodes.Callvirt> 、 <xref:System.Reflection.Emit.OpCodes.Calli>、、または命令の直前に配置する必要があります。 `tail` これは、呼び出し命令が実行される前に、現在のメソッドのスタックフレームを削除する必要があることを示します。 また、次の呼び出しから返される値も、現在のメソッドによって返される値であることを意味します。この呼び出しは、メソッド間のジャンプに変換できます。  
  
 スタックは、次の呼び出しによって転送される引数を除いて、空である必要があります。 呼び出し命令の後の命令は、ret である必要があります。したがって、有効なコードシーケンス`tail. call`は ( `calli`また`callvirt`は) だけです。 正しい MSIL (Microsoft 中間言語) 命令を`call`命令に分岐することはできませんが、後続<xref:System.Reflection.Emit.OpCodes.Ret>のに分岐する場合があります。  
  
 コード id のセキュリティが損なわれる可能性があるため、信頼されていないコードから信頼されるコードに制御が転送されるときに、現在のフレームを破棄することはできません。 このため、.NET Framework セキュリティチェックによっ`tail`てが無視され、標準<xref:System.Reflection.Emit.OpCodes.Call>の命令が残されます。 同様に、呼び出しから制御が戻っ`tail`た後に同期された領域の終了が発生するようにするために、同期済みとマークされたメソッドを終了するために使用した場合、プレフィックスは無視されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `tail`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Opcode オブジェクトのインスタンス。</param>
        <summary>提供されたオペコードが 1 バイト引数をとる場合は、true または false を返します。</summary>
        <returns><see langword="true" /> または <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、最適化されたコードで使用される "短い形式" の MSIL オペコードを見つけることができます。  
  
 `TakesSingleByteArgument`インスタンス`true`が次<xref:System.Reflection.Emit.OpCode>の場合に1バイトの引数を受け取る場合は、を返します。  
  
-   オペコードは、バイトサイズのアドレス (たとえば、 <xref:System.Reflection.Emit.OpCodes.Br_S>や<xref:System.Reflection.Emit.OpCodes.Bgt_S>) に対する分岐命令を実行します。  
  
-   オペコードは、バイト値をスタックにプッシュします (たとえば<xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>、)。  
  
-   オペコードは、バイトサイズの "短い形式" (や<xref:System.Reflection.Emit.OpCodes.Ldloc_S> <xref:System.Reflection.Emit.OpCodes.Stloc_S>など) を使用して、変数または引数を参照します。  
  
 それ以外の場合は、 `false`を返します。  
  
 次の例では、を`TakesSingleByteArgument` `OpCodes`クラスに反映することによってを使用し、 `OpCode`各フィールドが1バイトの引数を受け取るかどうかをテストしています。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックにある例外オブジェクトをスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|7A|throw|例外をスローします。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  (例外への) オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、例外がスローされます。  
  
 命令`throw`は、現在スタックにある例外`O`オブジェクト (型) をスローします。  
  
 <xref:System.NullReferenceException>オブジェクト参照が null 参照の場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `throw`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが、直後の <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> または <see langword="cpblk" /> の各命令の通常サイズに合わせて配置されていない可能性があることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|揃え. `alignment`|後続のポインター命令が整列していない可能性があることを示します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
 `Unaligned`スタック上のアドレス`native int`(アンマネージポインター) が、の`ldind`直後`stobj` `stind` `ldfld` `stfld` `ldobj`のの自然サイズにアラインされていない可能性があることを指定します。、、 `cpblk`または命令。 `initblk` つまり、 <xref:System.Reflection.Emit.OpCodes.Ldind_I4>命令の場合、アドレスのアラインメントを4バイト境界にすることはできません。 `initblk` と`cpblk`では、既定のアラインメントはアーキテクチャに依存します (32 ビット cpu では4バイト、64ビット cpu では8バイト)。 コンパイル時に8バイトになるように配置が認識されない場合、 `unaligned`出力を32ビットワードサイズに制限しないコードジェネレーターでは、を使用する必要があります。  
  
 アラインメントの値は1、2、または4である必要があります。生成されたコードでは、アドレスがバイト、2バイト、または4バイトでアラインされていると想定する必要があります。 一時的なポインター (型`*`) は常にアラインされることに注意してください。  
  
 `cpblk`命令の配置では、論理的に2つの数値が必要になりますが (1 つはソース用、もう1つは変換先に対して)、低い数値のみが指定されている場合、パフォーマンスに大きな影響はありません。  
  
 プレフィックス`unaligned` と`volatile`プレフィックスは、どちらの順序でも組み合わせることができます。 これら`ldind`は、`stobj` 、、`cpblk` 、、、、 、または命令の直前に配置する必要があります。`initblk` `stind` `ldfld` `stfld` `ldobj` との手順ではプレフィックスのみを使用できます。 <xref:System.Reflection.Emit.OpCodes.Volatile> <xref:System.Reflection.Emit.OpCodes.Ldsfld> <xref:System.Reflection.Emit.OpCodes.Stsfld>  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `unaligned`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Label)  
  
-   ILGenerator (オペコード、Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型のボックス化変換された形式をボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|79 < `T` >|アン`valType`|ボックス化された表現`obj`から値型データを抽出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照がスタックにプッシュされます。  
  
2.  オブジェクト参照はスタックからポップされ、ボックス化が解除されて値型のポインターになります。  
  
3.  値型のポインターがスタックにプッシュされます。  
  
 値型には、共通言語基盤 (CLI) 内の2つの異なる表現があります。  
  
-   値型が別のオブジェクトに埋め込まれている場合に使用される ' 未加工 ' フォーム。  
  
-   ' ボックス化された ' フォーム。値型のデータは、独立したエンティティとして存在できるように、オブジェクトにラップ (ボックス化) されます。  
  
 命令`unbox`は、オブジェクト参照 (型`O`)、値型のボックス化された表現を、値型のポインター (マネージポインター、型`&`)、およびボックス化解除された形式に変換します。 指定された値`valType`型 () は、ボックス化されたオブジェクト内に含まれる値型の型を示すメタデータトークンです。  
  
 オブジェクト<xref:System.Reflection.Emit.OpCodes.Box>で使用するために値型のコピーを作成するために必要なとは`unbox`異なり、では、オブジェクトから値型をコピーする必要はありません。 通常は、ボックス化されたオブジェクト内に既に存在する値の型のアドレスを計算するだけです。  
  
 <xref:System.InvalidCastException>オブジェクトがとして`valType`ボックス化されていない場合は、がスローされます。  
  
 <xref:System.NullReferenceException>オブジェクト参照が null 参照の場合は、がスローされます。  
  
 <xref:System.TypeLoadException>値の型`valType`が見つからない場合は、がスローされます。 これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `unbox`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>命令で指定された型のボックス化変換された形式を、ボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|A5 < `T` >|ボックス解除。任意`typeTok`|ボックス化され`obj`た表現からデータを抽出します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  オブジェクト参照`obj`がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、その命令で指定された型にボックス化解除されます。  
  
3.  結果として得られるオブジェクト参照または値型がスタックにプッシュされます。  
  
 値型のボックス化された形式に適用さ`unbox.any`れる場合、命令は`obj` (型`O`の) に含まれる値を抽出する`unbox`ため、 `ldobj`の後に続くと同じ結果になります。  
  
 参照型`unbox.any`に適用された場合、命令はと`castclass` `typeTok`同じ効果を持ちます。  
  
 オペランド`typeTok`がジェネリック型パラメーターの場合、ランタイムの動作は、そのジェネリック型パラメーターに対して指定されている型によって決まります。  
  
 <xref:System.InvalidCastException>がボックス化`obj`された型でない場合は、がスローされます。  
  
 <xref:System.NullReferenceException>が null 参照`obj`の場合は、がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `unbox.any`オペコードを使用できます。  
  
-   ILGenerator (オペコード, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが揮発性である可能性があるため、この位置の読み取り結果をキャッシュできないこと、またはこの位置への複数の格納を中止できないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|FE 13|やすい.|後続のポインター参照が volatile であることを示します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  アドレスがスタックにプッシュされます。  
  
 `volatile`。 アドレスが volatile アドレスである (つまり、現在実行されているスレッドの外部で参照できる) ことを指定します。また、その場所の読み取り結果をキャッシュできないか、またはその場所への複数のストアを抑制できないことを示します。 アクセスをとし`volatile`てマークすると、その単一のアクセスのみに影響します。同じ場所への他のアクセスは、個別にマークする必要があります。 揮発性の場所へのアクセスは、アトミックに実行する必要はありません。  
  
 プレフィックス<xref:System.Reflection.Emit.OpCodes.Unaligned> と`volatile`プレフィックスは、どちらの順序でも組み合わせることができます。 これら`ldind`は、`stobj` 、、`cpblk` 、、、、 、または命令の直前に配置する必要があります。`initblk` `stind` `ldfld` `stfld` `ldobj` との手順ではプレフィックスのみを使用できます。 `volatile` <xref:System.Reflection.Emit.OpCodes.Ldsfld> <xref:System.Reflection.Emit.OpCodes.Stsfld>  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `volatile`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある 2 つの値のビットごとの XOR を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。  
  
|形式|アセンブリ形式|説明|  
|------------|---------------------|-----------------|  
|61|xor|2つの整数値のビットごとの XOR を計算し、整数を返します。|  
  
 スタックの移行動作は、次の順序で実行されます。  
  
1.  `value1`はスタックにプッシュされます。  
  
2.  `value2`はスタックにプッシュされます。  
  
3.  `value2`と`value1`はスタックからポップされ、ビットごとの XOR が計算されます。  
  
4.  `value2` と`value1`のビットごとの XOR がスタックにプッシュされます。  
  
 命令`xor`は、スタックの上位2つの値のビットごとの XOR を計算し、結果をスタックに残します。  
  
 `Xor`は整数固有の演算です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `xor`オペコードを使用できます。  
  
-   ILGenerator (オペコード)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
