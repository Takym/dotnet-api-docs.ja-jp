<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7997fce117ccc7ae23044ec686939cb810bed93e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69389123" /></Metadata><TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IParserAccessor&#xA;    interface IUrlResolutionService&#xA;    interface IDataBindingsAccessor&#xA;    interface IControlBuilderAccessor&#xA;    interface IControlDesignerAccessor&#xA;    interface IExpressionsAccessor" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>すべての ASP.NET サーバー コントロールによって共有されるプロパティ、メソッド、およびイベントを定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、カスタム ASP.NET サーバーコントロールを開発するときにから派生するプライマリクラスです。 <xref:System.Web.UI.Control>には、ユーザーインターフェイス (UI) 固有の機能はありません。 UI を持たないコントロールを作成する場合、または独自の UI をレンダリングする他のコントロールを組み合わせる場合は<xref:System.Web.UI.Control>、から派生します。 UI を持つコントロールを作成する場合は、、またはカスタム<xref:System.Web.UI.WebControls.WebControl>コントロールの適切な開始<xref:System.Web.UI.WebControls>点を提供する名前空間内の任意のコントロールから派生します。  
  
 <xref:System.Web.UI.Control>クラスは、カスタムコントロール、ユーザーコントロール、ページなど、すべての ASP.NET サーバーコントロールの基本クラスです。 ASP.NET pages はクラスの<xref:System.Web.UI.Page>インスタンスであり、クラス<xref:System.Web.UI.Control>から継承され、.aspx 拡張子を持つファイルの要求を処理します。  
  
 クラス<xref:System.Web.UI.Control>は、Web アプリケーションのユーザーインターフェイスの一部として直接または間接的に使用できます。そのため、セキュリティで保護されたコードを記述し、アプリケーションを保護するためのベストプラクティスを確認するために、このクラスを調査する必要があります。  
  
 これらのトピックに関する一般的な情報については、「 [Web アプリケーションのセキュリティの脅威の概要](https://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a)」、 [NIB:セキュリティポリシーのベスト](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05)プラクティスと[セキュリティの基本概念](~/docs/standard/security/key-security-concepts.md)について解説します。 詳細については、「[標準コントロールのセキュリティ保護](https://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8)」を[参照してください。安全なエラーメッセージ](https://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa)を[表示する、方法:HTML エンコーディングを文字列](https://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b)に適用し、[検証コントロールの概要](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.0/2e4hd649(v=vs.85))を説明することで、Web アプリケーションのスクリプト攻略を防止します。  
  
   
  
## Examples  
 <xref:System.Web.UI.Control>クラスから派生するカスタムサーバーコントロールの例を次に示します。 クラス`InnerContent`は<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドをオーバーライドし、クラスにページ上の子コントロールがあるかどうかを確認し、コントロールの最初の子がリテラルコントロールであるかどうかを確認します。 これら両方の条件が満たされた場合、オーバーライドされたメソッド\<は、メッセージ > HTML 文字列 H2 を書き込みます。これは、リテラルコントロール\<の内容と、/H2 > 終了タグを Web フォームページに書き込みます。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
    <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">カスタム ASP.NET サーバーコントロールの開発</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Adapter : System.Web.UI.Adapters.ControlAdapter" Usage="System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール用のブラウザー固有のアダプターを取得します。</summary>
        <value>このコントロールの <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。 対象のブラウザーでアダプターが不要な場合は <see langword="null" /> が返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web ページは、Web から情報を要求できる幅広いデバイスとブラウザーで使用できます。 プロパティ<xref:System.Web.UI.Control.Adapter%2A>は、要求<xref:System.Web.UI.Adapters.ControlAdapter>元のデバイスまたはブラウザーの画面でコントロールをレンダリングするオブジェクトを返します。  
  
 アダプターの詳細については、「[アダプティブコントロールの動作のアーキテクチャの概要](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">アダプティブコントロールの動作のアーキテクチャの概要</related>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberSignature Language="F#" Value="abstract member AddedControl : System.Web.UI.Control * int -&gt; unit&#xA;override this.AddedControl : System.Web.UI.Control * int -&gt; unit" Usage="control.AddedControl (control, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">追加された <see cref="T:System.Web.UI.Control" />。</param>
        <param name="index">このコントロールの <see cref="P:System.Web.UI.Control.Controls" /> コレクション内でのインデックス。</param>
        <summary>子コントロールが <see cref="T:System.Web.UI.Control" /> オブジェクトの <see cref="P:System.Web.UI.Control.Controls" /> コレクションに追加された後に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、コントロールが<xref:System.Web.UI.Control.Controls%2A>コレクションに追加された直後に呼び出されます。 <xref:System.Web.UI.Control.AddedControl%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" /> が <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member AddParsedSubObject : obj -&gt; unit&#xA;override this.AddParsedSubObject : obj -&gt; unit" Usage="control.AddParsedSubObject obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">解析された要素を表す <see cref="T:System.Object" />。</param>
        <summary>XML または HTML のいずれかの要素が解析されたことをサーバー コントロールに通知し、サーバー コントロールの <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトに要素を追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライドしない限り、このメソッドはオブジェクト<xref:System.Web.UI.LiteralControl>をサーバーコントロールの<xref:System.Web.UI.ControlCollection>オブジェクトに自動的に追加します。 このコレクションには、 <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>プロパティを使用してアクセスできます。  
  
   
  
## Examples  
 次の例は、 <xref:System.Web.UI.Control.AddParsedSubObject%2A>メソッドを使用して、このコントロールの開始タグと終了タグの間で宣言された要素が<xref:System.Web.UI.WebControls.TextBox> Web サーバーコントロールであるかどうかを判断するカスタムサーバーコントロールです。 存在する場合は、 <xref:System.Collections.ArrayList> `items`オブジェクトに追加されます。 オーバーライド<xref:System.Web.UI.Control.CreateChildControls%2A>されたメソッドが呼び出されると、を<xref:System.Collections.ArrayList>反復処理し、その中の各<xref:System.Web.UI.ControlCollection>オブジェクトをカスタムサーバーコントロールのに追加します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="abstract member ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit&#xA;override this.ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit" Usage="control.ApplyStyleSheetSkin page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">コントロールを格納している <see cref="T:System.Web.UI.Page" />。</param>
        <summary>ページのスタイル シートに定義されたスタイル プロパティをコントロールに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>は、テーマディレクトリに定義されているスキンプロパティに基づいて、コントロールのスタイルプロパティを設定します。 適用されるスキンは、コントロールの既定のスキン、または<xref:System.Web.UI.Control.SkinID%2A>プロパティで指定されているスキンのいずれかです。 メソッド<xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>は、ページに配置された宣言型コントロールに対して ASP.NET によって呼び出されます。 スタイルシートスキンを<xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>コントロールに適用するには、実行時にプログラムによって作成されたコントロールに対してメソッドを呼び出す必要があります。 テーマスキンは自動的に適用されます。 テーマとカスケードスタイルシートの違いの詳細については、「 [ASP.NET theme And スキン](https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートが既に適用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeTemplateSourceDirectory : string with get, set" Usage="System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールが含まれている <see cref="T:System.Web.UI.Page" /> オブジェクトまたは <see cref="T:System.Web.UI.UserControl" /> オブジェクトのアプリケーション相対の仮想ディレクトリを取得または設定します。</summary>
        <value>このコントロールを格納しているページまたはユーザー コントロールのアプリケーション相対の仮想ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>は、現在のコントロールを格納しているページまたはユーザーコントロールへのアプリケーション相対パスを格納します。 たとえば、Web ページがに`http://www.contoso.com/application/subdirectory`存在する場合、プロパティは<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> "~/サブディレクトリ" を返します。  
  
 仮想パス ("application/サブディレクトリ") を取得するには<xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 、プロパティを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.BeginRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.BeginRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">トレース データを書き込むオブジェクト。</param>
        <param name="traceObject">トレース オブジェクト。</param>
        <summary>レンダリング データのデザイン時のトレースを開始します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのデータ バインディングを格納しているコントロールを取得します。</summary>
        <value>このコントロールのデータ バインディングを格納している <see cref="T:System.Web.UI.Control" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.Control.BindingContainer%2A>は、現在のコントロールの<xref:System.Web.UI.Control>データバインディング情報を格納しているオブジェクトへの参照を格納します。  
  
 コントロールがテンプレートの一部である<xref:System.Web.UI.Control.NamingContainer%2A>場合を除き、プロパティはプロパティと同じです。<xref:System.Web.UI.Control.BindingContainer%2A> その場合、 <xref:System.Web.UI.Control.BindingContainer%2A>プロパティは、 <xref:System.Web.UI.Control>テンプレートを定義するに設定されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberSignature Language="F#" Value="member this.BuildProfileTree : string * bool -&gt; unit" Usage="control.BuildProfileTree (parentId, calcViewState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">コントロールの親の識別子。</param>
        <param name="calcViewState">ビューステートのサイズを計算するかどうかを示すブール値。</param>
        <summary>ページのトレースが有効な場合、サーバー コントロールに関する情報を収集し、これを表示するために <see cref="P:System.Web.UI.Page.Trace" /> プロパティに渡します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、ページの UI 階層に関する必要な情報を収集し、ページの[ &lt;トレース&gt; ](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md)プロパティに渡します。 ページまたはアプリケーションのトレースを有効にすると、トレース出力の`Control Tree`セクションにこの情報が表示されます。 ページのトレース出力がページの最後に追加されます。アプリケーションのトレース出力は、アプリケーションのルートディレクトリに格納されているトレースビューアー (trace.axd ファイル) から表示できます。 トレースの詳細については、「 [ASP.NET tracing の概要](https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChildControlsCreated : bool with get, set" Usage="System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの子コントロールが作成されたかどうかを示す値を取得します。</summary>
        <value>子コントロールが作成された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、カスタム<xref:System.Web.UI.Control.OnDataBinding%2A> <xref:System.Web.UI.WebControls.Repeater>コントロールのメソッドをオーバーライドする方法を示しています。 データバインディング<xref:System.Web.UI.Control.ChildControlsCreated%2A>が再び行われるまで子コントロールが作成されないようにするには、 <xref:System.Web.UI.WebControls.RepeaterItem>オブジェクトが作成され、コントロールの<xref:System.Web.UI.ControlCollection>オブジェクトに追加された後に、プロパティがに`true`設定されます。  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 次の例は、Web ページでカスタム repeater コントロールを使用する方法を示しています。  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberSignature Language="F#" Value="member this.ClearCachedClientID : unit -&gt; unit" Usage="control.ClearCachedClientID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キャッシュされた <see cref="P:System.Web.UI.Control.ClientID" /> 値を <see langword="null" /> に設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildControlState : unit -&gt; unit" Usage="control.ClearChildControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールについて、コントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドは、親コントロールのコントロール状態に書き込まれた子コントロール状態情報が、新しい子コントロールが作成されるときに使用されます。たとえば、テンプレート化されたデータバインドサーバーコントロールでのデータバインディング子コントロールの場合などです。 メソッドを<xref:System.Web.UI.Control.ClearChildControlState%2A>呼び出す前<xref:System.Web.UI.Control.SaveControlState%2A>に空の子コントロールに対してメソッドを呼び出すと、格納または転送する必要があるコントロール状態情報のサイズが縮小されます。  
  
 <xref:System.Web.UI.Control>オブジェクトの子コントロールを再作成する場合は<xref:System.Web.UI.Control.ClearChildControlState%2A> 、メソッドを使用して子コントロールの状態をクリアし、意図せずに新しいコントロールに適用されないようにします。  
  
 子コントロールの状態とビューステートの両方をクリアするに<xref:System.Web.UI.Control.ClearChildState%2A>は、メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildState : unit -&gt; unit" Usage="control.ClearChildState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールのビューステート情報およびコントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.Control.ClearChildState%2A>は、子コントロールのすべてのビューステート情報とコントロール状態情報をクリアします。 これは、 <xref:System.Web.UI.Control.ClearChildViewState%2A>メソッド<xref:System.Web.UI.Control.ClearChildControlState%2A>とメソッドの両方を呼び出すことと同じです。  
  
 <xref:System.Web.UI.Control>オブジェクトの子コントロールを再作成する場合は<xref:System.Web.UI.Control.ClearChildState%2A> 、メソッドを使用して、新しいコントロールに誤って適用されないように、子の状態をクリアします。  
  
   
  
## Examples  
 次のコード例は、テンプレート化さ<xref:System.Web.UI.Control.OnDataBinding%2A>れたデータバインドコントロールのメソッドをオーバーライドする方法を示しています。 コントロールをバインドするデータソースが設定されている場合は、 <xref:System.Web.UI.ControlCollection> <xref:System.Web.UI.ControlCollection.Clear%2A>メソッド<xref:System.Web.UI.Control.ClearChildState%2A>を使用してコントロールのコレクションが空になり、メソッドを使用して、子コントロールに保存されていたすべての状態情報が削除されます。  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildViewState : unit -&gt; unit" Usage="control.ClearChildViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールのビューステート情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、通常、テンプレート化さ<xref:System.Web.UI.Control.DataBind%2A>れたデータバインドサーバーコントロールを開発するときにメソッドをオーバーライドする場合に使用します。 このメソッドを呼び出さないと、子コントロールのビューステート情報を親サーバーコントロールに書き込むことができ、データがバインドされている場合にのみオーバーライドされます。  
  
 の<xref:System.Web.UI.Control>子コントロールを再作成する場合は<xref:System.Web.UI.Control.ClearChildViewState%2A> 、メソッドを使用して、新しいコントロールに誤って適用されないように、子ビューステートをクリアします。  
  
 このメソッドの使用方法の詳細につい[ては、「方法:テンプレート化 ASP.NET ユーザーコントロール](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)を作成します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <related type="Article" href="https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2">方法: テンプレートを作成したユーザーコントロールを作成する</related>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberSignature Language="F#" Value="member this.ClearEffectiveClientIDMode : unit -&gt; unit" Usage="control.ClearEffectiveClientIDMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のコントロール インスタンスおよびすべての子コントロールの <see cref="P:System.Web.UI.Control.ClientIDMode" /> プロパティを <see cref="F:System.Web.UI.ClientIDMode.Inherit" /> に設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientID : string" Usage="System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET によって生成される HTML マークアップのコントロール ID を取得します。</summary>
        <value>ASP.NET によって生成される HTML マークアップのコントロール ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web サーバーコントロールが html 要素として表示される場合`id` 、html 要素の属性は、 <xref:System.Web.UI.Control.ClientID%2A>プロパティの値に設定されます。 この値は、多くの場合、 `document.getElementById`メソッドを使用してクライアントスクリプト内の HTML 要素にアクセスするために使用されます。 <xref:System.Web.UI.Control.ClientID%2A> また、ID は、スタイルを設定する要素を指定するために CSS 規則で使用されることもよくあります。 たとえば、次の CSS スタイル規則では、 `span` `id`属性値がであるすべての`ProductIDLabel`要素を選択`background-color`し、 `white`その属性をに設定しています。  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET は、 <xref:System.Web.UI.Control.ClientID%2A>プロパティ値を生成する方法に対して複数のアルゴリズムを提供します。 コントロールに使用するアルゴリズムを選択するには、 <xref:System.Web.UI.Control.ClientIDMode%2A>プロパティを設定します。 アルゴリズムは、次の表<xref:System.Web.UI.ClientIDMode>に示す列挙値によって識別されます。  
  
|[値]|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 値は、それぞれの親名前付けコンテナーの <xref:System.Web.UI.Control.ID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールの複数のインスタンスが表示されるデータ バインディング シナリオでは、コントロールの <xref:System.Web.UI.Control.ID%2A> 値の前にインクリメント値が挿入されます。 各セグメントはアンダースコア文字 (_) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されていました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 値は、<xref:System.Web.UI.Control.ID%2A> プロパティの値に設定されます。 コントロールが名前付けコンテナーの場合、そのコントロールは、名前付けコンテナーの階層構造に含まれるすべてのコントロールに対して最上位の階層として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内のコントロールに対して使用されます。 <xref:System.Web.UI.Control.ClientID%2A> 値は、親名前付けコンテナーの <xref:System.Web.UI.Control.ClientID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールが複数の行を生成するデータ バインド コントロールである場合は、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティで指定されたデータ フィールドの値が末尾に追加されます。 <xref:System.Web.UI.WebControls.GridView> コントロールの場合は、複数のデータ フィールドを指定できます。 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが空白の場合は、データフィールドの値ではなく、末尾に連続する数値が追加されます。 各セグメントはアンダースコア文字 (_) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールは、<xref:System.Web.UI.ClientIDMode> コントロールの <xref:System.Web.UI.Control.NamingContainer%2A> 設定を継承します。|  
  
 ページのの<xref:System.Web.UI.Control.ClientIDMode%2A>既定値は<xref:System.Web.UI.ClientIDMode.Predictable>です。 コントロールのの<xref:System.Web.UI.Control.ClientIDMode%2A>既定値は<xref:System.Web.UI.ClientIDMode.Inherit>です。 コントロールの既定値は<xref:System.Web.UI.ClientIDMode.Inherit>であるため、既定の生成<xref:System.Web.UI.ClientIDMode.Predictable>モードはです。 (ただし、visual studio を使用して、web プロジェクトを以前のバージョンの ASP.NET 4 に変換する場合、web.config ファイルでは、 <xref:System.Web.UI.ClientIDMode.AutoID> visual studio によってサイトの既定値が自動的にに設定されます)。  
  
 詳細については、[ASP.NET Web サーバー コントロールの識別](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例は、マスターページのコンテンツページ内にある Web ユーザーコントロールを示しています。 ユーザーコントロールには、 <xref:System.Web.UI.WebControls.DropDownList>コントロール<xref:System.Web.UI.WebControls.Label>とコントロールが含まれています。 <xref:System.Web.UI.WebControls.Label>コントロールに表示されるテキストは、ユーザーが<xref:System.Web.UI.WebControls.DropDownList>コントロールから選択した値によって決まります。 テキスト値はクライアントスクリプトによって設定されるため、この値を設定するために Web ページがサーバーにポストバックする必要はありません。 クライアントスクリプトで<xref:System.Web.UI.WebControls.Label>コントロールに対して表示される HTML 要素への参照を取得するには、コントロールの<xref:System.Web.UI.Control.ClientID%2A>プロパティの値を把握している必要があります。 ただし、ユーザーコントロールは Web ページ内の任意の場所に配置できるため、どの名前付けコンテナーにコントロールが格納されるかを事前に把握することはできません。 値が<xref:System.Web.UI.Control.ID%2A>値と同じになるように、このコードでは<xref:System.Web.UI.Control.ClientIDMode%2A>値をに<xref:System.Web.UI.WebControls.ValidatorDisplay.Static>設定します。 <xref:System.Web.UI.Control.ClientID%2A>  
  
 次の例は、ユーザーコントロールを示しています。  
  
  
  
 次の例は、ユーザーコントロールを含むコンテンツページを示しています。  
  
  
  
 次の例は、コンテンツページを含むマスターページを示しています。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">ASP.NET 制御 Id</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">方法: ID によって JavaScript からコントロールにアクセスする</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">チュートリアル: データバインドコントロールを JavaScript から簡単にアクセスできるようにする</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">チュートリアル: Web ユーザーコントロールに配置されたコントロールを JavaScript から簡単にアクセスできるようにする</related>
        <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">ASP.NET Web ページのクライアントスクリプト</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDMode : System.Web.UI.ClientIDMode with get, set" Usage="System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.UI.Control.ClientID" /> プロパティの値を生成するために使用されるアルゴリズムを取得または設定します。</summary>
        <value><see cref="P:System.Web.UI.Control.ClientID" /> プロパティの生成方法を示す値。 既定値は、<see cref="F:System.Web.UI.ClientIDMode.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET は、 <xref:System.Web.UI.Control.ClientID%2A>プロパティ値を生成する方法に対して複数のアルゴリズムを提供します。 コントロールに使用するアルゴリズムを選択するには、 <xref:System.Web.UI.Control.ClientIDMode%2A>プロパティを設定します。 アルゴリズムは、次の表<xref:System.Web.UI.ClientIDMode>に示す列挙値によって識別されます。  
  
|[値]|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 値は、それぞれの親名前付けコンテナーの <xref:System.Web.UI.Control.ID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールの複数のインスタンスが表示されるデータ バインディング シナリオでは、コントロールの <xref:System.Web.UI.Control.ID%2A> 値の前にインクリメント値が挿入されます。 各セグメントはアンダースコア文字 (_) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されていました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 値は、<xref:System.Web.UI.Control.ID%2A> プロパティの値に設定されます。 コントロールが名前付けコンテナーの場合、そのコントロールは、名前付けコンテナーの階層構造に含まれるすべてのコントロールに対して最上位の階層として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内のコントロールに対して使用されます。 <xref:System.Web.UI.Control.ClientID%2A> 値は、親名前付けコンテナーの <xref:System.Web.UI.Control.ClientID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールが複数の行を生成するデータ バインド コントロールである場合は、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティで指定されたデータ フィールドの値が末尾に追加されます。 <xref:System.Web.UI.WebControls.GridView> コントロールの場合は、複数のデータ フィールドを指定できます。 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが空白の場合は、データフィールドの値ではなく、末尾に連続する数値が追加されます。 この値は0から始まり、行ごとに1ずつインクリメントされます。 各セグメントはアンダースコア文字 (_) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールは、<xref:System.Web.UI.ClientIDMode> コントロールの <xref:System.Web.UI.Control.NamingContainer%2A> 設定を継承します。|  
  
 ページのの<xref:System.Web.UI.Control.ClientIDMode%2A>既定値は<xref:System.Web.UI.ClientIDMode.Predictable>です。 コントロールのの<xref:System.Web.UI.Control.ClientIDMode%2A>既定値は<xref:System.Web.UI.ClientIDMode.Inherit>です。 コントロールの既定値は<xref:System.Web.UI.ClientIDMode.Inherit>であるため、既定の生成<xref:System.Web.UI.ClientIDMode.Predictable>モードはです。 (ただし、visual studio を使用して、web プロジェクトを以前のバージョンの ASP.NET 4 に変換する場合、web.config ファイルでは、 <xref:System.Web.UI.ClientIDMode.AutoID> visual studio によってサイトの既定値が自動的にに設定されます)。  
  
 詳細については、[ASP.NET Web サーバー コントロールの識別](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例は<xref:System.Web.UI.WebControls.Label> 、 <xref:System.Web.UI.WebControls.ListView>コントロールに含まれるコントロールを示しています。 <xref:System.Web.UI.ClientIDMode.Predictable> `ProductID`コントロールでは、プロパティはに設定され、プロパティはに設定されます。<xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> <xref:System.Web.UI.Control.ClientIDMode%2A> <xref:System.Web.UI.WebControls.ListView> レンダリングされた HTML では、 `span` 3 つ`ProductIDLabel`のコントロールに対応する3つの要素が作成されます。 ページを実行`id`すると、 `span`要素の属性は次の値に設定されます。  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">ASP.NET 制御 Id</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">方法: ID によって JavaScript からコントロールにアクセスする</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">チュートリアル: データバインドコントロールを JavaScript から簡単にアクセスできるようにする</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">チュートリアル: Web ユーザーコントロールに配置されたコントロールを JavaScript から簡単にアクセスできるようにする</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDSeparator : char" Usage="System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.UI.Control.ClientID" /> プロパティで使用される区切り記号を表す文字値を取得します。</summary>
        <value>常にアンダースコア文字 (_) が返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値は、コントロール<xref:System.Web.UI.Control.ID%2A> <xref:System.Web.UI.Control.UniqueID%2A>の値と親コントロールの値を連結することによって生成されます。 <xref:System.Web.UI.Control.ClientID%2A> 生成さ<xref:System.Web.UI.Control.ID%2A>れたプロパティの各部分は、 <xref:System.Web.UI.Control.ClientIDSeparator%2A>プロパティ値によって区切られます。 値は常にアンダースコア (_) を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の Web 要求に対するサーバー コントロールに関連付けられている <see cref="T:System.Web.HttpContext" /> オブジェクトを取得します。</summary>
        <value>現在の要求に関連付けられている、指定された <see cref="T:System.Web.HttpContext" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、現在の Web <xref:System.Web.HttpContext>要求に対するオブジェクトへのアクセスを提供します。 オブジェクト<xref:System.Web.HttpContext.Application%2A>には<xref:System.Web.HttpContext.Session%2A> 、現在のHTTP<xref:System.Web.HttpContext.Response%2A>要求に関する情報を格納する、 、、およびその他のオブジェクトにアクセスするプロパティが用意されています。<xref:System.Web.HttpContext.Request%2A> また、構成情報を取得し、要求のエラーを設定またはクリアするためのメソッドも用意されています。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UI 階層内の指定されたサーバー コントロールの子コントロールを表す <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトを取得します。</summary>
        <value>指定されたサーバー コントロールの子コントロールのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET ページでは、サーバーコントロールの開始タグと終了タグの間にコントロールが宣言によって追加されると、ASP.NET は、そのコントロール<xref:System.Web.UI.ControlCollection>を、それを含んでいるサーバーコントロールのに自動的に追加します。 サーバー上で処理されない HTML タグやテキスト文字列は、オブジェクトと<xref:System.Web.UI.LiteralControl>して扱われます。 これらは、他のサーバーコントロールと同様にコレクションに追加されます。  
  
 プロパティ<xref:System.Web.UI.Control.Controls%2A>を使用すると、任意のサーバーコントロールの<xref:System.Web.UI.ControlCollection>クラスのインスタンスにプログラムでアクセスできます。 コレクションにコントロールを追加したり、コレクションからコントロールを削除したり、コレクション内のサーバーコントロールを反復処理したりできます。  
  
   
  
## Examples  
 次の例では、 <xref:System.Web.UI.ControlCollection> <xref:System.Web.UI.Control.Controls%2A>プロパティを使用して、サーバーコントロールのオブジェクトに子コントロールを追加する方法を示します。  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="P:System.Web.UI.Control.Controls" />プロパティをオーバーライドする場合は、必ず<see cref="M:System.Web.UI.Control.EnsureChildControls" />メソッドを呼び出してください。 さらに、コントロールをプログラムによってコントロールコレクションに追加する予定がある場合は、オーバーライド<see cref="M:System.Web.UI.Control.CreateChildControls" />されたメソッドにコントロールを追加することを検討してください。</para></block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="control.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ASP.NET ページ フレームワークによって呼び出され、ポストバックまたはレンダリングの準備として、合成ベースの実装を使うサーバー コントロールに対し、それらのコントロールに含まれる子コントロールを作成するように通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複合またはテンプレート化したサーバーコントロールを開発する場合は、このメソッドをオーバーライドする必要があります。 <xref:System.Web.UI.Control.CreateChildControls%2A>メソッドをオーバーライドするコントロールは、名前<xref:System.Web.UI.INamingContainer>の競合を避けるためにインターフェイスを実装する必要があります。  
  
 詳細については、「 [Web サーバーコントロールのテンプレート](https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae)」および「[カスタム ASP.NET サーバーコントロールの開発](https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef)」を参照してください。  
  
   
  
## Examples  
 次の例は、オーバーライドされた<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドのバージョンを示しています。 この実装では、複合コントロールは、 <xref:System.Web.UI.WebControls.TextBox> HTML をレンダリングする2つのリテラルコントロールで囲まれたコントロールを表示します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">カスタム ASP.NET サーバーコントロールの開発</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae">ASP.NET Web サーバーコントロールテンプレート</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection&#xA;override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="control.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールの子コントロール (リテラルとサーバーの両方) を保持する新しい <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトを作成します。</summary>
        <returns>現在のサーバー コントロールの子サーバー コントロールを格納する <see cref="T:System.Web.UI.ControlCollection" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ControlCollection>クラスから派生したコレクションオブジェクトを作成した場合は、カスタムサーバーコントロールでこのメソッドをオーバーライドします。 その後、そのコレクションクラスをこのメソッドのオーバーライドでインスタンス化できます。  
  
   
  
## Examples  
 次のコード例では<xref:System.Web.UI.Control.CreateControlCollection%2A> 、メソッドをオーバーライドして、 `CustomControlCollection`クラスから<xref:System.Web.UI.ControlCollection>継承するクラスのインスタンスを作成します。  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 次のコード例では<xref:System.Web.UI.Control.CreateControlCollection%2A> 、 <xref:System.Web.UI.Control.CreateChildControls%2A>メソッドのカスタムサーバーコントロールオーバーライドでメソッドを使用します。 新しいコレクションが作成され、 `firstControl`とと`secondControl`いう2つの子コントロールが設定されます。  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>呼び出されたサーバー コントロールと、そのすべての子コントロールにデータ ソースをバインドします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberSignature Language="F#" Value="abstract member DataBind : unit -&gt; unit&#xA;override this.DataBind : unit -&gt; unit" Usage="control.DataBind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出されたサーバー コントロールと、そのすべての子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ソースからサーバーコントロールにデータをバインドします。 このメソッドは、通常、データベースクエリを使用してデータセットを取得した後に使用されます。 ほとんどのコントロールは、データバインディングを自動的に実行します。これは、通常、このメソッドを明示的に呼び出す必要がないことを意味します。  
  
 このメソッドは、通常、カスタムテンプレートのデータバインドコントロールを作成するときにオーバーライドされます。 詳細については、「[方法 :テンプレート化された](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2) ASP.NET ユーザーコントロールを作成し、データバインドされた[カスタム Web サーバーコントロールを開発](https://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1)します。 このメソッドは、サーバーコントロールで呼び出されると、サーバーコントロールおよびそのすべての子コントロール内のすべてのデータバインディング式を解決します。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.DataBind%2A> 、カスタム ASP.NET サーバーコントロールのメソッドをオーバーライドします。 まず、基本<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドを呼び出してから、 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType>メソッドを使用してすべて<xref:System.Web.UI.Control.ClearChildViewState%2A>の子コントロールを削除し、メソッドを使用して、これらの子コントロールの保存されているビューステートの設定を削除します。 最後に、 <xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティがに`true`設定され、コントロールに、 <xref:System.Web.UI.Control.TrackViewState%2A>メソッドを使用して、新しく作成されたコントロールのビューステートへの変更を追跡するように指示されます。 これは、データをコントロールにバインドして、新しいデータが前<xref:System.Web.UI.Control.DataBind%2A>のメソッド呼び出しで格納されたデータと競合しないようにするための一般的な手法です。  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">カスタム ASP.NET サーバーコントロールの開発</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberSignature Language="F#" Value="abstract member DataBind : bool -&gt; unit&#xA;override this.DataBind : bool -&gt; unit" Usage="control.DataBind raiseOnDataBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding"><see cref="E:System.Web.UI.Control.DataBinding" /> イベントが発生する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary><see cref="E:System.Web.UI.Control.DataBinding" /> イベントを発生させるオプションを指定して、呼び出されたサーバー コントロールとそのすべての子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタムコントロールが<xref:System.Web.UI.Control.DataBind%2A>メソッドをオーバーライドし、 <xref:System.Web.UI.IDataItemContainer>インターフェイスを実装する場合は、シナリオでメソッドを使用します。<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> このシナリオでは、カスタムコントロールは、 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>をに`raiseOnDataBinding` `false`設定してメソッドを呼び出し、基本クラス<xref:System.Web.UI.Control.DataBind%2A>のメソッドが確実に呼び出されるようにします。  
  
 メソッド<xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>は、が<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> `raiseOnDataBinding` に`true`設定されたメソッドを呼び出します。  
  
> [!NOTE]
>  `raiseOnDataBinding` <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>をに設定`false`してメソッドを呼び出すと、子コントロールはメソッドでデータバインド<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberSignature Language="F#" Value="abstract member DataBindChildren : unit -&gt; unit&#xA;override this.DataBindChildren : unit -&gt; unit" Usage="control.DataBindChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データ ソースをサーバー コントロールの子コントロールにバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.DataBindChildren%2A>メソッドを使用して、データソースをサーバーコントロールの子コントロールにバインドします。  
  
> [!NOTE]
>  このメソッドは、サーバーコントロールで呼び出された場合、データをコントロールにバインドしません。 サーバーコントロールとそのすべての子コントロールをバインドするには<xref:System.Web.UI.Control.DataBind%2A> 、メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">カスタム ASP.NET サーバーコントロールの開発</related>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberSignature Language="F#" Value="member this.DataBinding : EventHandler " Usage="member this.DataBinding : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがデータ ソースに連結すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、サーバーコントロールに対して書き込まれたデータバインディングロジックを実行するように通知します。  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataItemContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーが <see cref="T:System.Web.UI.IDataItemContainer" /> を実装している場合、名前付けコンテナーへの参照を取得します。</summary>
        <value>名前付けコンテナー。 <see cref="T:System.Web.UI.IDataItemContainer" /> を実装している名前付けコンテナーの階層では、このプロパティは階層の最上位にある名前付けコンテナーを返します。現在の <see cref="T:System.Web.UI.Control" /> オブジェクトが <see cref="T:System.Web.UI.IDataItemContainer" /> を実装している名前付けコンテナー内にない場合は <see langword="null" /> を返します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataKeysContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーが <see cref="T:System.Web.UI.IDataKeysControl" /> を実装している場合、名前付けコンテナーへの参照を取得します。</summary>
        <value>名前付けコンテナー。 <see cref="T:System.Web.UI.IDataKeysControl" /> を実装している名前付けコンテナーの階層では、このプロパティは階層の最上位にある名前付けコンテナーを返します。現在の <see cref="T:System.Web.UI.Control" /> オブジェクトが <see cref="T:System.Web.UI.IDataKeysControl" /> を実装している名前付けコンテナー内にない場合は <see langword="null" /> を返します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DesignMode : bool" Usage="System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがデザイン サーフェイスで使用されているかどうかを示す値を取得します。</summary>
        <value>コントロールがデザイナーで使用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.Control.DesignMode%2A>は、 `true`コントロールがデザイナーのコンテキストで使用されていることを示すためにを返します。 カスタムコントロールは、デザイン時の動作が実行時の動作と異なる場合に、このプロパティを使用できます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/wxh45wzs(v=vs.100)">ASP.NET コントロールデザイナーの概要</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="control.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールが、メモリから解放される前に最終的なクリーンアップを実行できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control> を使い終わったら、<xref:System.Web.UI.Control.Dispose%2A>を呼び出します。 <xref:System.Web.UI.Control.Dispose%2A>メソッドによって、<xref:System.Web.UI.Control> は使用不可の状態になります。 このメソッドを呼び出した後、使用していたメモリがガベージコレクションによって解放されるように、コントロールへのすべての参照を解放する必要があります。  
  
   
  
## Examples  
 次のコード例では<xref:System.Web.UI.Control.Dispose%2A> 、メソッドをオーバーライド<xref:System.Web.UI.HtmlTextWriter>して、 <xref:System.Web.UI.Control.Dispose%2A>コントロールに関連付けられているオブジェクト<xref:System.Web.UI.WebControls.Button>を閉じ、 `myButton`という名前のコントロールに対してメソッドを呼び出します。 このバージョン<xref:System.Web.HttpResponse>のメソッドが呼び出されたときにがスローされた場合、コントロールは現在のオブジェクトにメッセージを書き込みます。<xref:System.Exception> <xref:System.Web.UI.Control.Dispose%2A>  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.IComponent.Disposed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがメモリから解放されると発生します。これは、ASP.NET ページが要求されている場合のサーバー コントロールの有効期間における最終段階です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用して、データベース接続など、プロセッサ時間がかなりかかるリソースを解放する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーマがこのコントロールに適用されるかどうかを示す値を取得または設定します。</summary>
        <value>テーマを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.Control.EnableTheming%2A>は、指定されたコントロールに対してテーマが有効かどうかを示します。 <xref:System.Web.UI.Control.EnableTheming%2A>プロパティが`true`の場合、コントロールスキンを適用するために、アプリケーションのテーマディレクトリが検索されます。 テーマディレクトリに特定のコントロールのスキンが存在しない場合、スキンは適用されません。  
  
 プロパティが`false`の場合、テーマディレクトリは検索されず、 <xref:System.Web.UI.Control.SkinID%2A>プロパティの内容は使用されません。 <xref:System.Web.UI.Control.EnableTheming%2A>  
  
 テーマは、ページ、コンテナー、またはコントロールレベルで有効にすることができます。 コントロールは、親コントロール<xref:System.Web.UI.Control.EnableTheming%2A>またはそれを含んでいるページによって設定された値をオーバーライドできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="Page_PreInit" /> イベントが既に発生しています。  
  
- または - 
コントロールが既に <see langword="Controls" /> コレクションに追加されています。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">ASP.NET テーマの概要</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求元クライアントに対して、サーバー コントロールがそのビュー状態と、そこに含まれる任意の子のコントロールのビュー状態を保持するかどうかを示す値を取得または設定します。</summary>
        <value>サーバー コントロールがビュー状態を保持する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビューステートを使用すると、サーバーコントロールは HTTP 要求間で状態を維持できます。 次のすべての条件が満たされている場合は、コントロールのビューステートが有効になります。  
  
-   `true`ページの<xref:System.Web.UI.Control.EnableViewState%2A>プロパティがに設定されています。  
  
-   コントロール<xref:System.Web.UI.Control.EnableViewState%2A>のプロパティがに`true`設定されています。  
  
-   コントロールの<xref:System.Web.UI.ViewStateMode.Enabled>プロパティがに設定されているか<xref:System.Web.UI.ViewStateMode.Enabled> 、または設定を継承しています。 <xref:System.Web.UI.Control.ViewStateMode%2A>  
  
 詳細については、<xref:System.Web.UI.Control.ViewStateMode%2A> プロパティを参照してください。  
  
 サーバーコントロールのビューステートは、すべてのプロパティ値を累積したものです。 これらの値を HTTP 要求間で保持するために、ASP.NET は<xref:System.Web.UI.StateBag>クラスのインスタンスを使用してプロパティ値を格納します。 値は、後続の要求が処理されるときに、非表示フィールドに変数として渡されます。 ビューステートの詳細については、「 [ASP.NET View state の概要](https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818)」を参照してください。  
  
 ビューステートを無効にするのが適切な場合もあります。特に、アプリケーションのパフォーマンスを向上させるためです。 たとえば、データベース要求をサーバーコントロールに読み込んでいる場合は、このプロパティをに`false`設定します。 そうしないと、データベースクエリによってのみ上書きされるサーバーコントロールへのビューステートの読み込みが、プロセッサ時間の無駄になります。 <xref:System.Web.UI.Control.EnableViewState%2A> が`false`の場合は、コントロールの状態を使用して、コントロールに固有のプロパティ情報を永続化することができます。また、"ビューステート" プロパティのように無効にすることはできません。 コントロールの状態とビューステートの違いの詳細については[、「コントロールの状態とビューステートの](https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681)例。  
  
 ASP.NET ページのビューステートを宣言によって有効または無効にする方法の詳細については、「 [ \@ page](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100))」を参照してください。
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.EnableViewState%2A> 、プロパティ`false`をに設定します。  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 状態管理の概要</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681">コントロールの状態とビューステートの例</related>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.EndRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.EndRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">トレース データを書き込むオブジェクト。</param>
        <param name="traceObject">トレース オブジェクト。</param>
        <summary>レンダリング データのデザイン時のトレースを終了します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberSignature Language="F#" Value="abstract member EnsureChildControls : unit -&gt; unit&#xA;override this.EnsureChildControls : unit -&gt; unit" Usage="control.EnsureChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれているかどうかを確認します。 含まれていない場合、子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、まず、 <xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティの現在の値をチェックします。 この値が`false`の場合<xref:System.Web.UI.Control.CreateChildControls%2A> 、メソッドが呼び出されます。  
  
 <xref:System.Web.UI.Control.EnsureChildControls%2A>メソッドは、通常、一部またはすべての機能に対して子コントロールを使用するコントロールである複合コントロールで使用されます。 メソッド<xref:System.Web.UI.Control.EnsureChildControls%2A>は、子コントロールが作成されており、入力の処理、データバインディングの実行、またはその他のタスクを実行する準備ができていることを確認するために呼び出されます。  
  
 <xref:System.Web.UI.WebControls.GridView>コントロールは、複合コントロールの一例です。 <xref:System.Web.UI.WebControls.Table>このメソッドは<xref:System.Web.UI.WebControls.TableRow> <xref:System.Web.UI.WebControls.TextBox> <xref:System.Web.UI.WebControls.GridView> 、、、、、およびコントロールなどの子コントロールを作成します。これは、によって生成される HTML テーブルのレンダリングに使用されます。 <xref:System.Web.UI.WebControls.Label> <xref:System.Web.UI.WebControls.TableCell>  
  
 ほとんどの場合、カスタムサーバーコントロールの開発者は、このメソッドをオーバーライドする必要はありません。 このメソッドをオーバーライドする場合は、既定の動作と同様の方法で使用します。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.EnsureChildControls%2A> 、メソッドを使用して、現在のサーバーコントロールに子コントロールがあることを確認します。 次に、現在のサーバー <xref:System.Web.UI.WebControls.TextBox.Text%2A>コントロールの<xref:System.Web.UI.ControlCollection>オブジェクトの<xref:System.Web.UI.WebControls.TextBox>子 Web コントロールのプロパティを取得または設定します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberSignature Language="F#" Value="member this.EnsureID : unit -&gt; unit" Usage="control.EnsureID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ID が割り当てられていないコントロールの ID を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.Control.EnsureID%2A>は、別のコントロールに含まれるコントロールの識別子を生成します。 識別子は、 <xref:System.Web.UI.Control.ID%2A>プロパティに値が割り当てられていないコントロールに対してのみ生成されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Events : System.ComponentModel.EventHandlerList" Usage="System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのイベント ハンドラー デリゲートのリストを取得します。 このプロパティは読み取り専用です。</summary>
        <value>イベント ハンドラー デリゲートのリスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの型<xref:System.ComponentModel.EventHandlerList>はで、線形検索アルゴリズムを使用してデリゲートのリスト内のエントリを検索します。 大量のエントリを処理する場合、線形検索アルゴリズムは非効率的です。 このため、リストが大きい場合は、このプロパティを使用してエントリを検索すると処理速度が低下します。  
  
   
  
## Examples  
 次の例では、という`Click`名前のイベントを作成します。これは<xref:System.ComponentModel.EventHandlerList> 、ページからイベントが呼び出されたときに、コントロールのコレクションからハンドラーを追加および削除します。  
  
 **メモ**この例では、コントロールが保持するイベントの一覧から、コントロールによってイベントが追加および削除される方法を最適化します。 カスタムコントロールを作成し、イベントを定義する場合は、次のようなコードを使用します。 この手法はでC#使用できますが、Visual Basic では使用できません。  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したサーバー コントロールの現在の名前付けコンテナーを検索します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string -&gt; System.Web.UI.Control&#xA;override this.FindControl : string -&gt; System.Web.UI.Control" Usage="control.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">検索されるコントロールの識別子。</param>
        <summary>指定した <paramref name="id" /> パラメーターを使用して、サーバー コントロールの現在の名前付けコンテナーを検索します。</summary>
        <returns>指定したコントロール。指定したコントロールがない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 分離<xref:System.Web.UI.Control.FindControl%2A>コードページ内の関数からコントロールにアクセスしたり、別のコンテナー内にあるコントロールにアクセスしたり、ターゲットコントロールが呼び出し元に直接アクセスできない場合に使用します。 このメソッドは、コントロールが指定されたコンテナーに直接含まれている場合にのみ、コントロールを検索します。つまり、メソッドは、コントロール内のコントロールの階層全体を検索しません。 直接コンテナーがわからない場合にコントロールを検索する方法については、「 [方法:ID](https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3)によってサーバーコントロールにアクセスします。  
  
   
  
## Examples  
 次の例では`Button1_Click` 、イベントハンドラーを定義します。 このハンドラーが呼び出されると、 <xref:System.Web.UI.Control.FindControl%2A>メソッドを使用して、含ま<xref:System.Web.UI.Control.ID%2A>れて`TextBox2`いるページののプロパティを持つコントロールを検索します。 コントロールが見つかった場合、その親は<xref:System.Web.UI.Control.Parent%2A>プロパティを使用して決定され、親<xref:System.Web.UI.Control.ID%2A>コントロールがページに書き込まれます。 が`TextBox2`見つからない場合は、"コントロールが見つかりません" というページに書き込まれます。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3">方法: ID によるサーバーコントロールへのアクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string * int -&gt; System.Web.UI.Control&#xA;override this.FindControl : string * int -&gt; System.Web.UI.Control" Usage="control.FindControl (id, pathOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">検索されるコントロールの識別子。</param>
        <param name="pathOffset">名前付けコンテナーに到達するために必要なページ コントロール階層までのコントロールの数。</param>
        <summary>指定した <paramref name="id" /> および検索に役立つ <paramref name="pathOffset" /> パラメーターに指定された整数を使用して、サーバー コントロールの現在の名前付けコンテナーを検索します。 この形式の <see cref="Overload:System.Web.UI.Control.FindControl" /> メソッドはオーバーライドしないでください。</summary>
        <returns>指定したコントロール。指定したコントロールがない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; unit&#xA;override this.Focus : unit -&gt; unit" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールに入力フォーカスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Focus%2A>メソッドを使用して、Web ページの最初のフォーカスをコントロールに設定します。 コントロールが選択された状態で、ブラウザーでページが開きます。  
  
 <xref:System.Web.UI.Control.Focus%2A>メソッドを使用すると、ページフォーカススクリプトへの呼び出しが、レンダリングされたページに出力されます。 メソッドが呼び出されたコントロール`ID`と一致する HTML 属性を持つコントロールがページに含まれていない場合、ページフォーカスは設定されません。 <xref:System.Web.UI.Control.Focus%2A> このような状況が発生する可能性があるのは、ユーザーコントロールの子コントロールにフォーカスを設定するのではなく、ユーザーコントロールにフォーカスを設定した場合です。 このシナリオでは、 <xref:System.Web.UI.Control.FindControl%2A>メソッドを使用して、ユーザーコントロールの子コントロールを検索し、その<xref:System.Web.UI.Control.Focus%2A>メソッドを呼び出すことができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberSignature Language="F#" Value="abstract member GetDesignModeState : unit -&gt; System.Collections.IDictionary&#xA;override this.GetDesignModeState : unit -&gt; System.Collections.IDictionary" Usage="control.GetDesignModeState " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのデザイン時データを取得します。</summary>
        <returns>コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.Control.GetDesignModeState%2A>は、コントロールのデザイン時データを返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>既定<see cref="M:System.Web.UI.Control.GetDesignModeState" />では<see langword="null" /> 、メソッドはを返します。 コントロールに必要なデザイン時データを提供するには、このメソッドをオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ルート パラメーターのセットに対応する URL を取得します。オプションで、ルート名に対応する URL も取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの便宜を実現するために用意されています。 これは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>メソッドを呼び出すことと同じです。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : obj -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定されたルート パラメーターに対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの便宜を実現するために用意されています。 これは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドを呼び出すことと同じです。 このメソッドは、 `routeParameters` <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>コンストラクターを使用して、渡さ<xref:System.Web.Routing.RouteValueDictionary>れたオブジェクトをオブジェクトに変換します。  
  
   
  
## Examples  
 次の例は、 <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType>メソッドを呼び出して、とと`category`いう名前`productid`のパラメーターを持つルートの URL を取得する方法を示しています。 この例では、 <xref:System.Web.UI.WebControls.HyperLink>という名前`HyperLink1`のコントロールが作成されていることを前提としています。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定されたルート パラメーターに対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの便宜を実現するために用意されています。 これは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドを呼び出すことと同じです。  
  
   
  
## Examples  
 次の例は、このメソッドを呼び出して、とと`productid` `category`いう名前のパラメーターを持つルートの URL を取得する方法を示しています。 この例では、 <xref:System.Web.UI.WebControls.HyperLink>という名前`HyperLink1`のコントロールが作成されていることを前提としています。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * obj -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前です。</param>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットおよびルート名に対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターおよびルート名に対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの便宜を実現するために用意されています。 これは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドを呼び出すことと同じです。 このメソッドは、 `routeParameters` <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>コンストラクターを使用して、渡さ<xref:System.Web.Routing.RouteValueDictionary>れたオブジェクトをオブジェクトに変換します。  
  
   
  
## Examples  
 次の例では、このメソッドを呼び出してという名前`Product`のルートの URL を取得し、と`category`いう名前`productid`のパラメーターを持つ方法を示します。 この例では、 <xref:System.Web.UI.WebControls.HyperLink>という名前`HyperLink1`のコントロールが作成されていることを前提としています。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前です。</param>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットおよびルート名に対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターおよびルート名に対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの便宜を実現するために用意されています。 これは、 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドを呼び出すことと同じです。  
  
   
  
## Examples  
 次の例では、このメソッドを呼び出してという名前`Product`のルートの URL を取得し、と`category`いう名前`productid`のパラメーターを持つ方法を示します。 この例では、 <xref:System.Web.UI.WebControls.HyperLink>という名前`HyperLink1`のコントロールが作成されていることを前提としています。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET ルーティング</related>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetUniqueIDRelativeTo : System.Web.UI.Control -&gt; string" Usage="control.GetUniqueIDRelativeTo control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">名前付けコンテナー内のコントロール。</param>
        <summary>指定されたコントロールの <see cref="P:System.Web.UI.Control.UniqueID" /> プロパティのプレフィックス部分を返します。</summary>
        <returns>指定されたコントロールの <see cref="P:System.Web.UI.Control.UniqueID" /> プロパティのプレフィックス部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのプロパティは、コントロールの<xref:System.Web.UI.Control.ID%2A>プロパティにプレフィックスを追加することによって生成されます。 <xref:System.Web.UI.Control.UniqueID%2A> プレフィックスは、区切り文字を<xref:System.Web.UI.Control.UniqueID%2A>連結したコントロールの名前付けコンテナーのプロパティで構成されます。 名前付けコンテナーがページの場合、プレフィックスはありません。 このメソッドは、プレフィックス文字列を返します。 プレフィックス文字列がない場合は、コントロールの<xref:System.Web.UI.Control.UniqueID%2A>値を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" /> の <see cref="P:System.Web.UI.Control.NamingContainer" /> プロパティが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildViewState : bool" Usage="System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のサーバー コントロールの子コントロールが、保存されたビューステートの設定を持っているかどうかを示す値を取得します。</summary>
        <value>子コントロールが、保存されたビューステートの情報を持っている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、 <xref:System.Web.UI.Control.ClearChildViewState%2A>サーバーコントロールの子コントロールにビューステート情報が格納されていることを確認することで、メソッドの不要な呼び出しを回避できます。  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberSignature Language="F#" Value="abstract member HasControls : unit -&gt; bool&#xA;override this.HasControls : unit -&gt; bool" Usage="control.HasControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれているかどうかを確認します。</summary>
        <returns>コントロールに他のコントロールが格納されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、子コントロールが存在するかどうかを判断するだけであるため、不要<xref:System.Web.UI.ControlCollection.Count%2A>なプロパティ呼び出しを回避できるようにすることで、パフォーマンスを向上させることができます。 このプロパティを呼び出すに<xref:System.Web.UI.ControlCollection>は、オブジェクトをインスタンス化する必要があります。 子が存在しない場合、このオブジェクトの作成によってサーバーリソースが浪費されます。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.HasControls%2A> 、メソッドを使用し<xref:System.Web.UI.ControlCollection.Count%2A>て、プロパティを使用してオブジェクトを<xref:System.Web.UI.ControlCollection>反復処理する前に、コントロールが存在するかどうかを確認します。  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>メソッド<see cref="M:System.Web.UI.Control.HasControls" />は、など<see cref="T:System.ComponentModel.EditorBrowsableAttribute" />のメタデータ属性を変更するためにのみオーバーライドする必要があります。 属性の使用方法の詳細については、「[属性](~/docs/standard/attributes/index.md)」を参照してください。</para></block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberSignature Language="F#" Value="member this.HasEvents : unit -&gt; bool" Usage="control.HasEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールまたは子コントロールに対してイベントが登録されているかどうかを示す値を返します。</summary>
        <returns>イベントが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールに割り当てられたプログラム ID を取得または設定します。</summary>
        <value>コントロールに割り当てられたプログラム ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバーコントロールでこのプロパティを設定することにより、サーバーコントロールのプロパティ、イベント、およびメソッドにプログラムでアクセスできます。 このプロパティは、ASP.NET サーバーコントロールの開始タグの<xref:System.Web.UI.Control.ID%2A>属性を宣言することで、Web 開発者が設定できます。  
  
 宣言によって、またはプログラムによってサーバーコントロールにこのプロパティが指定されていない場合は、親コントロールの<xref:System.Web.UI.Control.Controls%2A>プロパティを使用して、コントロールへの参照を取得できます。  
  
> [!NOTE]
>  このプロパティの有効な値は、英数字とアンダースコア (_) 文字の組み合わせだけです。 スペースやその他の無効な文字を含めると、ASP.NET ページパーサーエラーが発生します。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール ID を区別するために使用する文字を取得します。</summary>
        <value>区切り記号。 既定値は "$" です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.IdSeparator%2A>プロパティに含まれる文字は、子コントロールのコントロール識別子を区切るために使用されます。 ID 区切り文字が<xref:System.Web.UI.Control.ID%2A>プロパティに追加されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberSignature Language="F#" Value="member this.Init : EventHandler " Usage="member this.Init : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールが初期化されると発生します。これは、サーバー コントロールの有効期間における最初の手順です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバーコントロールは、インスタンスを作成および設定するために必要な初期化手順を実行する必要があります。 このイベント内では、ビューステート情報を使用できません。まだ設定されていません。 このコントロールの子または親であるかどうかに関係なく、このイベント中に別のサーバーコントロールにアクセスすることはできません。 他のサーバーコントロールを作成し、アクセスできる状態にすることはできません。 サーバーコントロールイベントの詳細については、「 [ASP.NET Web フォームサーバーコントロールイベントモデル](https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)」を参照してください。  
  
   
  
## Examples  
 次の例では、カスタムイベントハンドラー `Calendar_Init`を<xref:System.Web.UI.WebControls.Calendar>コントロールの`Init`イベントに割り当てています。  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsChildControlStateCleared : bool" Usage="System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに含まれているコントロールに、コントロールの状態が設定されているかどうかを示す値を取得します。</summary>
        <value>このコントロールの子がコントロールの状態を使用していない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberSignature Language="F#" Value="member this.IsLiteralContent : unit -&gt; bool" Usage="control.IsLiteralContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールがリテラルな内容だけを保持しているかどうかを決定します。</summary>
        <returns>サーバー コントロールがリテラルな内容だけを含む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが返さ`true`れるときに、サーバーコントロールのコレクションは1つのリテラルコントロールを保持します。  
  
   
  
## Examples  
 次の例では、サーバーコントロールを含むページがポストバックされたかどうかを確認します。 存在する場合は、 <xref:System.Web.UI.Control.IsLiteralContent%2A>メソッドを呼び出して、コントロールにリテラルコンテンツだけが含まれているか、他のサーバーコントロールの親コントロールであるかを確認します。 単にリテラルコンテンツ<xref:System.Web.UI.Control.UniqueID%2A>が含まれている場合は、そのコンテンツを表すのプロパティ<xref:System.Web.UI.LiteralControl>が応答に書き込まれます。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTrackingViewState : bool" Usage="System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがビューステートの変更を保存しているかどうかを示す値を取得します。</summary>
        <value>コントロールがその状態を保存するようにマークされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用するサンプルのカスタムサーバーコントロールについては、「[テンプレートサーバーコントロールの例](https://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)」を参照してください。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.DataBind%2A> 、カスタム ASP.NET サーバーコントロールのメソッドをオーバーライドします。 まず、基本<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドを呼び出し、次にオブジェクトを`ControlCollection`使用します。 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType>すべての子コントロールを削除するメソッドと<xref:System.Web.UI.Control.ClearChildViewState%2A> 、それらの子コントロールの保存されているビューステート設定を削除するメソッド。 最後に、 <xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティがに`true`設定されます。 コントロールは、プロパティを<xref:System.Web.UI.Control.IsTrackingViewState%2A>使用して、コントロールに対してビューステート変更の追跡が有効になっているかどうかを判断します。 有効になっ<xref:System.Web.UI.Control.TrackViewState%2A>ていない場合は、メソッドが呼び出されます。  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsViewStateEnabled : bool" Usage="System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールでビューステートが有効かどうかを示す値を取得します。</summary>
        <value>このコントロールでビューステートが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビューステートは、ページ、コンテナー、またはコントロールレベルで有効にすることができます。 ページまたはコンテナーレベルでビューステートが無効になっていると、ページまたはコンテナーに含まれるすべてのコントロールのビューステートが無効になります。 プロパティ<xref:System.Web.UI.Control.IsViewStateEnabled%2A>は、ページ、コンテナー、またはコントロールによってビューステートが有効かどうかを示します。  
  
 <xref:System.Web.UI.Control.EnableViewState%2A> プロパティ<xref:System.Web.UI.Control.IsViewStateEnabled%2A>とプロパティが異なる可能性があります。 たとえば、コントロールを含む<xref:System.Web.UI.Page>がビューステートを無効<xref:System.Web.UI.Control.EnableViewState%2A>にしている場合、プロパティ`true`はに<xref:System.Web.UI.Control.IsViewStateEnabled%2A>なります`false`が、プロパティはになります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>ページ開発者は、 <see cref="P:System.Web.UI.Control.EnableViewState" />プロパティ<see cref="P:System.Web.UI.Control.ViewStateMode" />とプロパティを設定して、コントロールでビューステートを使用しているかどうかを示します。 コントロールとすべてのコンテナー <see cref="P:System.Web.UI.Control.ViewStateMode" />に対してビューステートが有効になっているかどうかを判断するには、コードでプロパティとプロパティを使用します。<see cref="P:System.Web.UI.Control.IsViewStateEnabled" /></para></block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールが <see cref="T:System.Web.UI.Page" /> オブジェクトに読み込まれると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各ページ要求に対して発生するように設定されている処理手順を実行するように、サーバーコントロールに通知します。 このイベントから、ビューステート情報と Web フォームポストデータにアクセスできます。 また、ページのコントロール階層内の他のサーバーコントロールにアクセスすることもできます。  
  
> [!NOTE]
>  `Page_Load`イベント中にコントロールにカスタムテンプレートを設定した場合、カスタムテンプレートの子コントロールのテキスト値は失われます。 これは、フォームの値が既に読み込まれているために発生します。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadControlState : obj -&gt; unit&#xA;override this.LoadControlState : obj -&gt; unit" Usage="control.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary><see cref="M:System.Web.UI.Control.SaveControlState" /> メソッドによって保存された前回のページ要求からコントロールの状態情報を復元します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタムサーバーコントロールがコントロールの状態を復元する方法を指定する必要がある場合は、このメソッドをオーバーライドします。 詳細については、「 [ASP.NET State Management の概要](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Web.UI.Control.LoadControlState%2A> 、カスタム ASP.NET コントロールのメソッドをオーバーライドします。 このメソッドが呼び出されると、コントロールに対してコントロールの状態が既に保存されているかどうかが`currentIndex`判断され、存在する場合は、内部プロパティが保存された値に設定されます。  
  
 メソッドは、の<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを呼び出して、 <xref:System.Web.UI.Control.Page%2A>カスタムコントロールがコントロールの状態を使用することを示すためにオーバーライドされます。 <xref:System.Web.UI.Control.OnInit%2A>  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadViewState : obj -&gt; unit&#xA;override this.LoadViewState : obj -&gt; unit" Usage="control.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary><see cref="M:System.Web.UI.Control.SaveViewState" /> メソッドによって保存された前回のページ要求からビューステート情報を復元します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、主に .NET Framework インフラストラクチャによって使用されます。独自に作成したコードから直接使用するためのものではありません。 ただし、コントロールの開発者は、このメソッドをオーバーライドして、カスタムサーバーコントロールがビューステートを復元する方法を指定できます。 詳細については、「 [ASP.NET State Management の概要](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))」を参照してください。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.LoadViewState%2A> 、カスタム ASP.NET サーバーコントロールのメソッドをオーバーライドします。 この<xref:System.Web.UI.Control.LoadViewState%2A>メソッドは<xref:System.Object> 、 `savedState`パラメーターで渡されたビューステート情報を格納する配列を作成し、配列の最初のインデックス位置に対してメソッドの基本実装を呼び出します。 次の2つのインデックス位置に格納されている値`UserText`が`PasswordText`、それぞれとという名前の変数に代入されます。  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadViewStateByID : bool" Usage="System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがインデックスではなく <see cref="P:System.Web.UI.Control.ID" /> によりビューステートの読み込みを行うかどうかを示す値を取得します。</summary>
        <value>コントロールが <see cref="P:System.Web.UI.Control.ID" /> によりビューステートを読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、親コントロールが作成した子コントロールにビューステートを読み込むときに、親コントロールの<xref:System.Web.UI.Control.Controls%2A>コレクション内の各子コントロールの位置によって、この操作が行われます。 ビューステートが最初に適用されると、すべての子コントロールが作成されていない可能性があります。 この場合、まだ作成されていないコントロールのビューステートは保存され、後で子コントロールが作成されるときに適用されます。  
  
 親コントロールがビューステートを子コントロールに適用するには、次の2つの条件が満たされている必要があります。  
  
-   ポストバック時に、親コントロールは、コントロールの順序が一貫しているように、前の要求とまったく同じ順序で子コントロールを作成する必要があります。  
  
-   ポストバック後に、作成された子コントロールを親コントロールの<xref:System.Web.UI.Control.Controls%2A>コレクションの末尾に追加する必要があります。  
  
 これら2つの条件を満たすことができない場合、子コントロールの遅延作成の場合と同様に、親コントロールはを使用<xref:System.Web.UI.Control.ID%2A>してビューステートを読み込むことができます。 <xref:System.Web.UI.Control.LoadViewStateByID%2A>プロパティをに`true`設定するには、 <xref:System.Web.UI.ViewStateModeByIdAttribute>親コントロールのメタデータ属性を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPathSecure : string -&gt; string" Usage="control.MapPathSecure virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">相対 URL、またはルートに対して相対的な URL。</param>
        <summary>仮想パス (絶対パスまたは相対パス) の割り当て先の物理パスを取得します。</summary>
        <returns>要求されたファイルへの物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ファイルを読み取るアクセス許可を持ち、完全に信頼された .dll ファイル (system.servicemodel など) の一部であるサーバーコントロールでのみ使用できます。 これにより、セキュリティ侵害を防ぐことができます。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.MapPathSecure%2A> 、メソッドを使用して<xref:System.Web.UI.Page> 、オブジェクトまたは<xref:System.Web.UI.UserControl>オブジェクトの仮想ディレクトリの物理パスを取得します。  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" /> は <see langword="null" /> または空の文字列 ("") です。</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同じ <see cref="P:System.Web.UI.Control.ID" /> プロパティ値を持つ複数のサーバー コントロールを区別するための一意の名前空間を作成する、サーバー コントロールの名前付けコンテナーへの参照を取得します。</summary>
        <value>サーバー コントロールの名前付けコンテナー。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web アプリケーションの各ページには、コントロールの階層が含まれています。 この階層は、コントロールが UI を生成してユーザーに表示するかどうかに依存しません。 指定されたコントロールの名前付けコンテナーは、 <xref:System.Web.UI.INamingContainer>インターフェイスを実装する階層内の親コントロールです。 このインターフェイスを実装するサーバーコントロールは、その子サーバーコントロール<xref:System.Web.UI.Control.ID%2A>のプロパティ値に対して一意の名前空間を作成します。 名前付けコンテナーの<xref:System.Web.UI.Control.NamingContainer%2A>子コントロールのプロパティを使用して、その親コンテナーへの参照を取得できます。  
  
 サーバーコントロールに対して一意の名前空間を作成することは、 <xref:System.Web.UI.WebControls.Repeater>および<xref:System.Web.UI.WebControls.DataList>サーバーコントロールなどの Web サーバーコントロールをデータにバインドする場合に特に重要です。 データソース内の複数のエントリが、繰り返しコントロールの子であるサーバーコントロールの複数のインスタンスを作成する場合、名前付けコンテナーは、これらの子コントロール<xref:System.Web.UI.Control.UniqueID%2A>の各インスタンスに競合しないプロパティ値があることを保証します。 ページの既定の名前付けコンテナーは、そのページが<xref:System.Web.UI.Page>要求されたときに生成されるクラスのインスタンスです。  
  
 プロパティ<xref:System.Web.UI.Control.ClientID%2A>には、HTML マークアップで要素の`id`属性として表示される値が含まれています。 <xref:System.Web.UI.Control.ClientIDMode%2A>プロパティに割り当てる値に応じて、 <xref:System.Web.UI.Control.ClientID%2A>プロパティに対して生成される値に、 <xref:System.Web.UI.Control.NamingContainer%2A>オブジェクトの ID が含まれる場合があります。 <xref:System.Web.UI.Control.ClientIDMode%2A>をに<xref:System.Web.UI.ClientIDMode.Static>設定し<xref:System.Web.UI.Control.NamingContainer%2A>た場合、値にはオブジェクトのIDが含まれません。<xref:System.Web.UI.Control.ClientID%2A> をまたは<xref:System.Web.UI.Control.ClientIDMode%2A> <xref:System.Web.UI.ClientIDMode.AutoID> の<xref:System.Web.UI.ClientIDMode.Predictable>いずれかに<xref:System.Web.UI.Control.NamingContainer%2A>設定すると、値にはオブジェクトのIDが含まれます。<xref:System.Web.UI.Control.ClientID%2A> 詳細については、[ASP.NET Web サーバー コントロールの識別](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例は、プロパティ<xref:System.Web.UI.Control.NamingContainer%2A>の使用方法を示しています。  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBubbleEvent : obj * EventArgs -&gt; bool&#xA;override this.OnBubbleEvent : obj * EventArgs -&gt; bool" Usage="control.OnBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>サーバー コントロールのイベントをページの UI サーバー コントロールの階層構造に渡すかどうかを決定します。</summary>
        <returns>イベントがキャンセルされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 、、 <xref:System.Web.UI.WebControls.Repeater> <xref:System.Web.UI.WebControls.DataList> Web コントロールなどの ASP.NET サーバーコントロールには、イベントを発生させる子コントロールを含めることができます。 <xref:System.Web.UI.WebControls.GridView> たとえば、 <xref:System.Web.UI.WebControls.GridView>コントロールの各行には、テンプレートによって動的に作成された1つ以上のボタンを含めることができます。 各ボタンがイベントを個別に生成するのではなく、入れ子になったコントロールからのイベントは "バブル" されます。つまり、名前付けコンテナーに送信されます。 名前付けコンテナーは、パラメーター値を使用し<xref:System.Web.UI.WebControls.GridView.RowCommand>てという汎用イベントを生成します。 これらの値を使用すると、元のイベントを発生させた個々のコントロールを特定できます。 この単一のイベントに応答することによって、子コントロールの個々のイベント処理メソッドを記述しなくても済むようになります。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.OnBubbleEvent%2A> 、カスタム ASP.NET サーバーコントロールのメソッドを`ParentControl`オーバーライドします。 このメソッドは、の`ParentControl`子コントロールがメソッドを<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>呼び出すと呼び出されます。 この場合、クラスは`ParentControl` 、ASP.NET の親ページに2つの文字列を書き込みます。最初<xref:System.Web.UI.Control.OnBubbleEvent%2A>にメソッドが呼び出されたことを示す、2番目<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>の文字列はメソッドのソース管理を識別します。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataBinding : EventArgs -&gt; unit&#xA;override this.OnDataBinding : EventArgs -&gt; unit" Usage="control.OnDataBinding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.DataBinding" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、サーバーコントロールに関連付けられているデータをバインドするためのロジックを実行するように通知します。  
  
 <xref:System.Web.UI.Control.DataBinding>イベントを処理する場合は、このイベント処理メソッドをオーバーライドする必要があります。 これにより、 <xref:System.Web.UI.Control.DataBinding>イベントにアタッチされたすべてのデリゲートが呼び出されます。  
  
   
  
## Examples  
 次の例は、 <xref:System.Web.UI.Control.OnDataBinding%2A>メソッドをオーバーライドして、データソースから親コントロールに子コントロールを追加する方法を示しています。  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="control.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET は、このメソッドを呼び出し<xref:System.Web.UI.Control.Init>てイベントを発生させます。 カスタムコントロールを開発している場合は、追加の処理を提供するために、このメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、基本コントロールの<xref:System.Web.UI.Control.OnInit%2A>メソッドを呼び出して、サブスクライバーにイベントを通知します。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="control.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.Load" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET は、このメソッドを呼び出し<xref:System.Web.UI.Control.Load>てイベントを発生させます。 カスタムコントロールを開発している場合は、追加の処理を提供するために、このメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、基本コントロールの<xref:System.Web.UI.Control.OnLoad%2A>メソッドを呼び出して、サブスクライバーにイベントを通知します。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="control.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.PreRender" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET は、このメソッドを呼び出し<xref:System.Web.UI.Control.PreRender>てイベントを発生させます。 カスタムコントロールを開発している場合は、追加の処理を提供するために、このメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、基本コントロールの<xref:System.Web.UI.Control.OnPreRender%2A>メソッドを呼び出して、サブスクライバーにイベントを通知します。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="control.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary><see cref="E:System.Web.UI.Control.Unload" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET は、このメソッドを呼び出し<xref:System.Web.UI.Control.Unload>てイベントを発生させます。 カスタムコントロールを開発している場合は、追加の処理を提供するために、このメソッドをオーバーライドできます。 このメソッドをオーバーライドする場合は、基本コントロールの<xref:System.Web.UI.Control.OnUnload%2A>メソッドを呼び出して、サブスクライバーにイベントを通知します。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string -&gt; System.IO.Stream" Usage="control.OpenFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">目的のファイルへのパス。</param>
        <summary>ファイルの読み込みで使用される <see cref="T:System.IO.Stream" /> を取得します。</summary>
        <returns>目的のファイルを参照する <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.Control.OpenFile%2A>は、 `path`パラメーター <xref:System.IO.Stream>で指定されたファイルの内容を読み取るために使用できるオブジェクトを返します。 Path パラメーターには、プロトコルを使用しない相対 URL またはルート URL ("~/mySite/myFile.txt" など)、または物理パス (local ("c:\mySite\myFile.txt") または UNC\\("\myServer\myFile.txt")) のいずれかを指定できます。  
  
 メソッド<xref:System.Web.UI.Control.OpenFile%2A>は、ファイルアクセスセキュリティを使用して、指定されたファイルへのアクセスを制御します。 現在の ASP.NET ユーザーにファイルへのアクセス権がない場合、ファイルは開か<xref:System.Web.HttpException>れず、アクセスが拒否されたことを示す例外がスローされます。 パラメーターで`path`相対パスを指定した場合、例外には、要求されたファイルへの物理パスに関する情報は含まれません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定したファイルへのアクセスは拒否されました。</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page with get, set" Usage="System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールを含んでいる <see cref="T:System.Web.UI.Page" /> インスタンスへの参照を取得します。</summary>
        <value>サーバー コントロールを含んでいる <see cref="T:System.Web.UI.Page" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値には、サーバーコントロールを含む .aspx ファイルの名前が反映されます。  
  
   
  
## Examples  
 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> メソッドをオーバーライドする例を次に示します。 <xref:System.Web.UI.Page>プロパティを使用して<xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType>プロパティにアクセスし、このコントロールを含むページが初めて読み込まれたばかりか、またはポストバックの結果であるかを確認します。  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Web.UI.Control" Usage="System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ コントロールの階層構造における、サーバー コントロールの親コントロールへの参照を取得します。</summary>
        <value>サーバー コントロールの親コントロールへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページが要求されるたびに、そのページ上のサーバーコントロールの階層が構築されます。 このプロパティを使用すると、その階層内の現在のサーバーコントロールの親コントロールを決定し、それに対するプログラミングを行うことができます。  
  
   
  
## Examples  
 次の例では、 <xref:System.Web.UI.Control> `myControl1`ページ上の新しいオブジェクトを、 <xref:System.Web.UI.Control.FindControl%2A>メソッドの呼び出しで指定されたコントロールに設定します。 呼び出しによってコントロールが返された場合、 <xref:System.Web.UI.Control.Parent%2A>コードはプロパティを使用して`myControl1`、を含むコントロールを識別します。 親コントロールが存在する場合、"テキストボックスの親は" という文字列が親コントロールの<xref:System.Web.UI.Control.ID%2A>プロパティと連結され、 <xref:System.Web.UI.Control.Page%2A>に書き込まれます。 親コントロールが見つからない場合は、"コントロールが見つかりません" という文字列が書き込まれます。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberSignature Language="F#" Value="member this.PreRender : EventHandler " Usage="member this.PreRender : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.Control" /> オブジェクトの読み込み後、表示を開始する前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバーコントロールがページに表示される前に、このイベントを使用して更新を実行します。 このイベント中に、サーバーコントロールのビューステートの変更を保存できます。 レンダリングフェーズで行った変更は保存されません。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.RaiseBubbleEvent : obj * EventArgs -&gt; unit" Usage="control.RaiseBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>イベントのソースおよびその情報をコントロールの親に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 、、 <xref:System.Web.UI.WebControls.Repeater> <xref:System.Web.UI.WebControls.DataList> Web コントロールなどの ASP.NET サーバーコントロールには、イベントを発生させる子コントロールを含めることができます。 <xref:System.Web.UI.WebControls.GridView> たとえば、 <xref:System.Web.UI.WebControls.GridView>コントロールの各行には、テンプレートによって動的に作成された1つ以上のボタンを含めることができます。 各ボタンがイベントを個別に生成するのではなく、入れ子になったコントロールからのイベントは "バブル" されます。つまり、コントロールの親に送信されます。 親は、パラメーター値を使用して<xref:System.Web.UI.WebControls.GridView.RowCommand>という汎用イベントを生成します。 これらの値を使用すると、元のイベントを発生させた個々のコントロールを特定できます。 この単一のイベントに応答することによって、子コントロールの個々のイベント処理メソッドを記述しなくても済むようになります。  
  
 このメソッドをオーバーライドすることはできませんが、作成したコントロールでは、 <xref:System.Web.UI.Control.OnBubbleEvent%2A>メソッドをオーバーライドすることにより、バブルイベントを処理または発生させることができます。  
  
   
  
## Examples  
 次のコード例は、カスタム`ChildControl`クラスを作成する方法を示しています。このメソッドを<xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType>オーバーライドし<xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType>て、イベントを親の ASP.NET サーバーコントロールに送信する<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>メソッドを呼び出します。 ユーザーがの`ChildControl`インスタンスを含む ASP.NET ページ内のボタンをクリックすると、の`ChildControl`インスタンスを<xref:System.Web.UI.Control.OnBubbleEvent%2A>含む親コントロールのメソッドが発生し、"childcontrol クラスの OnClick メソッドは"をページに対して呼び出します。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RemovedControl : System.Web.UI.Control -&gt; unit&#xA;override this.RemovedControl : System.Web.UI.Control -&gt; unit" Usage="control.RemovedControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">既に削除済みの <see cref="T:System.Web.UI.Control" />。</param>
        <summary><see cref="T:System.Web.UI.Control" /> オブジェクトの <see cref="P:System.Web.UI.Control.Controls" /> コレクションから子コントロールが削除された後に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、コントロールが<xref:System.Web.UI.Control.Controls%2A>コレクションから削除された直後に呼び出されます。 <xref:System.Web.UI.Control.RemovedControl%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">サーバー コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>提供されたクライアントに表示される内容を書き込む <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトに、サーバー コントロールの内容を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタムサーバーコントロールを開発する場合は、このメソッドをオーバーライドして、ASP.NET ページのコンテンツを生成できます。  
  
   
  
## Examples  
 メソッドを<xref:System.Web.UI.Control.Render%2A>オーバーライドするコード例を次に示します。 メソッドは、 <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>プロパティを介してアクセスできる<xref:System.Web.UI.ControlCollection>オブジェクトに、サーバーコントロールに子コントロールが格納されているかどうかを判断するために使用されます。 <xref:System.Web.UI.Control.HasControls%2A> が<xref:System.Web.UI.Control.HasControls%2A> true を返し、コレクション内の最初のサーバーコントロールがリテラルテキストの場合は、リテラルテキストが HTML 文字列に追加されます。  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">表示された内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>クライアントに表示される内容の書き込みを行う、指定された <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトに、サーバー コントロールの子を出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ページに Active Server ページ (ASP) コードを表示するように ASP.NET に通知します。 ページに ASP コードが存在しない場合、このメソッドはサーバーコントロールのすべての子コントロールを表示します。 このメソッドは、 <xref:System.Web.UI.Control.Render%2A>メソッドによって呼び出されます。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.RenderChildren%2A> 、カスタムサーバーコントロールのメソッドをオーバーライドします。 現在のコントロールに<xref:System.Web.UI.ControlCollection>オブジェクト内の子コントロールがあるかどうかを判断します。 存在する場合は、 <xref:System.Web.UI.ControlCollection.Count%2A>プロパティを使用してコレクションを反復処理します。 各子コントロールが検出されると、 <xref:System.Web.UI.Control.RenderControl%2A>メソッドを使用して、親コントロールとそのすべての子コントロールが、含んでいるページに表示されます。  
  
 オーバーライド<xref:System.Web.UI.Control.Render%2A>されたメソッドは、 <xref:System.Web.UI.Control.RenderChildren%2A>オーバーライドされたメソッドを呼び出します。  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サーバー コントロールの内容を出力し、トレースが有効である場合はコントロールに関するトレース情報を格納します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderControl writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>指定の <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトにサーバー コントロールの内容を出力し、トレースが有効である場合はコントロールに関するトレース情報を保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバーコントロールの<xref:System.Web.UI.Control.Visible%2A>プロパティがに`true`設定されている場合、このメソッドは、ページに対してトレースを有効にするかどうかを決定します。 その場合は、コントロールに関連付けられているトレース情報が格納され、ページにサーバーコントロールの内容が表示されます。  
  
 このメソッドは、レンダリング中にページによって自動的に呼び出されますが、カスタムコントロールの開発者がオーバーライドできます。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.RenderChildren%2A> 、カスタムサーバーコントロールのメソッドをオーバーライドします。 現在のコントロールに<xref:System.Web.UI.ControlCollection>オブジェクト内の子コントロールがあるかどうかを判断します。 存在する場合は、 <xref:System.Web.UI.ControlCollection.Count%2A>プロパティを使用してコレクションを反復処理します。 各子コントロールが検出されると、 <xref:System.Web.UI.Control.RenderControl%2A>メソッドを使用して、子コントロールとそのすべての子コントロールが、含んでいるページに表示されます。 このメソッドに渡される<xref:System.Web.UI.Page.Render%2A> オブジェクトは、メソッドによってインスタンス化されます。<xref:System.Web.UI.XhtmlTextWriter>  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="member this.RenderControl : System.Web.UI.HtmlTextWriter * System.Web.UI.Adapters.ControlAdapter -&gt; unit" Usage="control.RenderControl (writer, adapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="adapter">表示を定義する <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</param>
        <summary>指定した <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> オブジェクトを使用して、指定した <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトにサーバー コントロールの内容を出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web ページは、Web から情報を要求できる幅広いデバイスとブラウザーで使用できます。 プロパティ<xref:System.Web.UI.Control.Adapter%2A>は、要求<xref:System.Web.UI.Adapters.ControlAdapter>元のデバイスまたはブラウザーの画面でコントロールをレンダリングするオブジェクトを返します。  
  
 アダプターの詳細については、「[アダプティブコントロールの動作のアーキテクチャの概要](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))」を参照してください。  
  
 サーバーコントロールの<xref:System.Web.UI.Control.Visible%2A>プロパティがに`true`設定され、そのページでトレースが有効になっている場合、コントロールに関連付けられているトレース情報がキャプチャされます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>カスタムコントロールの<see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />メソッドをオーバーライドする場合は、基本クラスのメソッドを呼び出して、トレース情報が正しくキャプチャされるようにします。</para></block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">アダプティブコントロールの動作のアーキテクチャの概要</related>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingCompatibility : Version with get, set" Usage="System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レンダリングされる HTML と互換性がある ASP.NET のバージョンを表す値を取得します。</summary>
        <value>レンダリングされる HTML と互換性がある ASP.NET のバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET は、web.config ファイル内の`controlRenderingCompatibilityVersion` `pages`要素の属性の値にこのプロパティを設定します。 `controlRenderingCompatibilityVersion`属性が web.config ファイルで設定されていない場合、既定値は ASP.NET の現在のバージョンです。  
  
> [!CAUTION]
>  このプロパティにはパブリックな set アクセサーがありますが、set アクセサーは .NET Framework インフラストラクチャをサポートします。独自に作成したコードから直接使用するためのものではありません。 この値をコードで設定した場合、結果は予測できません。  
  
 ASP.NET の各リリースは、以前のリリースとは異なる方法で HTML を表示する場合があります。 たとえば、ASP.NET 3.5 で<xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>は、 <xref:System.Web.UI.WebControls.Label>コントロールのプロパティがの場合、 `false`既定`disabled`では、ASP.NET は属性`span`が "disabled" に設定されている要素をレンダリングします。 ASP.NET 4 では、既定`span`では、要素は`disabled`属性ではなくカスケードスタイルシート ( `class` CSS) 属性を使用してレンダリングされます。 これにより、コントロールの無効な外観を指定し、無効な HTML の表示を回避できます。 (HTML 4.0 および XHTML 1.1 `span`では、要素は属性を`disabled`サポートしていません)。  
  
 Web アプリケーションには、HTML レンダリングが変更された場合に正しく機能しない可能性のあるコードが含まれる場合があります。 この問題を回避するには、web.config `controlRenderingCompatibilityVersion`ファイルの`pages`要素の属性を設定して、互換性を維持する以前のバージョンを指定します。 たとえば、 <xref:System.Web.UI.Control.RenderingCompatibility%2A>プロパティをに`3.5`設定すると、無効になっ<xref:System.Web.UI.WebControls.Label>ているコントロールは`disabled` 、CSS クラスではなく、属性を表示します。  
  
> [!NOTE]
>  このプロパティを設定できる最も古いバージョンは`3.5`です。  
  
 下位互換性を維持するために、visual studio を使用して以前のバージョンの web プロジェクトを ASP.NET 4 にアップグレードすると、 `controlRenderingCompatibilityVersion` visual studio によって、web.config ファイル`3.5`の属性が自動的にに設定されます。 アップグレードした Web サイトで、ASP.NET 4 で導入されたアルゴリズムを使用して HTML を表示する場合は、 `controlRenderingCompatibilityVersion`属性を変更または削除できます。  
  
 ほとんどの場合、このプロパティによって制御される動作は自動であり、コード内の<xref:System.Web.UI.Control.RenderingCompatibility%2A>プロパティをチェックする必要はありません。 ただし、カスタムコントロールをプログラミングしている場合は、このプロパティの設定に基づいてコントロールの動作を変更するコードを含める必要があります。 たとえば、ASP.NET 4 のカスタムコントロールは<xref:System.Web.UI.WebControls.Label>コントロールで構成され、カスタムコントロールは、クラスを`aspNetDisabled`変更する JavaScript コードを生成することによって、コントロールの無効な外観を指定する場合があります。 これは、が<xref:System.Web.UI.Control.RenderingCompatibility%2A> `4.0`以降の場合に予想どおりに動作します。 ただし、 <xref:System.Web.UI.Control.RenderingCompatibility%2A>がの`3.5`場合と同じ効果が得られるように、 <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>プロパティが`false`の場合`CssClass` 、カスタムコントロールのコードでは、コントロールのプロパティを "aspNetDisabled" に設定する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberSignature Language="F#" Value="abstract member ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter&#xA;override this.ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter" Usage="control.ResolveAdapter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指定したコントロールを表示するコントロール アダプターを取得します。</summary>
        <returns>コントロールを表示する <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web ページは、Web からページを要求できる幅広いデバイスで表示できます。 メソッド<xref:System.Web.UI.Control.ResolveAdapter%2A>は、ASP.NET ページを要求した特定のブラウザーまたはデバイス上でコントロールを表示するコントロールアダプターを返します。  
  
 返される特定のアダプターの種類は、表示され<xref:System.Web.UI.Control>ているクラスの子孫の型によって異なります。  
  
 アダプターの詳細については、「[アダプティブコントロールの動作のアーキテクチャの概要](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="abstract member ResolveClientUrl : string -&gt; string&#xA;override this.ResolveClientUrl : string -&gt; string" Usage="control.ResolveClientUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">現在のページに相対的な URL。</param>
        <summary>ブラウザーで使用できる URL を取得します。</summary>
        <returns>ブラウザーで使用できる、指定したリソースへの完全修飾 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ResolveClientUrl%2A>メソッドを使用して、クライアントが Web サーバー上のリソースにアクセスするための適切な URL 文字列を返します。これには、イメージファイル、追加のページへのリンクなどがあります。  
  
> [!NOTE]
>  このメソッドによって返される URL は、コントロールがインスタンス化されるソースファイルが格納されているフォルダーに対する相対パスです。 <xref:System.Web.UI.UserControl> や<xref:System.Web.UI.MasterPage>など、このプロパティを継承するコントロールは、コントロールに対して相対的な完全修飾 URL を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeUrl" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="member this.ResolveUrl : string -&gt; string" Usage="control.ResolveUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl"><see cref="P:System.Web.UI.Control.TemplateSourceDirectory" /> プロパティに関連付けられた URL。</param>
        <summary>要求側クライアントで使用できる URL に変換します。</summary>
        <returns>変換後の URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーターに`relativeUrl`絶対 url が含まれている場合、url は変更されずに返されます。 パラメーターに`relativeUrl`相対 url が含まれている場合、その url は、ブラウザーが url を解決できるように、現在の要求パスに適した相対 url に変更されます。  
  
 たとえば、次の場合を考えてください。  
  
-   クライアントが、イメージが関連付けられているユーザーコントロールを含む ASP.NET ページを要求しました。  
  
-   ASP.NET ページは、/ストアにあります。  
  
-   ユーザーコントロールは/Store/UserControls/UC1.ascx. にあります。  
  
-   イメージファイルは/UserControls/Images/Image1.jpg. にあります。  
  
 ユーザーコントロールが、イメージへの相対パス (つまり、/Store/UserControls/Images/Image1.jpg) を<xref:System.Web.UI.Control.ResolveUrl%2A>メソッドに渡す場合、メソッドは値/images/image1.jpg」を返します。  
  
 このメソッドは、 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティを使用して、絶対 URL に解決します。 返される URL は、クライアントで使用されます。  
  
 Web サイトのリソースパスの詳細については、「 [ASP.NET Web Project paths](https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd)」を参照してください。  
  
> [!NOTE]
>  モバイル Web ページの場合にのみ、アプリケーションが cookie なしのセッションに依存しているか、cookie 以外のセッションを必要とするモバイル\~ブラウザーから要求を受信すると、パスでチルダ ("") を使用すると、誤って新しいセッションが作成される可能性があります。セッションデータが失われる可能性があります。 \~"/\~** <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> ** Path" などのパスを使用してプロパティを設定するには、プロパティに割り当てる前に、"path" などの引数を指定してを呼び出してパスを解決します。/  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.WebControls.Image> 、Web サーバーコントロールオブジェクトを作成<xref:System.Web.UI.Control.ResolveUrl%2A>し、メソッドを使用して、 <xref:System.Web.UI.WebControls.Image.ImageUrl%2A>プロパティによって格納されるイメージへのパスを設定します。  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeUrl" /> パラメーターが <see langword="null" /> を格納している場合に発生します。</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
        <related type="Article" href="https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd">ASP.NET Web サイトのパス</related>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveControlState : unit -&gt; obj&#xA;override this.SaveControlState : unit -&gt; obj" Usage="control.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生したすべてのサーバー コントロール状態の変化を保存します。</summary>
        <returns>サーバー コントロールの現在の状態を返します。 このコントロールに関連付けられている状態がない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.SaveControlState%2A>メソッドを使用して、特定のコントロールの操作に必要な状態情報を保存します。 このコントロールの状態データは、コントロールのビューステートデータとは別に格納されます。  
  
 コントロールの状態を使用するカスタムコントロール<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>は、コントロール<xref:System.Web.UI.Control.Page%2A>の状態を保存する前に、でメソッドを呼び出す必要があります。  
  
   
  
## Examples  
 次のコード例では<xref:System.Web.UI.Control.SaveControlState%2A> 、カスタム ASP.NET コントロールのメソッドをオーバーライドします。 このメソッドが呼び出されたときに、内部プロパティ`currentIndex`が既定値以外の値に設定されているかどうかを確認し、存在する場合は、コントロールの状態に値を保存します。  
  
 メソッドは、の<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを呼び出して、 <xref:System.Web.UI.Control.Page%2A>カスタムコントロールがコントロールの状態を使用することを示すためにオーバーライドされます。 <xref:System.Web.UI.Control.OnInit%2A>  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>コントロールの状態が保存されると、文字列オブジェクトが HTML <see langword="HIDDEN" />要素に格納されている変数としてクライアントに返されます。 コントロールで使用する状態情報を抽出するには、このメソッドをオーバーライドします。  
  
コントロールの状態は、ページインデックスやキーワードなど、少量の重要なデータを対象としています。 大量のデータに対してコントロールの状態を使用すると、ページのパフォーマンスに悪影響を及ぼす可能性があります。 詳細については、「 [ASP.NET State Management の概要](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))」を参照してください。</para></block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 状態管理の概要</related>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveViewState : unit -&gt; obj&#xA;override this.SaveViewState : unit -&gt; obj" Usage="control.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生した、サーバー コントロールのビューステートの変更を保存します。</summary>
        <returns>サーバー コントロールの現在のビューステートを返します。 コントロールに関連付けられているビューステートがない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビューステートは、サーバーコントロールのプロパティの値を累積したものです。 これらの値は、 <xref:System.Web.UI.Control.ViewState%2A> <xref:System.Web.UI.StateBag>クラスのインスタンスであるサーバーコントロールのプロパティに自動的に配置されます。 このプロパティの値は、サーバーコントロールのライフサイクルの状態の保存ステージの後に文字列オブジェクトに保存されます。 詳細については、「 [ASP.NET Page ライフサイクルの概要](https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991)」を参照してください。  
  
 ビューステートが保存されると、この文字列オブジェクトは、HTML `HIDDEN`要素に格納されている変数としてクライアントに返されます。 カスタムビューステートを使用してカスタムサーバーコントロールを作成する場合、ビューステートはメソッド<xref:System.Web.UI.Control.SaveViewState%2A>および<xref:System.Web.UI.Control.LoadViewState%2A>メソッドを使用して明示的に管理できます。 詳細については、「 [ASP.NET State Management の概要](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))」を参照してください。 カスタムセッション状態プロバイダーの実装の詳細については、「[セッション状態ストアプロバイダーの実装](https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66)」を参照してください。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.SaveViewState%2A> 、カスタム ASP.NET サーバーコントロールのメソッドをオーバーライドします。 このメソッドが呼び出されると、コントロールに子コントロールがあるかどうか、およびそれ<xref:System.Web.UI.Page>を含んでいるオブジェクトがポストバックの結果であるかどうかが判断されます。 両方とも true の場合は、 <xref:System.Web.UI.WebControls.Label.Text%2A> <xref:System.Web.UI.WebControls.Label> Web サーバーコントロールのプロパティを変更し`Custom Control Has Saved State`て読み取ります。 次に、コントロールのビューステートをという名前`allStates`のオブジェクトの配列として保存します。  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 状態管理の概要</related>
        <related type="Article" href="https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66">セッション状態ストアプロバイダーの実装</related>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetDesignModeState : System.Collections.IDictionary -&gt; unit&#xA;override this.SetDesignModeState : System.Collections.IDictionary -&gt; unit" Usage="control.SetDesignModeState data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data">コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>コントロールのデザイン時データを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド<xref:System.Web.UI.Control.SetDesignModeState%2A>は、コントロールのデザイン時データを保存します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>コントロールに必要なデザイン時データを保存するには、このメソッドをオーバーライドする必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberSignature Language="F#" Value="member this.SetRenderMethodDelegate : System.Web.UI.RenderMethod -&gt; unit" Usage="control.SetRenderMethodDelegate renderMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">サーバー コントロールを表示するためにデリゲートに渡す必要がある情報。</param>
        <summary>サーバー コントロールとその内容を親コントロールに表示するイベント ハンドラー デリゲートを割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、実装のためだけに用意されています。直接呼び出すことはできません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>レンダリング データのデザイン時トレースのトレース データを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj -&gt; unit" Usage="control.SetTraceData (traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">トレース データ キー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>トレース データ キーとトレース データ値を使用して、レンダリング データのデザイン時トレースのトレース データを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj * obj -&gt; unit" Usage="control.SetTraceData (tracedObject, traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataKey" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="tracedObject">トレースされたオブジェクト。</param>
        <param name="traceDataKey">トレース データ キー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>トレースされたオブジェクト、トレース データ キー、およびトレース データ値を使用して、レンダリング データのデザイン時トレースのトレース データを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デザイン サーフェイスに現在のコントロールを表示するときに、このコントロールをホストするコンテナーに関する情報を取得します。</summary>
        <value>コントロールをホストしているコンテナーに関する情報が格納されている <see cref="T:System.ComponentModel.ISite" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイトは、オブジェクト<xref:System.ComponentModel.Component>を<xref:System.ComponentModel.Container>オブジェクトにバインドし、2つの間の通信を可能にします。 また、コンテナーがそのコンポーネントを管理する方法も提供します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに適用するスキンを取得または設定します。</summary>
        <value>コントロールに適用するスキンの名前。 既定値は、<see cref="F:System.String.Empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールで使用できるスキンは、テーマディレクトリ内の1つ以上のスキンファイルに格納されます。 プロパティ<xref:System.Web.UI.Control.SkinID%2A>は、コントロールに適用するスキンのを指定します。 スキンは、特定のコントロールに固有のものです。異なる種類のコントロール間でスキン設定を共有することはできません。  
  
 <xref:System.Web.UI.Control.SkinID%2A>プロパティを設定しなかった場合、コントロールは既定のスキンを使用します (定義されている場合)。 たとえば、id のないスキンが<xref:System.Web.UI.WebControls.Image>コントロールに対して定義されている場合、そのスキンは、id でスキンを明示的に参照せず、テーマを無効に設定しないすべて<xref:System.Web.UI.WebControls.Image>のコントロールに適用されます。 Id を持つスキンが<xref:System.Web.UI.WebControls.Image>コントロールに対して定義されている場合、そのスキンは、その id に設定されているプロパティを持つ<xref:System.Web.UI.Control.SkinID%2A>コントロールに<xref:System.Web.UI.WebControls.Image>のみ適用されます。  
  
 テーマディレクトリ内のスキンファイルに、指定さ<xref:System.Web.UI.Control.SkinID%2A>れたプロパティを持つスキンが含まれていない場合は<xref:System.ArgumentException> 、実行時に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートが既に適用されています。  
  
- または - 
<see langword="Page_PreInit" /> イベントが既に発生しています。  
  
または 
コントロールが既に <see langword="Controls" /> コレクションに追加されました。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">ASP.NET テーマの概要</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System::Web::UI::IControlBuilderAccessor::ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの説明については、<see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" /> のトピックを参照してください。</summary>
        <value>コントロールを作成した <see cref="T:System.Web.UI.ControlBuilder" />。ビルダーが使用されなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlBuilderAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />」をご覧ください。</summary>
        <returns>コントロールの状態の <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data">コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>このメンバーの説明については、<see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" /> のトピックを参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="owner">コントロールの所有者。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 コントロールデザイナーは、このインターフェイスを使用して、コントロールに対してデザイン時のアクションを実行します。<xref:System.Web.UI.IControlDesignerAccessor>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="owner" /> が現在のコントロールに対して設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System::Web::UI::IControlDesignerAccessor::UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />」をご覧ください。</summary>
        <value>コントロールに関する情報が格納されている <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System::Web::UI::IDataBindingsAccessor::DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの説明については、<see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" /> のトピックを参照してください。</summary>
        <value>データ連結のコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IDataBindingsAccessor::HasDataBindings { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />」をご覧ください。</summary>
        <value>コントロールにデータ バインディング ロジックが含まれる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System::Web::UI::IExpressionsAccessor::Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />」をご覧ください。</summary>
        <value>コントロールのプロパティと式を表す <see cref="T:System.Web.UI.ExpressionBindingCollection" /> オブジェクトが格納された <see cref="T:System.Web.UI.ExpressionBinding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IExpressionsAccessor::HasExpressions { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />」をご覧ください。</summary>
        <value>コントロールに、式によって設定されるプロパティがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">追加するオブジェクト。</param>
        <summary>このメンバーの説明については、<see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" /> のトピックを参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IParserAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TemplateControl : System.Web.UI.TemplateControl with get, set" Usage="System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールを格納しているテンプレートへの参照を取得または設定します。</summary>
        <value>このコントロールを格納している <see cref="T:System.Web.UI.TemplateControl" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスがコントロールテンプレートの一部である場合<xref:System.Web.UI.Control.TemplateControl%2A> 、プロパティには、格納しているコントロールへの参照が格納されます。 <xref:System.Web.UI.Control> 詳細については、次を参照してください。、<xref:System.Web.UI.TemplateControl?displayProperty=nameWithType>ドキュメント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplateSourceDirectory : string" Usage="System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のサーバー コントロールを格納している <see cref="T:System.Web.UI.Page" /> または <see cref="T:System.Web.UI.UserControl" /> の仮想ディレクトリを取得します。</summary>
        <value>サーバー コントロールを格納しているページまたはユーザー コントロールの仮想ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>は、現在のコントロールを格納しているページまたはユーザーコントロールへのパスを指定します。 たとえば、Web ページがに`http://www.contoso.com/application/subdirectory`存在する場合、プロパティは<xref:System.Web.UI.Control.TemplateSourceDirectory%2A> "application/サブディレクトリ" を返します。  
  
 アプリケーション相対仮想パス ("~/サブディレクトリ") を返すには、 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>プロパティを使用します。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 、プロパティを2回使用します。 <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType>メソッド呼び出しで初めて使用されるときに、コントロールが存在するディレクトリへのパスを取得します。 2回目の<xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType>メソッド呼び出しで、そのディレクトリ内に含まれるすべてのファイルの一覧を取得します。  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberSignature Language="F#" Value="abstract member TrackViewState : unit -&gt; unit&#xA;override this.TrackViewState : unit -&gt; unit" Usage="control.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールにビューステートの変更を追跡させ、サーバー コントロールの <see cref="T:System.Web.UI.StateBag" /> オブジェクトに変更を格納できるようにします。 このオブジェクトは、<see cref="P:System.Web.UI.Control.ViewState" /> プロパティによってアクセスできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、サーバーコントロールのライフサイクルで<xref:System.Web.UI.Control.Init>イベントの最後に自動的に呼び出されます。  
  
 このメソッドは、テンプレート化されたデータバインドコントロールを開発するときに呼び出します。 このメソッドは、ASP.NET に警告して<xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType> 、サーバーコントロールのビューステートの変更を監視します。これは、メソッドをオーバーライドするときに必要です。  
  
   
  
## Examples  
 次の例では<xref:System.Web.UI.Control.DataBind%2A> 、カスタム ASP.NET サーバーコントロールのメソッドをオーバーライドします。 まず、基本<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドを呼び出してから、 <xref:System.Web.UI.ControlCollection.Clear%2A>メソッドを使用してすべて<xref:System.Web.UI.Control.ClearChildViewState%2A>の子コントロールを削除し、メソッドを使用して、これらの子コントロールの保存されているビューステートの設定を削除します。 最後に、 <xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティがに`true`設定されます。 コントロールは、プロパティを<xref:System.Web.UI.Control.IsTrackingViewState%2A>使用して、コントロールに対してビューステート変更の追跡が有効になっているかどうかを判断します。 有効になっ<xref:System.Web.UI.Control.TrackViewState%2A>ていない場合は、メソッドが呼び出されます。  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueID : string" Usage="System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>階層構造で修飾されたサーバー コントロールの一意の ID を取得します。</summary>
        <value>サーバー コントロールの完全修飾 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、プロパティ<xref:System.Web.UI.Control.ID%2A>にサーバーコントロールの名前<xref:System.Web.UI.Control.UniqueID%2A>付けコンテナーの識別子が含まれている点で、プロパティとは異なります。 この識別子は、ページ要求が処理されるときに自動的に生成されます。  
  
 このプロパティは、繰り返されるデータバインディングサーバーコントロール内に含まれるサーバーコントロールを区別するために特に重要です。 繰り返しコントロール<xref:System.Web.UI.WebControls.Repeater>( <xref:System.Web.UI.WebControls.DataList> 、<xref:System.Web.UI.WebControls.DetailsView> <xref:System.Web.UI.WebControls.GridView> 、、、および Web サーバーコントロール) (または、データバインド時に繰り返し機能を含む、作成したカスタムサーバーコントロール) は、次のように機能します。 <xref:System.Web.UI.WebControls.FormView>子コントロールのコンテナーに名前を付けます。 これは、その子コントロールに対して一意の名前空間を作成<xref:System.Web.UI.Control.ID%2A>し、そのプロパティ値が競合しないようにすることを意味します。  
  
 <xref:System.Web.UI.WebControls.Label>たとえば、ASP.NET Web サーバーコントロールを<xref:System.Web.UI.WebControls.Repeater>サーバーコントロールに追加<xref:System.Web.UI.Control.ID%2A>し、 <xref:System.Web.UI.WebControls.Repeater>コントロールに<xref:System.Web.UI.WebControls.Label>というプロパティ値`MyLabel` <xref:System.Web.UI.Control.ID%2A>を割り当て、次のようにします`MyRepeater`。 3つのエントリを持つ<xref:System.Web.UI.WebControls.Repeater> <xref:System.Collections.ArrayList>オブジェクトにデータをバインドする場合、 <xref:System.Web.UI.WebControls.Label>サーバー <xref:System.Web.UI.Control.UniqueID%2A>コントロールの各インスタンスに対して生成さ`MyRepeater$ctl00$MyLabel`れる`MyRepeater$ctl01$MyLabel`プロパティは`MyRepeater$ctl02$MyLabel`、、およびです。  
  
   
  
## Examples  
 次の例では<xref:System.Collections.ArrayList> 、オブジェクトを作成し、3つのテキスト文字列を<xref:System.Web.UI.WebControls.Repeater>設定します。次に、ページ<xref:System.Collections.ArrayList>が読み込まれるときに、Web サーバーコントロールを内のデータにバインドします。 このコードは、 <xref:System.Web.UI.Control.UniqueID%2A>データバインディング中に生成された各子コントロールのプロパティを取得します。 このコードは、3つの<xref:System.Web.UI.WebControls.Label>バージョンのコントロールを`UniqueID`生成し、そのプロパティ値をページに書き込みます。  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : EventHandler " Usage="member this.Unload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがメモリからアンロードされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバーコントロールは、インスタンスがアンロードされる前に、コントロールのライフサイクルのこの段階で、ファイルのクローズ、データベース接続、オブジェクトの破棄など、最終的なクリーンアップを実行する必要があります。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET ページのライフサイクルの概要</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーからのクライアント入力の安全性をコントロールで調べるかどうかを示す値を取得または設定します。</summary>
        <value>コントロールがクライアントの入力をチェックするかどうかを決定する値。 使用できる値には <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />、および <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" /> があります。 既定値は <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" /> で、コントロールが親から値を取得することを意味します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求の検証の詳細について<xref:System.Web.UnvalidatedRequestValues>は、「」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewState : System.Web.UI.StateBag" Usage="System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同一のページに対する複数の要求にわたって、サーバー コントロールのビューステートを保存し、復元できるようにする状態情報のディクショナリを取得します。</summary>
        <value>サーバー コントロールのビューステートの情報を格納している <see cref="T:System.Web.UI.StateBag" /> クラスのインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバーコントロールのビューステートは、すべてのプロパティ値を累積したものです。 これらの値を HTTP 要求間で保持するために、ASP.NET サーバーコントロールは、 <xref:System.Web.UI.StateBag>クラスのインスタンスであるこのプロパティを使用して、プロパティ値を格納します。 値は、後続の要求が処理されるときに、HTML 非表示の input 要素に変数として渡されます。 サーバーコントロールのビューステートを保存する方法の詳細については、「 [ASP.NET State Management の概要](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))」を参照してください。  
  
 既定では、すべてのサーバーコントロールに対してビューステートが有効になっていますが、無効にする必要がある状況もあります。 詳細については、「 [ASP.NET Performance の概要](https://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b)」を参照してください。  
  
 ディクショナリとその使用方法の詳細については、「[コレクションとデータ構造体](~/docs/standard/collections/index.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、 `Text`コントロールの<xref:System.Web.UI.Control.ViewState%2A>プロパティから値を格納して取得するプロパティを実装する方法を示します。  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 状態管理の概要</related>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateIgnoresCase : bool" Usage="System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.StateBag" /> オブジェクトが大文字小文字を区別しないかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Web.UI.StateBag" /> インスタンスが大文字小文字を区別しない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大文字小文字を考慮せずにビューステートを保存するカスタムサーバーコントロールを作成する場合は、このメソッドをオーバーライドします。 同じキーを持つ複数のオブジェクトを使用する場合、大文字と小文字が異なると、 <xref:System.Web.UI.StateBag>は<xref:System.Web.UI.Control.ViewState%2A>プロパティに関連付けられたに格納できます。  
  
   
  
## Examples  
 次の例は、 <xref:System.Web.UI.Control.ViewStateIgnoresCase%2A>プロパティをオーバーライドしてを返す`true`方法を示しています。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateMode : System.Web.UI.ViewStateMode with get, set" Usage="System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのビューステート モードを取得または設定します。</summary>
        <value>このコントロールのビューステート モード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ViewStateMode%2A>プロパティを使用すると、ページのビューステートが無効になっている場合でも、個々のコントロールのビューステートを有効にすることができます。 ビューステートとコントロールの状態の詳細については<xref:System.Web.UI.Control.EnableViewState%2A> 、プロパティを参照してください。  
  
 ページのビューステートを無効にして、ページの特定のコントロールに対して有効にする<xref:System.Web.UI.Control.EnableViewState%2A>には、ページのプロパティとコントロール`true`をに<xref:System.Web.UI.Control.ViewStateMode%2A>設定し、ページ<xref:System.Web.UI.ViewStateMode.Disabled> <xref:System.Web.UI.Control.ViewStateMode%2A>のプロパティをに設定し、のプロパティを設定します。をに<xref:System.Web.UI.ViewStateMode.Enabled>制御します。  
  
 ページの<xref:System.Web.UI.Control.ViewStateMode%2A>プロパティの既定値は<xref:System.Web.UI.ViewStateMode.Enabled>です。 ページ内の Web サーバー <xref:System.Web.UI.Control.ViewStateMode%2A>コントロールのプロパティの既定値は<xref:System.Web.UI.ViewStateMode.Inherit>です。 その結果、ページまたはコントロールレベルでこのプロパティを設定しなかった場合、 <xref:System.Web.UI.Control.EnableViewState%2A>プロパティの値によってビューステートの動作が決定されます。  
  
 ページまたはコントロールの<xref:System.Web.UI.Control.EnableViewState%2A> `true`プロパティは、プロパティがに設定されている場合にのみ効果<xref:System.Web.UI.Control.ViewStateMode%2A>があります。 プロパティがに`false`設定されている場合、 <xref:System.Web.UI.Control.ViewStateMode%2A>プロパティがに<xref:System.Web.UI.ViewStateMode.Enabled>設定されていても、ビューステートはオフになります。 <xref:System.Web.UI.Control.EnableViewState%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このプロパティを <see cref="T:System.Web.UI.ViewStateMode" /> 列挙値にない値に設定しようとしました。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/75x4ha6s(v=vs.100)">ASP.NET 状態管理の概要</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb386448(v%3dvs.100)">ASP.NET ビューステートの概要</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cteh3e77(v=vs.100)">ビューステートの制御</related>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがページ上の UI としてレンダリングされているかどうかを示す値を取得または設定します。</summary>
        <value>コントロールをページに表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが`false`の場合、サーバーコントロールはレンダリングされません。 ページのレイアウトを整理する際には、このことを考慮する必要があります。  
  
> [!NOTE]
>  コンテナーコントロールがレンダリングされない場合、個々のコントロールの<xref:System.Web.UI.Control.Visible%2A>プロパティをに`true`設定しても、コンテナーコントロールに含まれるコントロールは表示されません。 その場合、明示的にに`false` `true`設定した<xref:System.Web.UI.Control.Visible%2A>場合でも、個々のコントロールはプロパティに対してを返します。 (つまり、親コントロールの`Visible`プロパティがに`false`設定されている場合、子コントロールはその設定を継承し、設定はローカル設定よりも優先されます)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
