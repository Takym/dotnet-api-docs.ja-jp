<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="756a688304d910ca2afe1de75ffeac595896e11f" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78734199" /></Metadata><TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Web パーツのコントロール、機能、および Web ページ上で発生するイベントのすべてを管理する、Web パーツ コントロール セットの中心的なクラスとして機能します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、Web パーツアプリケーションのハブまたはコントロールセンターとして機能します。 Web パーツコントロールを使用する各ページには、1つの<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールインスタンスのみが必要です。 Web パーツアプリケーションのほとんどの側面と同様に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは認証されたユーザーに対してのみ機能します。 さらに、その機能は、<xref:System.Web.UI.WebControls.WebParts.WebZone> クラスを継承する Web パーツゾーン内に存在するサーバーコントロールとほぼ同じように機能します。 これらのゾーンの外部にあるページに配置されているサーバーコントロールは、Web パーツ機能がほとんどなく、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールとの対話も可能です。  
  
 ページの Web パーツ機能のハブとして、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、次の表で説明するタスクの種類を実行します。  
  
|タスクのカテゴリ|コントロールの動作|  
|-------------------|---------------------------|  
|Web パーツコントロールの追跡|<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、接続、ゾーンなどの Web パーツ機能を提供する、ページ上のさまざまな種類のコントロールを追跡します。|  
|Web パーツコントロールの追加と削除|ページ上のコントロールを追加、削除、および <xref:System.Web.UI.WebControls.WebParts.WebPart> 閉じるためのメソッドを提供します。|  
|接続の管理|コントロール間の接続を作成し、接続を監視します。また、接続を追加および削除するプロセスも監視します。|  
|コントロールとページのカスタマイズ|ユーザーがコントロールをページ上の別の場所に移動し、ユーザーがコントロールの外観、プロパティ、および動作を編集できるビューを起動できるようにします。 では、各ページにユーザー固有のパーソナル化の設定が保持されます。|  
|切り替え (異なるページビューを)|ページレイアウトの変更やコントロールの編集などの特定のタスクをユーザーが実行できるように、ページを異なる特別なビューに切り替えます。|  
|Web パーツのライフサイクルイベントの発生|開発者は、コントロールが追加、移動、接続、または削除されたときなど、Web パーツコントロールのライフサイクルイベントを処理できます。|  
|コントロールのインポートとエクスポートを有効にする|<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのプロパティの状態を含む XML ストリームをエクスポートし、ユーザーがファイルをインポートして、他のページやサイトの複雑なコントロールをカスタマイズする場合に便利です。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスには、多数のプロパティがあります。 他のコントロールを追跡するための <xref:System.Web.UI.WebControls.WebParts.WebPartManager> の役割と一貫性のある、Web パーツコントロールのコレクションまたはその他の特殊な Web パーツオブジェクトを参照する多くのプロパティがあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> の各プロパティは、追跡およびその他の管理タスクのために <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって使用されるすべてのコレクションです。  
  
 別のプロパティグループには、Web パーツアプリケーションで発生する特定のシナリオに適用されるカスタマイズ可能な警告が含まれています。 これには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> プロパティが含まれます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスは、多くの Web サーバーコントロールで使用される基本継承プロパティの一部をオーバーライドします。 これには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> の各プロパティが含まれます。  
  
 最後に、アプリケーションの現在の状態にアクセスするのに役立つプロパティのグループがあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティは、ページの現在の表示モードを示します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> プロパティは、コントロールがクライアント側スクリプトのレンダリングを許可されているかどうかを示します。これは、ユーザーがさまざまな機能を持つブラウザーを使用している場合や、スクリプトが無効になっている場合に関連します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> プロパティは、拡張ケースに使用される重要な Web パーツメソッドの多くの呼び出しを含むユーティリティクラスを参照する場合に便利です。 これらのメソッドの呼び出しを別のクラス (<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> クラス) で非表示にすることにより、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの独自の API が簡略化されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティは、ユーザーのパーソナル化設定を格納し、そのデータを永続的なストレージに保持するパーソナル化オブジェクトへのアクセスを提供します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> プロパティは、ユーザーまたはアプリケーションによって現在選択されているページの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを示します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール上のカスタムのパーソナル化データが変更されたかどうかを示します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールには、5つの組み込みの表示モード、または Web ページのビューが含まれています。 開発者は、この機能を拡張して、<xref:System.Web.UI.WebControls.WebParts.WebZone> クラスや <xref:System.Web.UI.WebControls.WebParts.ToolZone> クラスなどの型を拡張することで、カスタム表示モードを作成できます。 特定の表示モードに対応する適切な種類のコントロールがページに存在する場合は、ユーザーがページをさまざまな表示モードに切り替えることができます。  
  
> [!NOTE]
>  この機能を拡張して、ユーザーがページに対応するゾーンがなくてもカスタム表示モードに切り替えることができるようにすることができます。 ただし、既定の動作では、表示モードはゾーンに対応しています。  
  
 標準表示モードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスのパブリックフィールドによって表されます。 次の表は、フィールドとそれらが参照する表示モードをまとめたものです。 前に説明したように、ページの現在の表示モードは常に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティで参照されます。また、ページに存在するゾーンの種類に応じて、特定のページで使用できる表示モードのセットは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティに含まれています。  
  
|フィールド|表示モードの詳細|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|Web ページの通常のユーザービュー。既定と最も一般的な表示モード。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|ページレイアウトを変更するためにユーザーがコントロールを再配置または削除できるビュー。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|編集中のユーザーインターフェイス (UI) が表示されるビュー。ユーザーは、通常のブラウズモードで表示されるコントロールの外観、プロパティ、および動作を編集できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|カタログ UI が表示されるビュー。ユーザーは、使用可能なコントロールのカタログからページにコントロールを追加できます。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|接続 UI が表示されるビュー。ユーザーは、コントロール間の接続、管理、または接続解除を行うことができます。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールには、Web パーツページとコントロールのライフサイクルに不可欠な多数のイベントも含まれています。 これらのイベントにより、Web パーツコントロールの動作をプログラムによって細かく制御できます。 ほとんどのメソッドは、コントロール (または <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに配置されている他のサーバーコントロールまたはユーザーコントロール) <xref:System.Web.UI.WebControls.WebParts.WebPart> に直接関係し、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとして動作するようにします。 ただし、いくつかのイベントは、ページ上のページまたは接続の状態に関連しています。 次の表は、使用可能なイベントの一覧とその用途をまとめたものです。  
  
> [!NOTE]
>  次の表のいずれの場合も、"コントロール" という単語は、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールまたはゾーン内に存在し、実行時に <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトでラップされたサーバーコントロールを指します。  
  
|イベント|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|コントロールがページに追加される直前に発生し、承認されていることを確認します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|ページ上のすべての接続がアクティブになった後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|ページ上のすべての接続をアクティブ化するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|ページの現在の表示モードが変更された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|ページの表示モードを変更するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|コントロールの選択が取り消された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|コントロールの選択をキャンセルするプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|コントロールがゾーンに追加された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|コントロールをゾーンに追加するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|コントロールが閉じられた (ページから削除された) 後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|コントロールを閉じるプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|動的コントロールのインスタンス (プログラムによって作成された、またはカタログから追加されたもの) が完全に削除された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|動的コントロールを削除するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|コントロールがゾーン内または別のゾーン内で移動された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|コントロールを移動するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|接続に参加するために選択された2つのコントロールが接続を確立した後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|2つのコントロールを接続するプロセスの直前に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|接続されている2つのコントロールが切断された後に発生します。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|2つのコントロールを切断するプロセスの直前に発生します。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールには、Web パーツページを管理するためのさまざまなメソッドがあります。 ここに記載されていないメソッドの大きなセットは、名前が*EventName*の形式であるメソッドです。 これらのメソッドは、通常、関連付けられたイベントを発生させ、イベントに <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>型のハンドラーを提供します。 これらのメソッドのほとんどは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを継承する開発者がオーバーライドできます。 また、ページ開発者は、これらのメソッドに関連付けられたイベントのカスタムハンドラーを提供できます。 たとえば、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントの場合、ページ開発者は Web ページのマークアップの `<asp:webpartmanager>` 要素に `OnWebPartAdded` 属性を追加し、カスタムメソッド名を属性に割り当てて、イベントのカスタム処理を提供できます。 属性は <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> メソッドに対応しています。この基本的なパターンのイベント処理は、ほとんどの Web パーツイベントとそれに関連するメソッドに対して機能します。  
  
 さらに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールには、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール (および <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとして使用されるサーバーコントロールまたはユーザーコントロール) を管理するためのタスクに固有のメソッドがあります。 これらのメソッドには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>が含まれます。  
  
 別のメソッドセットは、接続に特化しています。 これには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>などのメソッドが含まれます。  
  
 最後に、いくつかの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> メソッドは、パーソナル化機能に重点を置いています。 これらのメソッドには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> が含まれます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> プロパティを使用してアクセスできるその他の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> メソッドの詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> クラスのドキュメントを参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの宣言型の使用とプログラムによる使用の両方を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと、`<asp:webpartmanager>` 要素を含む Web ページ。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 ユーザーコントロールにはドロップダウンリストコントロールがあります。このコントロールには、ページ上に存在する Web パーツコントロールがある場合に、使用可能な表示モードが表示されます。 このコード例の Web ページでは、このユーザーコントロールはページのマークアップ内の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 要素のすぐ下に宣言され、Web ページの上部付近に `Register` ディレクティブがあり、コントロールが登録されます。 このコントロールの表示モードとソースコードの説明の詳細については、「[チュートリアル: Web パーツページの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 Web ページの宣言型マークアップには、ユーザーコントロールとカスタムコントロールの両方の `Register` ディレクティブが含まれています。 `<asp:webpartmanager>` 要素、カスタムコントロールを格納する `<asp:webpartzone>` 要素、および `<asp:connectionszone>` 要素があります。 このページには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの接続に関連するイベントを処理するインラインコードも含まれています。コントロールに接続したり切断したりすると、このコードの効果を確認できます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 `IZipCode`という名前のインターフェイスが存在し、このインターフェイスが `ZipCodeWebPart` クラスに実装されていることに注意してください。 このクラスには、プロバイダーとして機能する `ProvideIZipCode` という名前の特殊なコールバックメソッドがあります。 もう1つの型は、`WeatherWebPart`という名前の特殊な `GetIZipCode`メソッドを使用して実装されます。これにより、コントロールは他のコントロールのコンシューマーとして機能することができます。  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、ソースがアセンブリにコンパイルされており、Web ページの `Register` ディレクティブがアセンブリ名を参照していることを前提としています。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは、`<asp:connectionszone>` 要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続 UI が表示されたら、**[コンシューマーへの接続の作成]** リンクをクリックします。 ドロップダウンリストコントロールを持つセルが表示されます。 ドロップダウンリストで **[気象制御]** を選択し、**[接続]** をクリックして2つのコントロールの接続を完了します。 **[閉じる]** をクリックし、**[表示モード]** ドロップダウンリストを使用して、ページを通常ブラウズモードに戻します。 郵便番号を入力すると、コンシューマーコントロールが入力した値で更新されます。 `ZipCode` プロパティはソースコードの `Personalizable` 属性でマークされているため、このプロパティ値はブラウザーセッション間で保持されるため、ユーザーが入力した値が保存されます。 より洗練されたコンシューマーコントロールは、郵便番号情報を取得し、コードに基づいて気象情報を参照し、ユーザーに表示することができます。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールは拡張されるように設計されています。 Web パーツアプリケーションの中心となるため、Web パーツコントロールセット内の特定の型またはコントロールを拡張する場合は、多くの場合、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスも拡張する必要があります。これは、カスタム型を Web パーツアプリケーションのコンテキストで動作させるために必要なプロパティまたはメソッドがある可能性があるためです。 Web パーツリファレンスドキュメント (<see cref="N:System.Web.UI.WebControls.WebParts" />を参照) は、Web パーツ型を拡張する方法について説明するときに、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを拡張するために実行する必要があること、およびコード例で拡張する方法を示します。</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> コンストラクターは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって使用されるいくつかの重要な変数を初期化します。 すべての Web パーツページに直接影響する割り当ての1つは、既定のページ表示モードが参照モード (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>) に設定されていることです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web ページ上で現在アクティブでないすべての接続をアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> と <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに存在する他のサーバーコントロールとの間の既存の接続をアクティブ化するために、ページへの各要求に対して呼び出されます。 場合によっては、アクティブ化されている接続に競合がある場合、このメソッドは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドを呼び出して、問題のある接続を終了します。 切断プロセス中に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントが発生します。 通常、開発者はこのイベントを取り消すことができますが、接続のアクティブ化プロセスを完了するには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールで競合を解決する必要があるため、接続の間で競合が発生する可能性があります。 詳細については、「<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベント」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddWebPart (webPart As WebPart, zone As WebPartZoneBase, zoneIndex As Integer) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">Web ページに追加するか、ページ上で開く <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (あるいは、サーバー コントロールまたはユーザー コントロール)。</param>
        <param name="zone"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> の追加先となる <paramref name="webPart" />。</param>
        <param name="zoneIndex"><paramref name="webPart" /> 内の他のコントロールに対して <paramref name="zone" /> 内で <paramref name="zone" /> が占める序数位置を表す整数。</param>
        <summary>Web ページにプログラムで <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを追加する標準メソッドを提供します。</summary>
        <returns>ページに追加された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドは、新しい動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをページに追加し、以前にページで閉じられていた静的または動的コントロールを再び開くために使用されます。 新しいコントロールを追加するためにメソッドが呼び出されると、実際には `webPart` パラメーターで参照されるコントロールのコピーが作成されます。 コントロールのコピー用に新しい ID が生成されるため、開発者は、メソッドから返された <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを参照して、新しい ID 値を取得する必要があります。 以前に閉じられたコントロールを再び開くためにメソッドが呼び出されると、`webPart` パラメーターによって参照されるコントロールへの直接参照が返されます。  
  
> [!IMPORTANT]
>  <xref:System.Web.UI.ControlCollection.Add%2A> メソッドを使用すると例外がスローされるため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> プロパティによって参照されるコントロールのコレクションの <xref:System.Web.UI.ControlCollection.Add%2A> メソッドではなく、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドを使用して、プログラムによって <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをページに追加する必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではないコントロール (つまり、実行時に <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールと共にラップされるサーバーコントロール) を追加するには、まず <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドを呼び出してコントロールを作成し、次に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドを呼び出してコントロールを追加する必要があります。 この方法のデモについては、「例」のセクションを参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドを使用して、ページにプログラムによってサーバーコントロールを追加する方法を示しています。 ページマークアップには、空の `<asp:webpartzone>` 要素と `<asp:webpartmanager>` 要素が含まれています。 **[カレンダーの追加]** ボタンを初めてクリックすると、イベントハンドラーのコードによって <xref:System.Web.UI.WebControls.Calendar> コントロールが作成され、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドを呼び出して、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトとしてゾーンに追加されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。  
  
または 
 <paramref name="zone" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="zone" /> が、ゾーンの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのコレクションに登録されていません。  
  
または 
 <paramref name="webPart" /> は、既に <paramref name="zone" /> にあります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> の値が 0 未満です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> メソッドを呼び出すと発生し、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールをページに追加できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールがページに追加されるたびに発生します。 コントロールをページに追加できる一般的なシナリオがいくつかあります。 これらの詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドの「解説」を参照してください。 コントロールが追加されたときに、そのコントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが設定されているかどうかを確認し、存在する場合は、コントロールをページに追加する権限があるかどうかを確認する必要があります。  
  
 開発者は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントのイベントハンドラーを作成して、コントロールのフィルター処理を提供できます。 コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ値がイベントハンドラーコードの条件を満たさない場合、コントロールはページに追加されません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントのカスタムイベントハンドラーを設定する方法を示しています。これにより、既定の <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドが自動的にオーバーライドされます。  
  
 `mgr1_AuthorizeWebPart` メソッドのコードは、ページ上のコントロールのそれぞれの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ値が `user` に設定されているかどうかを確認し、存在する場合は `true`を返します。これは、それらが承認され、ページに追加されることを意味します。 これは、ユーザーのパーソナル化スコープのページでコントロールを表示できるようにするための既定の方法であることを前提としています。 ただし、この例では、コントロールの1つに <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ値が `admin`に設定されています。 開発者は、管理ユーザーのみが表示できるように設計された特殊なコントロールにこのフィルターを配置できます。 このコントロールは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベント中の承認チェックに失敗し、表示されません。 プロパティが設定されていないコントロールも表示されることに注意してください。<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> のプロパティが設定されていないため、フィルター処理のシナリオに含まれないものと想定されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの間に Web パーツ接続を作成する場合に使用できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトのコレクションを取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> メソッドを使用してコレクションを作成します。 既定では、アプリケーション構成ファイルから使用可能なトランスフォーマーが読み取られます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100)">Web パーツ接続の概要</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginWebPartConnecting (webPart As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続を構成するコントロール。</param>
        <summary>2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを接続するプロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> メソッドは、コントロール間の接続を形成するプロセスを個別の段階で実行できるようにするため、開発者は接続プロセスをより細かく制御できます。 メソッドは、初期チェックのセットを実行して、`webPart` が接続が正しく形成される状態であることを確認します。 `webPart` がすべてのチェックに合格した場合は、現在選択されているコントロールとして設定され (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> のプロパティを参照)、接続プロセスを続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ページ上の現在の表示モードが <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" /> ではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> は閉じています。  
  
または 
 <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションの一部ではありません。  
  
または 
 <paramref name="webPart" /> と <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールが等価です。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールを拡張する必要がある開発者は、派生クラスでこのメソッドをオーバーライドすることが必要になる場合があります。 1つの方法は、基本メソッドを呼び出して、追加のカスタム処理を追加することです。または、コントロール間の接続を開始するプロセスを完全にカスタマイズすることもできます。 たとえば、接続を作成する前に特定のデータが使用可能であることを確認することができます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginWebPartEditing (webPart As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">編集対象のコントロール。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを編集するプロセスを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> メソッドは、コントロールを編集するプロセスを個別の段階で実行できるようにするため、開発者はプロセスをより細かく制御できます。 メソッドは、初期チェックのセットを実行して、`webPart` が編集可能な状態であることを確認します。 `webPart` がすべてのチェックに合格した場合は、現在選択されているコントロールとして設定され (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> のプロパティを参照)、編集プロセスを続行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">ページ上の現在の表示モードが <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" /> ではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> は閉じています。  
  
または 
 <paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクションの一部ではありません。  
  
または 
 <paramref name="webPart" /> と <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールが等価です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールが含まれたページの既定の表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> フィールドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって作成および格納されるカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> オブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせずに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを使用して直接参照できます。  
  
 Web パーツコントロールを含むページが最初に読み込まれるとき、既定では <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (ブラウズモード) になります。 通常の Web ページの場合と同じようにユーザーが参照するだけの場合、ページはブラウズモードのままになります。 ユーザーがページのレイアウト、コントロール、外観、または動作をカスタマイズする場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティを通じて使用できる特殊な表示モードのいずれかにページを切り替える必要があります。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> フィールドをプログラムによって操作する方法を示します。 このコードは、サポートされている表示モードを使用してドロップダウンリストを設定します。この例では、参照とデザインが使用されています。 `Page_PreRender` メソッドで、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>に設定されているかどうかがコードによってチェックされることに注意してください。 その場合、`Label1` が表示されます。存在しない場合、`Label1` は非表示になります。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 閲覧モードになっていることを示すラベルがページに表示されます。 ドロップダウンリストコントロールを使用して、ページをデザインモードに切り替えます。 `Page_PreRender` メソッドのコードにより、ラベルが非表示になっていることに注意してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをチェックし、こうしたコントロールを接続できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドは、2つの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを接続できるかどうかを判断するために使用されます。 メソッドは、通常、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドを呼び出す前に条件チェックとして使用されます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドは、2つのコントロールが接続を形成する前に満たす必要があるいくつかの条件をチェックします。 次の一覧は、接続を確立するための主要な基準をまとめたものです。 これらのすべての条件 (およびその他の内部条件も含む) が満たされた場合、メソッドは `true`を返します。これは、コントロールを接続できることを意味します。  
  
-   プロバイダーコントロールとコンシューマーコントロールは `null`できず、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティによって参照されるコントロールのコレクションに格納されている必要があります。  
  
-   プロバイダーとコンシューマーを同じコントロールにすることはできません。 つまり、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール自体に接続することはできません。  
  
-   プロバイダーとコンシューマーの両方の <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> オブジェクト (接続ポイント) を `null`することはできません。  
  
-   プロバイダーとコンシューマーを閉じることはできません (コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> プロパティはどちらも `true`できません)。  
  
-   接続ポイントコントロールの <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> プロパティは、コンシューマーとプロバイダーの両方のコントロールの型と一致している必要があります。  
  
-   接続ポイントは両方とも有効になっている必要があります (<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> メソッドは両方とも `true`を返す必要があります)。  
  
-   各接続ポイントは、独自の <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> プロパティで指定されている数よりも多くの接続を形成することはできません。  
  
-   互換性のないコントロールを接続するために <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクト (トランスフォーマー) が必要な場合は、`null`することはできません。 ただし、コントロールに既に互換性がある場合は、トランスフォーマーを `null`する必要があります。  
  
-   トランスフォーマー (使用されている場合) は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> コレクションで参照される必要があります。  
  
-   トランスフォーマー (使用されている場合) には、2つのコントロール間でデータを変換できるように、プロバイダーとコンシューマーと互換性のあるインターフェイスが必要です。 コンシューマーとプロバイダーのセカンダリインターフェイスにも互換性がある必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanConnectWebParts (provider As WebPart, providerConnectionPoint As ProviderConnectionPoint, consumer As WebPart, consumerConnectionPoint As ConsumerConnectionPoint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">コントロールを接続したときに、<paramref name="consumer" /> にデータを提供するコントロール。</param>
        <param name="providerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> が接続に関与できるようにする <paramref name="provider" />。</param>
        <param name="consumer">コントロールを接続したときに、<paramref name="provider" /> からデータを受け取るコントロール。</param>
        <param name="consumerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> が接続に関与できるように、コールバック メソッドとして機能する <paramref name="consumer" />。</param>
        <summary>コンシューマー コントロールとプロバイダー コントロールが互換性のあるインターフェイスを持ち、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトが不要な場合に、接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> コントロールをチェックし、こうしたコントロールを接続できるかどうかを判断します。</summary>
        <returns><paramref name="provider" /> と <paramref name="consumer" /> を接続できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、両方のコントロールに互換性のある接続ポイントの種類があり、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトが必要ない場合に、`provider` と `consumer` に接続するために使用されます。 このメソッドを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> を呼び出してプログラムによる接続を作成する前に、2つのコントロールを接続できることを確認することができます。  
  
 このオーバーロードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> メソッドオーバーロードと同じ実装を使用しますが、このオーバーロードにはトランスフォーマーが必要ないという唯一の例外があります。  
  
   
  
## Examples  
 このメソッドの使用方法を次のコード例に示します。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、`<asp:webpartmanager>` 要素、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドを使用して接続を作成するいくつかのイベント処理コードを含む Web ページ。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 Web ページの宣言型マークアップには、ユーザーコントロールとカスタムコントロールの両方の `Register` ディレクティブが含まれています。 `<asp:webpartmanager>` 要素、カスタムコントロールを格納する `<asp:webpartzone>` 要素、および `<asp:connectionszone>` 要素があります。 `Page_Load` メソッドでは、接続を確立できるかどうかをコードが確認し、存在する場合は、プロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティによって参照される静的接続のセットに新しい接続を追加します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 これには、インターフェイスと2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールが含まれ、1つはプロバイダーとして機能し、もう1つはコンシューマーとして機能します。 互換性のあるコネクションポイントがあるため (どちらも `IZipCode` インターフェイスを認識します)、接続を確立するためにトランスフォーマーは必要ありません。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは、`<asp:connectionszone>` 要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、`Page_Load` メソッドに含まれるコードによって接続が既に作成されていることを確認します。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConnectWebParts (provider As WebPart, providerConnectionPoint As ProviderConnectionPoint, consumer As WebPart, consumerConnectionPoint As ConsumerConnectionPoint, transformer As WebPartTransformer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">コントロールを接続したときに、<paramref name="consumer" /> にデータを提供するコントロール。</param>
        <param name="providerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> が接続に関与できるように、コールバック メソッドとして機能する <paramref name="provider" />。</param>
        <param name="consumer">コントロールを接続したときに、<paramref name="provider" /> からデータを受け取るコントロール。</param>
        <param name="consumerConnectionPoint"><see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> が接続に関与できるように、コールバック メソッドとして機能する <paramref name="consumer" />。</param>
        <param name="transformer">互換性のない <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> と <paramref name="provider" /> の接続を可能にする <paramref name="consumer" />。</param>
        <summary>接続に関係する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをチェックして、こうしたコントロールが接続可能かどうかを判断し、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> オブジェクトを使用して互換性のないコンシューマーとプロバイダーの間に接続を作成します。</summary>
        <returns><paramref name="provider" /> と <paramref name="consumer" /> で接続を構成できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、両方のコントロールに互換性のない接続ポイントの種類があり、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトが必要である場合に、`provider` と `consumer` に接続するために使用されます。 このメソッドを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> を呼び出してプログラムによる接続を作成する前に、2つのコントロールを接続できることを確認することができます。  
  
 このオーバーロードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> メソッドオーバーロードと同じ実装を使用しますが、このオーバーロードにはトランスフォーマーが必要であるという唯一の例外があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのカタログから Web ページにサーバー コントロールを追加する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> フィールドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって作成および格納されるカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> オブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせずに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを使用して直接参照できます。  
  
 ユーザーがコントロールをページに追加する場合、サーバーコントロールのカタログが使用可能な場合は、ページを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (カタログモード) に切り替えて、カタログユーザーインターフェイス (UI) が表示されるようにすることができます。 Web パーツカタログの UI は、<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> ゾーンコントロールによって提供されます。 開発者は、デザイン時にこのゾーンをページに追加してから、サーバーコントロールをゾーンに追加して、ユーザーが実行時にこれらのコントロールをページに追加できるようにします。 開発者がこれらのコントロールを追加した後、カタログモードは、カタログモードを有効にするために必要なコントロールがあるため、ページでサポートされている表示モードになります。  
  
 ユーザーがページをカタログモードに切り替えると、ゾーンとそれに追加されたすべてのサーバーコントロールが表示されるようになり、ユーザーは、カタログからコントロールを選択してページに追加したり、ページからコントロールを削除したりできます。 コントロールがページに追加されると、通常のブラウズモードで表示され、ページが更新されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> フィールドをプログラムによって操作する方法を示します。 このコードは、ページのサポートされている表示モードを含むドロップダウンリストを設定します。この例では、参照、デザイン、およびカタログです。 カタログモードは、Web ページ内の `<asp:CatalogZone>` 要素とその子要素によって使用できます。 `Page_PreRender` メソッドで、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>に設定されているかどうかがコードによってチェックされることに注意してください。 その場合、`Label1` が表示されます。存在しない場合、`Label1` は非表示になります。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 ページのラベルが非表示になっていることに注意してください。 ドロップダウンリストコントロールを使用して、ページをカタログモードに切り替えます。 `Page_PreRender` メソッドのコードにより、ラベルが表示されるようになったことに注意してください。 カタログ内のコントロールを選択し、ページの2つのゾーンのいずれかに追加できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ブラウザーから要求を行う機能および <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> プロパティの値をチェックし、クライアント スクリプトを表示するかどうかを判断します。</summary>
        <returns>クライアント スクリプトを表示するかどうかを示すブール値。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続で他のコントロールに対するプロバイダーとして動作しているコントロールをユーザーが終了すると表示される警告を取得または設定します。</summary>
        <value>警告メッセージが含まれた文字列。 既定値は、.NET Framework が提供するカルチャ固有のメッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じると、通常、メッセージは表示されません。 コントロールを閉じる方法の詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドを参照してください。  
  
 ただし、コントロールが別のコントロールに接続され、他のコントロールに対するデータのプロバイダーとして機能している場合は、ユーザーがコントロールを閉じるときに既定の警告メッセージが表示されます。 このメッセージは、プロバイダーコントロールが閉じようとしていることをユーザーに通知します。これは、コンシューマーとしてこのプロバイダーに接続されているコントロールが、使用するデータを保持しなくなることを意味します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティを使用すると、開発者はユーザーに表示される警告メッセージをカスタマイズできます。  
  
 ページ開発者がこのプロパティに空の文字列値または null 文字列値を割り当てた場合、ユーザーがプロバイダーである <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じると、警告メッセージボックスは表示されません。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティを使用して、ユーザーにカスタム警告を表示する方法を示します。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと `<asp:webpartmanager>` 要素を含む Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 次のコードには、例の Web ページ部分のみが含まれています。 また、カスタムユーザーコントロールと、上記で説明したカスタムコントロールのソースコードも必要になります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから、これらの2つの項目を取得します。  
  
 次の Web ページコードは、`<asp:webpartmanager>` 要素内の宣言型マークアップの <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティにカスタム警告メッセージを割り当てる方法を示しています。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは、`<asp:connectionszone>` 要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、**[コンシューマーへの接続の作成]** リンクをクリックします。 ドロップダウンリストコントロールを持つセルが表示されます。 ドロップダウンリストで **[気象制御]** を選択し、**[接続]** をクリックして2つのコントロールの接続を完了します。 **[閉じる]** をクリックし、**[表示モード]** ドロップダウンリストを使用して、ページを通常ブラウズモードに戻します。 最後に、**[郵便]** 番号 コントロール (この場合はプロバイダーコントロール) の動詞メニューをクリックし、**[閉じる]** を選択します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> プロパティに割り当てたカスタムメッセージが表示されます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseWebPart (webPart As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 内の終了する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはサーバー コントロール。</param>
        <summary>Web ページ上に表示されなくても再度開くことができる方法で <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> またはその他のサーバーコントロールを削除して、最初に含まれていた Web ページ上にレンダリングされないようにします。 閉じたコントロールが <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> オブジェクトに追加されます。このオブジェクトは、終了したコントロールへの参照を保持し、コントロールをページに復元できるようにします。 閉じられた <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティによって参照されるコレクションに引き続き表示されます。  
  
 コントロールを閉じることは、コントロールを削除することとは異なります。 閉じられたコントロールをページに復元することはできますが、削除されたコントロールインスタンスは完全に削除されるため、復元することはできません。 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールが静的である (ページのマークアップで宣言されている) か、または動的に (プログラムによって、または Web パーツカタログからユーザーが追加した) かにかかわらず、ページ上で閉じて再度開くことができます。  
  
 通常、ユーザーは動詞メニューをクリックし、[閉じる] 動詞を選択して、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じることができます。 また、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドを直接呼び出し、`webPart`への参照を渡すことによって、コントロールを閉じることもできます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールが閉じられているページで、開発者が `<asp:catalogzone>` 要素を宣言し、その中に `<asp:pagecatalogpart>` 要素を追加すると、ユーザーが実行時に終了したコントロールをページに復元するための簡単なユーザーインターフェイス (UI) が提供されます。 ユーザーはページをカタログ表示モードに切り替えることができ、閉じたコントロールはページカタログ内に表示されます。 ユーザーは、終了したコントロールを選択して、任意の位置でページに戻すことができます。その後、選択したコントロールがページに復元され、通常どおりにレンダリングされます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドが呼び出されると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (複数のコントロールがある場合)、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (接続されているコントロールがある場合) など、いくつかのイベントが発生します。 通常、開発者はこれらのイベントを取り消すことができますが、場合によってはキャンセルすることはできません。 詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントのドキュメントを参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドの使用方法を示します。  
  
 このコード例には、次の4つの部分があります。  
  
-   ページ表示モードを変更できるユーザーコントロール。  
  
-   カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール。  
  
-   Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 コード例の2番目の部分は、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では、動的コンパイルの方法を使用します。したがって、このコントロールの `Register` ディレクティブには、Web ページの上部に `Assembly` 属性はありません。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 コード例の3番目の部分は、Web ページです。 このページには <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーンが含まれており、その中で `<asp:pagecatalogpart>` 要素が宣言されています。 これは、閉じられた <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを含み、ユーザーがこのコントロールをページに再び追加できるようにするものです。 `Button1_Click` メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドを直接呼び出してカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じます。ただし、ユーザーは動詞メニューを使用してコントロールを閉じることもできます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 ブラウザーにページを読み込んだ後、コントロールのヘッダーの動詞メニュー (矢印の記号) をクリックし、**[閉じる]** をクリックして、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じます。 次に、**[表示モード]** ドロップダウンリストコントロールで **[カタログ]** を選択して、ページをカタログモードに変更します。 閉じたコントロールでページカタログが表示されます。 閉じたコントロールの横のチェックボックスをオンにし、**[追加]** をクリックしてページに追加し、**[閉じる]** をクリックしてページをブラウズモードに戻します。 コントロールがページに復元されます。 ここで、**[WebPart を閉じる]** ボタンをクリックして、もう一度閉じます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクション内にありません。  
  
または 
 <paramref name="webPart" /> は共有コントロールで、別のユーザーによって既に終了されています。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール間の接続を管理するための特殊なユーザー インターフェイス (UI) を表示する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> フィールドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって作成および格納されるカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> オブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせずに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを使用して直接参照できます。  
  
 ユーザーが Web ページ上の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール間の接続を管理する場合、ページで <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> ゾーンが宣言されていると、ページを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードに切り替えることができます。 接続表示モードでは、接続を管理するための特殊な UI が表示されます。これには、コントロールに接続したり、接続を切断したり、既存の接続の詳細を編集したりする機能が含まれます。  
  
 Web パーツコントロールセットによって提供される UI を使用して接続を管理する機能をユーザーに提供する場合は、ページのマークアップで `<asp:connectionszone>` 要素を宣言する必要があります。 他の種類の <xref:System.Web.UI.WebControls.WebParts.WebZone> ゾーンの要素とは異なり、この要素内に他のタグを追加する必要はありません。単に要素を単独で宣言します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードの使用方法を示しています。  
  
 このコード例には、次の3つの部分があります。  
  
-   接続を形成できるインターフェイスおよびカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを含むソースファイル。  
  
-   接続 UI を提供し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードの操作を示す Web ページ。  
  
-   例を実行する方法について説明します。  
  
 コード例の最初の部分は、インターフェイスと、接続できるように設計された2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを含むソースファイルです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイル方法を使用します。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 この例の2番目の部分は、カスタムコントロールをホストする Web ページです。 サーバー内の `<script>` タグは、ページの表示モードを使用してドロップダウンリストを設定するいくつかの方法です。 ユーザーは、ドロップダウンリストからこれらを選択して、ページの表示モードを変更できます。 使用可能な表示モードの1つは、`<asp:connectionszone>` 要素がページのマークアップで宣言されているため、接続表示モードです。 この要素には他の子要素が含まれていないことに注意してください。これは、ユーザーの接続管理 UI を有効にするためだけに存在します。  
  
 この例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> モードが2か所に表示されます。 まず、`Page_Init` メソッドでは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティで参照されるコレクションをコードがループするため、表示モードのドロップダウンリストに接続表示モードが追加されます。 次に、`Page_PreRender` メソッドがページの現在の表示モードを確認し、現在のモードが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>の場合、<xref:System.Web.UI.WebControls.Label> コントロールにメッセージを表示します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 ブラウザーにページを読み込んだ後、ドロップダウンリストをクリックし、**[接続]** を選択して、ページを接続表示モードに切り替えます。 ページが接続表示モードであることを通知するメッセージが表示されます。 次に、いずれかの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのタイトルバーにある動詞メニュー (矢印記号) をクリックし、動詞 メニューの **接続** をクリックします。 接続 UI が表示されたら、リンクをクリックして接続を作成します。 表示される接続 UI 内のドロップダウンリストを使用して、接続に参加する他のコントロールを選択し、**[接続]** ボタンをクリックします。 接続が確立されます。 **[閉じる]** ボタンをクリックし、ページの上部にあるドロップダウンリストを使用して、表示モードを参照するページを返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の現在の接続すべてのコレクションへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> プロパティは、ページ上の現在の接続のセットにアクセスする手段を提供します。 コレクション自体は読み取り専用であり、コレクションから特定の接続を操作する開発者は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> や <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>などの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> メソッドを使用する必要があります。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの宣言型およびプログラムによる使用方法を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと、`<asp:webpartmanager>` 要素を含む Web ページ。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 次のコードには、例の Web ページ部分のみが含まれています。 また、カスタムユーザーコントロールと、上記で説明したカスタムコントロールのソースコードも必要になります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから、これらの2つの項目を取得します。  
  
 次の Web ページのコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> プロパティをプログラムで使用して、ページ上の現在の接続数を取得する方法を示しています。 `<script>` タグセクションでは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの2つのイベントを処理するコードが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> プロパティにアクセスしてカウントを取得することに注意してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは、`<asp:connectionszone>` 要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、**[コンシューマーへの接続の作成]** リンクをクリックします。 ドロップダウンリストコントロールを持つセルが表示されます。 ドロップダウンリストで **[気象制御]** を選択し、**[接続]** をクリックして2つのコントロールの接続を完了します。 **[閉じる]** をクリックし、**[表示モード]** ドロップダウンリストを使用して、ページを通常ブラウズモードに戻します。 ラベルには、接続数と <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの数が表示されることに注意してください。 接続モードに戻り、2つのコントロールを切断した場合、ブラウズモードに戻ると、ラベルの内容が更新され、接続が確立されないようにする必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ上の現在の Web パーツ接続すべてが接続され、さらにそれぞれの接続に関係するコンシューマー コントロールとプロバイダー コントロールの間にアクティブなデータの共有が開始された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続のライフサイクルでは、ページが読み込みプロセスを完了した後にこのイベントが発生します。 また、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントの後にも発生します。これは、特定の接続に関係する <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールが正常に接続されたことのみを示します。 1つのページに複数の接続が存在する場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 方法は、ページ上のすべての有効な Web パーツ接続がアクティブになり、データを共有できるようになったことを示します。 すべての接続がアクティブであることを把握すると、開発者は、すべての接続の状態をユーザーに通知したり、プロバイダーからのデータを処理および表示するようコンシューマーコントロールに通知したりするなど、任意の数のタスクを実行できます。  
  
 このイベントは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> メソッドに関連付けられています。このメソッドは、イベントを発生させ、開発者がイベントのカスタムハンドラーを作成できるようにします。  
  
 ページ開発者は、イベントのカスタムハンドラーを作成できます。そのためには、ページの `<asp:webpartmanager>` 要素に `OnConnectionsActivated` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で確立されたすべての Web パーツ接続をアクティブにするプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続のライフサイクルでは、このイベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> メソッドが呼び出される直前にページが読み込みプロセスを完了しているときに発生します。 これは、<xref:System.Web.UI.WebControls.WebParts.WebPart> または他のサーバーコントロール間の特定の接続を含む <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> イベントとは異なります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> イベントは、ページ上のすべての可能な接続が接続され、アクティブ化されるときに発生します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> イベントは、イベントを発生させる <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> メソッドに関連付けられています。 ページに追加できる接続の種類を拡張するコントロール開発者は、保護された <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> メソッドをオーバーライドし、追加の種類の接続をアクティブ化することができます。  
  
 ページ開発者は、イベントのカスタムハンドラーを作成できます。そのためには、ページの `<asp:webpartmanager>` 要素に `OnConnectionsActivating` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーン内に存在する 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロール (または、接続を構成できるその他のサーバー コントロール) の間に接続を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドは、接続できる任意の2つの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール間の接続を形成します。 このメソッドを呼び出して接続を作成する前に、条件付きチェックで <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドを呼び出して、コントロールが接続を形成するための要件を満たしていることを確認することもできます。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではない2つのサーバーコントロール間の接続を作成することもできます。 通常、2つのコントロールは、必要なメンバーを追加できるように、カスタムサーバーコントロール (たとえば、<xref:System.Web.UI.WebControls.WebControl> または既存の ASP.NET サーバーコントロールから継承するコントロール) である必要があります。 コントロールも、以下に示す要件を満たしている必要があります。  
  
 接続できるようにするには、2つのコントロール間のあらゆる種類の接続シナリオが、次の要件を満たしている必要があります。  
  
-   各コントロールは <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに存在します (同じゾーンである必要はありません)。  
  
-   Web パーツコントロールセットに実装されている場合、接続のプロバイダーコントロールは、プロバイダーへのコールバックとして機能するパブリックメソッドとしてインターフェイスを実装し、メソッドに `ConnectionProvider` メタデータ属性を持ち、それをプロバイダー接続ポイントとして識別します。 プロバイダーのコネクションポイントを取得する <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドは仮想であるため、派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは必ずしも同じメタデータ属性を使用する必要はありません。  
  
-   Web パーツコントロールセットに実装されている場合、接続のコンシューマーコントロールには、プロバイダーのコールバックメソッドで公開されているインターフェイスへの参照を取得できる特殊なメソッドもあります。また、コンシューマーは、メソッドの `ConnectionConsumer` メタデータ属性を使用して、コンシューマー接続ポイントとして識別します。 コンシューマー接続ポイントを取得する <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドは仮想であるため、派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは必ずしも同じメタデータ属性を使用する必要はありません。  
  
-   コールバックメソッドには、プロバイダーのコールバックメソッドで提供されるインターフェイスの型 (コンシューマーとプロバイダーがデータを直接共有できること) を使用できること、または <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトを使用してプロバイダーのデータをコンシューマーが使用できる形式に変換する必要があるという、互換性があることが必要です。  
  
    > [!IMPORTANT]
    >  トランスフォーマーが不要な場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> メソッドのオーバーロードを使用します。 トランスフォーマーが必要な場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> メソッドのオーバーロードを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectWebParts (provider As WebPart, providerConnectionPoint As ProviderConnectionPoint, consumer As WebPart, consumerConnectionPoint As ConsumerConnectionPoint) As WebPartConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">接続されたもう一方のコントロールにデータを提供する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="providerConnectionPoint">接続のコールバック メソッドとして機能するメソッド。 Web パーツ コントロール セットに実装するときに、<paramref name="provider" /> のパブリック メソッドを <see langword="ConnectionProvider" /> メタデータ属性でマークします。</param>
        <param name="consumer"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> からデータを受け取り、それを処理するか表示する役割を持つ <paramref name="provider" /> コントロール。</param>
        <param name="consumerConnectionPoint"><paramref name="providerConnectionPoint" /> に接続し、接続のデータを受け取るメソッド。 Web パーツ コントロール セットに実装するときに、<paramref name="consumer" /> のパブリック メソッドを <see langword="ConnectionConsumer" /> メタデータ属性でマークします。</param>
        <summary>コントロールへの参照とその指定された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトだけを使用して、2 つの <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールまたは <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> コントロールの間に接続を作成します。</summary>
        <returns>接続に必要なプロバイダーとコンシューマーに関するさまざまな情報が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続ポイントに <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトを使用せずに接続できるという十分な互換性がある場合に、コントロールを接続するために使用されます。 メソッドのこのオーバーロードが呼び出されると、メソッドの他のオーバーロードされたバージョンに呼び出しが渡され、<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> オブジェクトを必要とするパラメーターの `null` が渡されます。  
  
 プログラムを使用して2つのコントロールを接続しようとすると、条件チェックで <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドを使用して、コントロールを直接接続できるかどうかを判断できます。  
  
   
  
## Examples  
 次のコード例は、このメソッドを使用してプログラムで接続を作成する方法を示しています。 例を実行するために必要な完全なコードについては、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」を参照してください。 この例では、ページの表示モードを変更できるようにするユーザーコントロールのソースコードと、2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのソースコードが必要です。  
  
 2つのコントロールをホストする Web ページのコードは、次のようになります。 このページでは、上部にある `Register` ディレクティブを使用して、ユーザーコントロールとカスタムコントロールを宣言します。 カスタムコントロールは、`<asp:webpartzone>` 要素内で宣言によって参照されます。 `Button1_Click` メソッドを処理するコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドを使用して、コントロール間の接続を作成します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、**[WebPart コントロールの接続]** ボタンをクリックして接続を作成します。 次に、テキストボックスにデータを入力し、**[5 桁の郵便番号を入力]** ボタンをクリックして、コントロールが接続されていることと、1つ目のコントロールに入力されたデータが2番目のコントロールで更新されていることを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">動的接続の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのコレクションが読み取り専用です。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConnectWebParts (provider As WebPart, providerConnectionPoint As ProviderConnectionPoint, consumer As WebPart, consumerConnectionPoint As ConsumerConnectionPoint, transformer As WebPartTransformer) As WebPartConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">接続されたもう一方のコントロールにデータを提供する役割を持つ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <param name="providerConnectionPoint"><paramref name="provider" /> メタデータ属性でマークされ、接続のコールバック メソッドとして機能する、<see langword="ConnectionProvider" /> のパブリック メソッド。</param>
        <param name="consumer"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> または <paramref name="provider" /> からデータを受け取り、それを処理するか表示する役割を持つ <paramref name="transformer" /> コントロール。</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" /> メタデータ属性でマークされ、<see langword="ConnectionConsumer" /> と接続して接続のデータを受け取る、<paramref name="providerConnectionPoint" /> のパブリック メソッド。</param>
        <param name="transformer"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> のデータを <paramref name="provider" /> が処理できる形式に変換することにより、2 つのコントロールを接続できるようにする <paramref name="consumer" />。</param>
        <summary>コントロールへの参照、指定された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクト、および <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> オブジェクトを使用して、2 つの <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> コントロールまたは <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> コントロール間の接続を作成します。</summary>
        <returns>接続に必要なプロバイダー、コンシューマー、およびトランスフォーマーに関する情報が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続ポイントに互換性がない場合にコントロールを接続するために使用されます。 非互換性は、`consumer` が接続ポイントとして `provider` とは異なるインターフェイスを実装している場合に発生します。 トランスフォーマーは、`consumer`によって認識できる型にデータを変換します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">接続が既に <see cref="E:System.Web.UI.Control.PreRender" /> でアクティブになっています。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーン内にあり、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールによって管理される、すべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロール、サーバー コントロール、またはユーザー コントロールのコレクションを取得します。</summary>
        <value><see cref="T:System.Web.UI.ControlCollection" /> コントロールによって管理されるすべてのコントロールが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> プロパティは、さまざまなゾーンコントロール、<xref:System.Web.UI.WebControls.WebParts.EditorPart> または <xref:System.Web.UI.WebControls.WebParts.CatalogPart> コントロールなど、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって参照される他のコントロールを参照しません。  
  
 このプロパティは、Web パーツコントロールセットによって使用されます。ほとんどの開発状況では、コードから呼び出すためのものではありません。 このため、プロパティはパブリックですが、IntelliSense からは非表示になっています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって管理されている <xref:System.Web.UI.WebControls.WebParts.WebPart> またはその他のサーバーコントロールのコレクションにアクセスする開発者は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティを使用する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CopyWebPart (webPart As WebPart) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">コピー対象の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール。</param>
        <summary>Web ページに <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを追加するためにこうしたコントロールのコピーを作成する場合に、Web パーツ コントロール セットで使用されます。</summary>
        <returns>ページに追加される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドをコードから直接呼び出すことはできません。 このメソッドは、新しい動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールをページに追加するプロセスの一部として、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって内部的に呼び出されます。 動的コントロールは、プログラムまたは Web パーツユーザーインターフェイス (UI) を使用してページに追加されます。たとえば、ページのマークアップで直接宣言されている静的コントロールではなく、コントロールのカタログからコントロールを追加するユーザーがコントロールを追加します。  
  
> [!NOTE]
>  開発者がメソッドを有効にして、追加のコントロールコピーシナリオを処理できるようにする場合は、派生クラスでメソッドをオーバーライドできます。 詳細については、「継承に関する注意事項」セクションを参照してください。  
  
 新しい動的コントロールが追加されると、そのコントロールが <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドはコントロールの新しいインスタンスを返します。 追加されるコントロールが、他の種類のサーバーコントロール (ユーザーコントロール、カスタムコントロール、ASP.NET コントロールなど) である場合、コントロールは Web パーツコントロールセットによって <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトで既にラップされています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドが <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールを検出すると、コントロールにラップされた子コントロールの新しいインスタンスを使用して <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールの新しいインスタンスが返されます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドによってコントロールの新しいコピーが作成され、を返すと、すべてのプロパティの値が既定値にリセットされます。 パーソナル化できるプロパティの値を保持し、それらを新しいコントロールインスタンスにコピーする場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> メソッドも呼び出す必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> メソッドによって実行される最後の手順は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> メソッドを呼び出して、コントロールの新しい ID を取得することです。  
  
> [!NOTE]
>  メソッドは、コピーされたコントロールに対して新しい ID を取得するため、元の ID によってページに追加される動的コントロールの参照に依存しないようにしてください。 代わりに、メソッドによって返されるコントロールの新しいインスタンスを参照する必要があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>メソッドは、開発者が <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを継承し、メソッドをオーバーライドして、コントロールのコピーを作成できる追加のシナリオを提供できるように <see langword="virtual" /> として宣言されます。 たとえば、メソッドは、必要に応じて、XML ファイルにシリアル化されたコントロールを入力として受け取ることができます。 メソッドは XML を逆シリアル化して (存在する場合)、既存のケースを処理し、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの新しいインスタンスを返すために、基本メソッドを呼び出します。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web サイトの構成ファイルに指定されているトランスフォーマーのセットを作成し、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> プロパティで参照されるトランスフォーマーのコレクションにそれを追加します。</summary>
        <returns>Web サイトの構成ファイルで指定されているトランスフォーマーのコレクション。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>このメソッドは、アプリケーションで使用できるその他のトランスフォーマーを追加するためにオーバーライドできます。 たとえば、メソッドを記述して、Web サービスから使用可能なトランスフォーマーの一覧を取得できます。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで管理されるすべてのコントロールのコレクションを返します。 このクラスは継承できません。</summary>
        <returns><see cref="T:System.Web.UI.ControlCollection" /> コントロールで管理されるすべてのさまざまな Web パーツ コントロールで構成された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>このメソッドはプロテクトおよびシールされているため、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを継承するクラスからは参照できますが、オーバーライドすることはできません。</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Web パーツ アプリケーションで使用できるすべての表示モードのセットを作成します。</summary>
        <returns>サポートされているすべての表示モードが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、特定のページでサポートされている表示モードだけでなく、使用可能なすべての表示モードの一覧を作成します。 サポートされている表示モードの詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティを参照してください。  
  
 既定では、Web パーツコントロールセットは、Web パーツページで使用される次の一連の表示モードを作成します。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 開発者は、<xref:System.Web.UI.WebControls.WebParts.WebZone> または <xref:System.Web.UI.WebControls.WebParts.ToolZone> クラスから派生したカスタムゾーンを使用するかどうかにかかわらず、カスタム表示モードを作成できます。 カスタム表示モードを作成するには、<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> クラスを継承し、表示モードをページのサポートされているモードとして追加する必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを継承し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッドをオーバーライドする必要があります。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> メソッドを使用して表示モードを追加する場合は、ユーザーインターフェイス (UI) コントロール (<xref:System.Web.UI.WebControls.ListBox> コントロールなど) に表示される順序で、ページの表示モードをユーザーに提供する順に追加する必要があります。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッドの使用方法を示します。  
  
 このコード例には5つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   他のコントロールをホストする Web ページ。  
  
-   Web ページの <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンに存在するユーザーコントロール。ラベルにテキストを入力して表示することができます。  
  
-   2つのコントロールを含むソースコードファイル。 一方はカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールで、もう1つはページの既定の表示モードに追加するカスタムの <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> オブジェクトです。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 この例の2番目の部分は Web ページです。 これには、ユーザーコントロールとカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの2つの <xref:System.Web.UI.WebControls.WebParts.WebPartZone> コントロールが含まれています。 ページの上部にある `Register` ディレクティブを使用して、コンパイルされたコントロールのユーザーコントロールと名前空間を参照します。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 この例の3番目の部分は、テキストを入力および表示するためのユーザーコントロールです。 <xref:System.Web.UI.WebControls.MultiView> コントロールを使用して、UI の複数のビューを作成します。 1つのビューが `Button1` ボタンと共に表示されます。 オーバーライドされた `OnPreRender` メソッドで、コードはページが現在カスタム表示モードであるかどうかを確認し、存在する場合は、ボタンを含むユーザーコントロールの最初のビューを表示することに注意してください。 ページがブラウザーモードまたはデザインモードの場合など、ページがカスタム表示モードでない場合、ボタンは非表示になります。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 この例の4番目の部分は、2つのカスタムクラスのソースファイルです。 カスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> メソッドをオーバーライドし、まず基本メソッドを呼び出してすべての既定の表示モードを追加し、次にカスタム表示モードを追加することに注意してください。 カスタム表示モードクラスである `InLineEditDisplayMode`は、単純に <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>から継承し、コンストラクターの表示モードの名前を設定し、基本プロパティの数をオーバーライドしてカスタム表示の特性を確立します。  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 コード例を実行するには、ブラウザーにページを読み込みます。 ページは現在ブラウズモードであり、ボタンが表示されていないことに注意してください。 **[表示モード]** ドロップダウンリストコントロールを使用して、ページを**インライン編集表示**モードに変更します。これで、[`Button1`] ボタンが下部のユーザーコントロールに表示されることがわかります。 テキストを追加し、ボタンをクリックしてコントロールを更新します。 ページ表示がブラウズモードに戻り、入力したテキストが表示されます。このボタンは、カスタム表示モードではなくなったため、再度非表示になります。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">チュートリアル: Web パーツページでの表示モードの変更</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>動的接続の ID として使用される一意の値を取得します。</summary>
        <returns>接続に関する一意の ID を含む文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> メソッドは、GUID 値を生成し、接続の一意の ID として機能するように、その値を文字列に変換します。 メソッドは、動的接続が作成されるたびに呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスでこのメソッドをオーバーライドして、一意の ID を生成するための実装を変更できます。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">ID の生成対象となるコントロールの <see cref="T:System.Type" />。</param>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの一意の ID を生成します。</summary>
        <returns>コントロールの一意の ID が含まれた文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールが Web ページに追加されると、コントロールは静的な場合があります (つまり、コントロールがページマークアップで宣言されています)。または、動的 (プログラムによって追加されることを意味します) にすることができます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールがページに追加する新しい動的コントロールを作成している場合は、このメソッドを呼び出して一意の ID を生成します。  
  
 メソッドは、ID を生成するためのカスタム実装を提供する必要がある場合に、開発者がオーバーライドできるように仮想化されています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartType" /> が <see langword="null" /> です。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">失敗するコントロールの ID を含む文字列。 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、ID はその子サーバー コントロールの ID です。</param>
        <param name="originalTypeName">失敗したコントロールの <see cref="T:System.Type" /> の名前を示す文字列。 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、型名はその子サーバー コントロールの型名です。</param>
        <param name="originalPath">子ユーザー コントロールを格納する <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> がこの失敗に関係する場合、ユーザー コントロールへのパスを含む文字列。</param>
        <param name="genericWebPartID">その型のコントロールがコントロールの読み込みまたは作成の失敗に関係する場合、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> の ID を返す文字列。</param>
        <param name="errorMessage">ページ上に表示するエラー メッセージを含む文字列。</param>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを読み込むか作成しようとして何らかの理由で失敗したときに、ページに挿入してエンド ユーザーに表示する特別なコントロールを作成します。</summary>
        <returns>読み込みまたは作成に失敗したコントロールの代わりにページに挿入する <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> メソッドは、Web パーツコントロールセットが動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールのインスタンスの読み込みまたは作成を試みたときに呼び出され、何らかの理由で失敗します。 メソッドは <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> オブジェクトを作成し、それにエラーメッセージを割り当てて、それを返します。 失敗したコントロールの代わりに <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> コントロールが挿入され、そのエラーメッセージがページに表示されます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> メソッドをコードから直接呼び出すことはできません。 ただし、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスから継承し、メソッドを拡張することができます。 詳細については、「継承に関する注意事項」セクションを参照してください。  
  
 エンドユーザーは、通常の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと同じように、ページ内の <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> コントロールを操作できます。 エラーメッセージを削除するには、閉じる動詞をクリックしてコントロールを閉じることができます。その時点で、他の閉じているコントロールと同様に、コントロールが <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> オブジェクトに追加されます。 エンドユーザーが <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> コントロールを削除すると、読み込みに失敗したサーバーコントロールもページから削除されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> コントロールで返される情報をカスタマイズする場合は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> メソッドをオーバーライドし、基本メソッドを呼び出して、基本メソッドに渡されるパラメーターに別の値を割り当ててから、結果の <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> コントロールを返すことができます。 たとえば、エンドユーザーに <paramref name="originalPath" /> 値 (ユーザーコントロールの仮想ディレクトリパスを示す) を表示させたくない場合、基本メソッドを呼び出すと、そのパラメーターに空の文字列 ("") を渡すことができます。  
  
<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> コントロール自体を継承することによって、その動作をカスタマイズすることもできます。 たとえば、<see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> または <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> プロパティをオーバーライドすることができます。</para></block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の Web ページのユーザーのパーソナル化データを格納するパーソナル化オブジェクトを返します。</summary>
        <returns>ユーザーのパーソナル化データが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> メソッドは、現在のページのユーザーのパーソナル化設定を格納および管理するオブジェクトを返します。 このオブジェクトは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって管理されます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web パーツパーソナル化の概要</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateWebPart (control As Control) As GenericWebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール以外のサーバー コントロール。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> オブジェクトを持った <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロール以外のサーバー コントロールが Web パーツ機能を備えることができるように、そのコントロールをラップします。</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> をラップし、真の <paramref name="control" /> コントロールとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではないサーバーコントロールが <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと同じ機能を使用できるようにし、Web パーツアプリケーションに完全に参加するための主要なメカニズムです。 この方法を使用すると、開発者は Web パーツアプリケーションで使用できるサーバーコントロールの数を大幅に拡張します。これは、ほとんどすべての種類のサーバーコントロール (標準 ASP.NET コントロール、ユーザーコントロール、およびカスタムコントロール) を使用できるためです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、他の2つのシナリオでもこのメソッドを使用して、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトでサーバーコントロールをラップします。 ユーザーが <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> コントロールを使用してサーバーコントロールをページに追加する場合、インポートされたコントロールが <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールでない場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドが呼び出されます。 また、サーバーコントロールが Web ページ上の <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン内で永続化形式で宣言されている場合、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではないコントロールに対して <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドが呼び出されます。  
  
 サーバーコントロールをプログラムでゾーンに追加する場合、一般的な方法として、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドを使用して <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトを使用してコントロールをラップし、次に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> メソッドを呼び出して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティによって参照されるページ上のすべての <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのコレクションにコントロールを追加します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドの使用方法を示しています。 `Button2_Click method`では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> メソッドを呼び出して、<xref:System.Web.UI.WebControls.Calendar> コントロールをゾーンに追加する前に <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトをラップします。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>このメソッドは、Web パーツコントロールセットで提供される基本クラスではなく、派生 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> クラスを使用するようにオーバーライドできます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンド ユーザーがコントロールを削除したときにそのユーザーに対して表示するカスタム警告メッセージを取得または設定します。</summary>
        <value>警告メッセージのテキストが含まれる文字列。 既定値は、ローカライズされた警告メッセージです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを削除すると、通常は既定の警告メッセージが表示されます。 コントロールのこのインスタンスが削除されると、削除が永続的であることをユーザーに警告します。 ページ開発者は、コントロールの新しいインスタンスをページに追加する方法をユーザーに提供する場合があります (たとえば、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのカタログを使用したり、プログラムによる手段を使用したりすることができます) が、削除されたコントロールの現在のインスタンスは完全に削除されます。 警告を表示するダイアログボックスには、必要に応じてユーザーが削除を取り消すためのボタンが含まれています。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティを使用すると、開発者はユーザーに表示される警告メッセージを設定できます。  
  
 ページ開発者がこのプロパティに空の文字列 ("") 値を割り当てた場合、ユーザーが <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを削除したときに警告メッセージダイアログボックスは表示されません。  
  
> [!NOTE]
>  静的 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールおよびサーバーコントロールの場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティは表示されません。 静的コントロールは、Web ページのマークアップで <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン内で宣言されたサーバーコントロールです。 このようなコントロールは静的であるため、削除することはできません。その場合、削除の警告メッセージが表示されることはありません。 静的コントロールはユーザーが閉じることができますが、閉じられたコントロールは、ユーザーがページに再び追加できるように、ページカタログに追加されます。ただし、削除されたコントロールは回復できません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティを宣言およびプログラムによって使用する方法を示しています。  
  
 コード例には、次の4つの部分があります。  
  
-   ページ表示モードを変更できるユーザーコントロール。  
  
-   カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール。  
  
-   Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 コード例の2番目の部分は、カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では、動的コンパイルの方法を使用します。したがって、このコントロールの `Register` ディレクティブには、Web ページの上部に `Assembly` 属性はありません。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 コード例の3番目の部分は、Web ページです。 このページには、ユーザーが実行時にページに追加できるように、カスタムの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールがゾーンで宣言されている <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーンが含まれています。 ページから削除できるのは、動的コントロール (プログラムによって、またはこのようなカタログからページに追加されるコントロール) だけです。 スタティックコントロール (ページのマークアップで <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン内で宣言されているコントロール) は閉じることができますが、削除することはできません。 `<asp:webpartmanager>` 要素は、`DeleteWarning` 属性を使用して、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティのカスタム値を宣言します。 `Button1_Click` メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> プロパティに別のカスタム値を割り当てます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをページに追加する必要があります。 **表示モード** ドロップダウンリストコントロールを使用して、カタログモード を選択します。 カタログが表示されたら、カスタムコントロールの横にあるチェックボックスをオンにし、**[追加]** をクリックしてページに追加します。次に、**[閉じる]** をクリックして、ページをブラウズモードに戻します。 コントロールが表示されたので、そのコントロールを削除できます。 **表示モード**コントロールを再度使用して、ページをデザインモードに切り替えます (ページがブラウズモードの間はコントロールを削除できません)。 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのヘッダーにある動詞メニュー (矢印記号) をクリックし、**[削除]** を選択します。 `DeleteWarning` 属性に設定した警告が表示されます。 **[キャンセル]** をクリックします。 次に、**[Change Delete Warning]** というラベルのボタンをクリックします。これにより、プログラムでプロパティ値が変更されます。 コントロールの動詞メニューから **[削除]** をもう一度選択します。今度は、もう一方の警告メッセージが表示されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteWebPart (webPart As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">削除するサーバー コントロール。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの動的インスタンスを Web ページから完全に削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドは、`webPart` パラメーターによって表されるコントロールをページから完全に削除します。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> コントロールに追加され、ページに戻すことができる閉じたコントロールとは異なり、削除されたコントロールインスタンスをページに再び追加することはできません。  
  
> [!NOTE]
>  Web パーツコントロールセットによって実装されるように、ユーザーが動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> 制御を削除する機能は、ユーザーと、コントロールがページに追加されたパーソナル化スコープによって異なります。 ページがアクセス許可を持つユーザーによって共有スコープ内にあるときにコントロールが追加された場合、そのページがユーザースコープにあるときは、個々のユーザーがそのコントロールを削除することはできません。  
  
 削除できるのは動的コントロールだけです。 動的コントロールは、プログラムによって、またはユーザーがカタログからコントロールを追加することによって、ページに追加されます。 静的コントロールは、マークアップまたは永続化形式で宣言によってページに追加されます。 宣言型のタグはマークアップ内に完全に存在するため、スタティックコントロールは削除できませんが、閉じて再度開くことができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドの使用方法を示します。 **[カレンダーの追加]** ボタンを初めてクリックすると、イベントハンドラーのコードによって <xref:System.Web.UI.WebControls.Calendar> コントロールが作成され、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトとしてゾーンに追加されます。 コントロールはプログラムによって追加されるため、動的コントロールであるため、削除することができます。 ユーザーが [カレンダーの**削除**] ボタンをクリックすると、そのコントロールが存在し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> メソッドを呼び出すことによって、そのコントロールが削除されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールを含む Web ページのレイアウトを変更する場合に使用する表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> フィールドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって作成および格納されるカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> オブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせずに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを使用して直接参照できます。  
  
 Web パーツコントロールを含むページが最初に読み込まれるとき、既定では <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (ブラウズモード) になります。 コントロールを別のゾーンまたは現在のゾーンに移動してページのレイアウトを変更する場合は、最初にページを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (デザインモード) に切り替える必要があります。 デザインモードでは、さまざまなゾーンのユーザーインターフェイス (UI) が表示され、ユーザーはコントロールをドラッグしてレイアウトを変更できます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> フィールドをプログラムによって操作する方法を示します。 このコードは、ページのサポートされている表示モードを含むドロップダウンリストを設定します。この例では、参照とデザインが使用されています。 `Page_PreRender` メソッドで、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>に設定されているかどうかがコードによってチェックされることに注意してください。 その場合、`Label1` が表示されます。存在しない場合、`Label1` は非表示になります。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 ページのラベルが非表示になっていることに注意してください。 ドロップダウンリストコントロールを使用して、ページをデザインモードに切り替えます。 `Page_PreRender` メソッドのコードにより、ラベルが表示されるようになったことに注意してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DisconnectWebPart (webPart As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続を解除する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</param>
        <summary>終了または削除する <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを、それが関係する接続から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドは、コントロールがページ上で閉じられたとき、またはページから削除されたときに、Web パーツコントロールによって内部的に呼び出されます。 このようなシナリオでは、コンシューマーまたはプロバイダーとして関係するすべての接続からコントロールを削除するために、メソッドが呼び出されます。 コントロールが接続から削除された場合、このメソッドは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドも呼び出して、`webPart` が関係しているすべての接続を終了します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドが呼び出されると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントが発生します。 通常、このイベントはキャンセルできますが、2つのケースでは取り消すことができません。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> メソッドが呼び出されると、ページへの要求中に1つのケースが発生します。 既存の接続間で競合が発生した場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドが呼び出され、競合している接続のいずれかが閉じられます。このインスタンスでは、競合を解決する必要があるため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを取り消すことはできません。  
  
 もう1つのケースは、現在接続されている <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールが閉じられているか削除されている場合です。 この場合、コントロールがページから削除されているため、接続も終了する必要があります。したがって、デザイン上、接続を終了するプロセスを中断するために <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントをキャンセルすることはできません。 詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドの使用方法を示します。 Web ページでは、2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを使用して、ボタンをクリックしてコントロール間の接続を作成できます。また、別のボタンを使用してコントロールを切断することもできます。 ページがブラウズモードであり、コントロールが接続されているときにコントロールのいずれかを閉じると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドのオーバーライドによって、終了したコントロールが切断され、接続が終了し、メッセージが表示されます。  
  
 このコード例には、次の4つの部分があります。  
  
-   表示モードを変更するためのユーザーコントロール。  
  
-   カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを含むソースファイル。  
  
-   コントロールをホストする Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 2番目の部分は、接続される2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのソースコードと、カスタムの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを含むファイルです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では動的コンパイルを使用するので、Web ページ内のこれらのコンポーネントを参照する `Register` ディレクティブは、それに応じて Web ページの上部に宣言されます。 コンパイルオプションを示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 ソースコードで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドをオーバーライドする継承されたコントロール `MyWebPartManager` を確認します。 このメソッドは、ページ内の各接続を確認し、閉じられているコントロールが接続に参加しているかどうかを確認します。接続を終了する場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドを呼び出します。 これは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールのメソッドの基本実装と同じです。 次に、オーバーライドされたメソッドは、メッセージをページに書き込むことによって基本実装をカスタマイズします。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の3番目の部分は、Web ページです。 上部には、ユーザーコントロールを登録する `Register` ディレクティブと、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを使用して動的にコンパイルされたアセンブリが含まれています。 このページには、2つの主要な方法があります。 `Button1_Click` メソッドは、コントロール間の接続を作成し、`Button2_Click` メソッドはコントロールを切断します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 ページを読み込んだ後、**[接続]** ボタンをクリックしてコントロールを接続します。 次に、コントロールの1つ (コントロールのヘッダーの下矢印) で動詞メニューをクリックし、動詞 メニューの **閉じる** をクリックします。 コントロールを終了しようとすると、オーバーライドされたメソッドが呼び出され、接続が終了し、メッセージがページに書き込まれます。 ページをリセットして、終了したコントロールを復元し、その他のオプションを試すには、**[ユーザー状態のリセット]** リンクをクリックしてパーソナル化データを削除し、ページの元の状態を復元します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">サーバー コントロール間の接続を表す <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</param>
        <summary>Web ページ上で接続されたサーバー コントロールの接続を解除するプロセスを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドは、`connection` パラメーターを渡すときに、<xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロール間の接続を終了する完全なプロセスを実行します。  
  
 このメソッドは、Web ページに `<asp:connectionszone>` 要素を配置するときにコントロールを切断するために使用され、接続を管理するためのユーザーインターフェイス (UI) を提供します。 ページが接続表示モード (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>) にあり、現在の接続が存在する場合、ユーザーは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドを呼び出して接続を終了するボタンをクリックできます。  
  
 また、プログラムによってコントロールを切断し、ページに `<asp:connectionszone>` 要素を追加しなくても、コードから <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドを直接呼び出すことができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドの使用方法を示します。 Web ページでは、2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを使用して、ボタンをクリックしてコントロール間の接続を作成できます。また、別のボタンを使用してコントロールを切断することもできます。  
  
 このコード例には、次の4つの部分があります。  
  
-   表示モードを変更するためのユーザーコントロール。  
  
-   カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを含むソースファイル。  
  
-   コントロールをホストする Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 2番目の部分は、接続される2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのソースコードを含むファイルです。 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 この例では動的コンパイルを使用するので、Web ページ内のこれらのコンポーネントを参照する `Register` ディレクティブは、それに応じて Web ページの上部に宣言されます。 コンパイルオプションを示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 コード例の3番目の部分は、Web ページです。 上部の近くには、ユーザーコントロールと動的にコンパイルされたアセンブリを <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールに登録するための `Register` ディレクティブが含まれています。 このページには、2つの主要な方法があります。 `Button1_Click` メソッドは、コントロール間の接続を作成し、`Button2_Click` メソッドはコントロールを切断します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 ページを読み込んだ後、**[接続]** ボタンをクリックしてコントロールを接続することができます。 テキストボックスコントロールにテキストを入力し、**[enter]** ボタンをクリックすると、接続されたコントロールにテキストが表示されます (コントロールが接続されていない場合は表示されません)。 **[切断]** ボタンをクリックすると、コントロールが切断されます。 コントロールの接続状態を確認するには、**[表示モード]** ドロップダウンリストコントロールを使用して、ページを**接続**モードに切り替えます。 その後、いずれかのコントロールのタイトルバーで動詞メニュー (矢印で表されます) をクリックし、**[Connect]** 項目を選択します。 接続 UI が表示されます。これは、ページで `<asp:connectionszone>` 要素が宣言されているために使用できます。 この UI からコントロールに接続したり、コントロールを切断したりすることもできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> または<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> のいずれかに <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> が含まれていません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> は読み取り専用です。  
  
または 
 <paramref name="connection" /> は既に <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> から接続解除されています。  
  
または 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> は読み取り専用です。  
  
または 
 <paramref name="connection" /> は既に <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> から接続解除されています。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを切断するための既定の実装を変更する場合は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> メソッドをオーバーライドできます。 メソッドをオーバーライドし、単に実装を既存のメソッドに追加するだけの場合は、独自のコードを実行する前に基本メソッドを呼び出すことができます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ コントロールが含まれた Web ページのアクティブな表示モードを取得または設定します。</summary>
        <value>ページの表示モードを決定する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツコントロールを含むページは、常にいくつかの表示モードのいずれかにあります。 表示モードの詳細については、「 [Web パーツページ表示モード](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)」を参照してください。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスは、Web ページの表示モードを作成します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、基本 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> クラスを使用して、Web パーツコントロールを含むページで使用できる標準表示モードオブジェクトをいくつか作成します。 これらの標準表示モードについては、<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> クラスの概要」を参照してください。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、Web パーツコントロールを使用するページの表示モードも管理します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティを使用して、ページ上の現在の表示モードへの参照を保持します。 また、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティを使用して、ページを異なる表示モードに切り替えることもできます。 Web パーツコントロールを使用するページで表示モードを変更する例については、「[チュートリアル: Web パーツページの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 表示モードの管理の一環として、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> メソッドや <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> メソッドなどの表示モードに関連するイベントとイベントハンドラーも用意されています。 これらのメソッドは、ページの動作をカスタマイズするためのメカニズムを提供し、カスタム表示モードを追加するためにも使用できます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティをプログラムで使用する方法を示しています。 ブラウザーにページを読み込むと、ページの下部付近にあるボタンを使用して表示モードを切り替えることができます。 ページは、読み込み時に既定でブラウズモードになります。 デザインモードに切り替えると、あるゾーンから別のゾーンにサーバーコントロールをドラッグしたり、1つのゾーン内に2つのコントロールを配置したりすることができます。 編集モードに切り替えると、いずれかのサーバーコントロールのヘッダーで動詞メニューをクリックし、**[編集]** を選択して、提供されている編集ユーザーインターフェイス (UI) を使用してコントロールを編集できます。  
  
> [!NOTE]
>  Web パーツアプリケーションでの表示モードの切り替えは非常に一般的であり、Web パーツコントロールを含むすべてのページで、一貫した再利用可能な方法でこの操作を行うことができます。 表示モードを変更し、多くのページで再利用できるユーザーコントロールの例については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが、サポートされている表示モードではありません。  
  
または 
プロパティに割り当てられている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトが無効です。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">チュートリアル: Web パーツページでの表示モードの変更</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web パーツ ページ上の現在の表示モードが変更された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示モードは Web パーツアプリケーションの不可欠な部分です。 ユーザーが Web ページで別の表示モードに切り替えた場合、新しい表示モードの目的によっては、ページの外観が大きく異なることがよくあります。 表示モードを変更した後、特定のコントロールの表示/非表示、選択した UI 要素の外観の変更など、ユーザーインターフェイス (UI) に特定の変更を加えることができます。  
  
> [!NOTE]
>  表示モードの詳細については、「 [Web パーツページ表示モード](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)」を参照してください。 イベントの使用方法の詳細については、「[方法: Web フォームアプリケーションでイベントを使用する](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で別の表示モードに変更するプロセスを開始する動詞をユーザーがクリックした後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示モードは Web パーツアプリケーションの不可欠な部分です。 ユーザーが Web ページで別の表示モードに切り替えた場合、新しい表示モードの目的によっては、ページの外観が大きく異なることがよくあります。 動詞をクリックして新しい表示モードに変更するプロセスをユーザーが開始した後、<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> プロパティを使用して、新しい表示モードを決定し、それに応じてさまざまな UI 要素を変更することによって、ユーザーインターフェイス (UI) に特定の変更を加えることができます。 これを行う便利な方法は、UI をカスタマイズするために <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> メソッドをオーバーライドすることです。  
  
> [!NOTE]
>  表示モードの詳細については、「 [Web パーツページ表示モード](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)」を参照してください。 イベントの使用方法の詳細については、「[方法: Web フォームアプリケーションでイベントを使用する](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに関連付けられたすべての表示モードの読み取り専用のコレクションを取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> コントロールに関連付けられた <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティは、関連付けられているすべての表示モードを参照します。これに対し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティは、現在のページで使用可能 (サポートされている) 表示モードのみを参照します。  
  
 指定された2つの表示モード (参照とデザイン) は、常にページでサポートされています。 他の3つの表示モード、編集、カタログ、および接続は、特定の表示モードが動作するために必要な対応する種類のゾーンがページにある場合にのみサポートされます。 たとえば、ページに <xref:System.Web.UI.WebControls.WebParts.EditorZone> ゾーンが含まれていない場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティによって参照されるコレクションには編集表示モードが表示されますが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティによって参照されるコレクションには表示されません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティをプログラムで使用する方法を示しています。 このコードでは、このプロパティを使用して、Web パーツコントロールセットで使用できるすべての表示モードをリストに設定します。現在のページではサポートされていないすべての表示モードを使用できます。 この場合、対応する必要なゾーンがページ上にないため、カタログと接続の表示モードはサポートされていません。  
  
 その他の3つの表示モード ([参照]、[デザイン]、[編集]) は、ページでサポートされています。 このページには <xref:System.Web.UI.WebControls.WebParts.EditorZone> ゾーンが含まれていますが、ブラウズモードとデザインモードは常にサポートされているので、編集モードはサポートされています。  
  
 ブラウザーにページを読み込むと、ドロップダウンリストコントロールを使用して、ページをブラウズモードからデザインモードに切り替えてから編集モードに切り替えることができます。 編集モードでは、いずれかのサーバーコントロールのヘッダーのドロップダウン動詞メニューをクリックし、**[編集]** を選択してコントロールを編集することができます。 ドロップダウンリストで **[カタログ]** または **[接続]** を選択すると、エラーページが生成されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">チュートリアル: Web パーツページでの表示モードの変更</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在 Web ページ上に存在するすべての動的接続のコレクションを取得します。</summary>
        <value>ページ上のすべての動的接続への参照が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的接続は、静的ではなく、プログラムによって作成される接続です。 静的接続は、Web フォームページのマークアップで宣言することによって作成されます。 動的接続は、プログラムによって、または接続ユーザーインターフェイス (UI) を使用して接続を作成するユーザーによって形成されます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> コレクションは読み取り専用ですが、内容を変更することはできません。は、各動的接続オブジェクトにプログラムでアクセスできるようにします。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの接続や切断などの一般的な操作を実行するには、開発者は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> コレクション内の接続オブジェクトを直接変更するのではなく、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> や <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>などの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスのパブリックメソッドを使用する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンド ユーザーによるサーバー コントロールの編集および変更が可能な表示モードを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> フィールドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって作成および格納されるカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> オブジェクトを参照します。 これは静的オブジェクトであるため、コントロールのインスタンスを必要とせずに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを使用して直接参照できます。  
  
 Web パーツコントロールを含むページが最初に読み込まれるとき、既定では <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (ブラウズモード) になります。 ユーザーがサーバーコントロールを編集または変更する場合は、最初にページを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (編集モード) に切り替える必要があります。 次に、編集する特定のサーバーコントロールを選択する必要があります。そのためには、そのコントロールのヘッダーの動詞メニューで [編集] 動詞をクリックします。 コントロールが編集モードになると、選択したコントロールを編集するための編集ユーザーインターフェイス (UI) が表示されます。  
  
 ページに対して編集モードを有効にするには、ページに1つ以上の <xref:System.Web.UI.WebControls.WebParts.EditorZone> ゾーンが含まれている必要があります。これには、<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> コントロールやカスタム編集コントロールなど、提供されている1つ以上の編集コントロールが含まれます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> フィールドをプログラムによって操作する方法を示します。 このコードは、ページのサポートされている表示モードを含むドロップダウンリストを設定します。この例では、参照、デザイン、および編集です。 編集をサポートするために、`<asp:EditorZone>` の要素がページにあります。 `Page_PreRender` メソッドで、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> プロパティが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>に設定されているかどうかがコードによってチェックされることに注意してください。 その場合、`Label1` が表示されます。存在しない場合、`Label1` は非表示になります。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 ブラウザーにページを読み込むと、既定でブラウズモードになります。 ページのラベルが非表示になっていることに注意してください。 ドロップダウンリストコントロールを使用して、ページを編集モードに切り替えます。 `Page_PreRender` メソッドのコードにより、ラベルが表示されるようになったことに注意してください。 コントロールのいずれかの動詞メニューで **[編集]** 動詞をクリックして、その特定のコントロールの編集を有効にします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが含まれた Web ページ上でクライアント側スクリプト機能を有効にするかどうかを決定する値を取得または設定します。</summary>
        <value>ページ上でクライアント スクリプトを実行できるかどうかを示すブール値。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> プロパティは、開発者がクライアントスクリプトを無効にする方法を提供します。 セキュリティ上の目的でクライアントスクリプトを無効にしたり、異なるブラウザーを使用している場合でも、ページのすべてのユーザーが同様のユーザーエクスペリエンスを持つようにすることができます。  
  
 次の宣言型コード行に示すように、Web ページの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 要素に `EnableClientScript` 属性を追加することによって、クライアントスクリプトを無効にすることができます。  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 また、開発者は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスから継承し、既定値を `false`に設定することによって、このプロパティを削除することもできます。  
  
 Web パーツコントロールセットは、クライアントスクリプトを使用して、いくつかのクライアントユーザーインターフェイス (UI) とパーソナル化機能を提供します。 クライアントスクリプトを無効にしても、Web パーツコントロールは機能しますが、一部の機能は無効になります。 コントロールを異なるゾーンにドラッグできるかどうかは、コントロールのタイトルバーのドロップダウン動詞メニューで動詞をレンダリングする機能と共に使用できなくなります (動詞は、コントロールのタイトルバーにリンクとして表示されます)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上でテーマを使用できることを示す値を取得します。</summary>
        <value>テーマが有効かどうかを示す Boolean 値。 すべてのケースで <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは基本 <xref:System.Web.UI.Control.EnableTheming%2A> プロパティをオーバーライドして、常に `true`の値を返すようにします。 これは、Web パーツコントロールセットで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの子コントロールであり、Web ページのユーザーインターフェイス (UI) を形成する Web パーツコントロールをレンダリングするために、テーマを使用する必要があるためです。 たとえば、さまざまな種類のパーツコントロール (<xref:System.Web.UI.WebControls.WebParts.Part> クラスを継承するコントロール)、ユーザーコントロール、ASP.NET サーバーコントロール、およびカスタムサーバーコントロールを含む、さまざまなゾーンと、ゾーン内に存在するコントロールを表示するテーマが使用されます。  
  
 オーバーライドされた <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> プロパティは、基本プロパティに従って読み取り/書き込みプロパティとして実装されますが、プロパティを設定することはできません。これは、デザイン上、常に `true`の値を返す必要があるためです。 プロパティを設定しようとすると、<xref:System.NotSupportedException> 例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティ値を設定しようとしました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一方の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをもう一方のコントロールに接続するプロセスを完了させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを別のコントロールに接続するプロセスを終了します。 これは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> メソッドに相当します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティによって参照されるパーソナル化オブジェクトが変更可能であることを保証します。これは、接続を形成すること自体がパーソナル化の一種であるために必要です。 次に、メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> オブジェクトが `null`されていないことを確認し、最後に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティによって参照されるコントロールが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールを拡張する必要がある開発者は、派生クラスでこのメソッドをオーバーライドすることが必要になる場合があります。 1つの方法として、基本メソッドを呼び出して、追加のカスタム処理を追加したり、コントロール間の接続を完了するプロセス全体を完全にカスタマイズしたりすることができます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールを編集するプロセスを完了させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを編集するプロセスを終了します。 これは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> メソッドに相当します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティによって参照されるパーソナル化オブジェクトが変更可能であることを保証します。これは、コントロールの編集が、パーソナル化の変更を必要とするプロセスであるために必要です。 次に、メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> オブジェクトが `null`されていないことを確認します。これにより、現在選択されている <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールが変更され、最後に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> プロパティによって参照されるコントロールが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールを拡張する必要がある開発者は、派生クラスでこのメソッドをオーバーライドすることが必要になる場合があります。 1つの方法として、基本メソッドを呼び出して、追加のカスタム処理を追加したり、コントロールの編集を完了するプロセス全体を完全にカスタマイズしたりすることができます。 たとえば、override メソッドでは、最初に基本メソッドを呼び出した後、変更内容を確認するコードを追加し、確認のために変更の一覧をエンドユーザーに対して表示します。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールから重要な状態情報をエクスポートしようとしたときに表示される警告メッセージのテキストを取得または設定します。</summary>
        <value>警告メッセージが含まれた文字列。 既定のメッセージは、.NET Framework が提供するカルチャ固有の値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールから機微な状態データをエクスポートしようとしたときに、エクスポートされているデータのいずれかが、ソースコードで機微とマークされたメンバーから取得された場合、メッセージボックスに警告メッセージが表示され、機密データがエクスポートされていることが通知され、エクスポートをキャンセルできるようになります。 開発者は、`[Personalizable]` 属性の `isSensitive` パラメーターをメンバーの `true` に設定することにより、特定のメンバーのデータを機密としてマークできます。 この属性とパラメーターの詳細については、<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> クラスを参照してください。  
  
> [!IMPORTANT]
>  Web パーツのエクスポート機能を使用すると、機密データが承認されていないユーザーにエクスポートされる可能性があります。 この脅威から保護する方法の詳細については、「 [Web パーツページのセキュリティ](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)保護」を参照してください。  
  
 既定のメッセージは、ユーザーがエクスポートを試行するたびに表示されます。 ただし、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> プロパティに値を割り当てることによって、カスタム警告メッセージを指定できます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> プロパティの宣言型の使用方法を示しています。  
  
 次の Web ページのコードでは、標準の <xref:System.Web.UI.WebControls.BulletedList> コントロールを使用して、それをゾーンに配置します。 コントロールは、実行時に <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールでラップされます。これにより、コントロールは真の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとして機能するようになります。 コントロールをエクスポート可能にするために、`ExportMode` 属性が `<asp:bulletedlist>` 要素に追加され、属性値が <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>に設定されています。これは、機微なデータと機微でないデータの両方をエクスポートできることを意味します。 `<asp:webpartmanager>` 要素では、`ExportSensitiveDataWarning` 属性にカスタム値が割り当てられていることにも注意してください。  
  
 コード例を使用するには、web.config ファイルにを追加して、Web パーツ記述ファイルをエクスポートできるようにする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 `<system.web>` セクション内で、次のマークアップのように `true`に `enableExport` 属性が設定された `<webParts>` 要素があることを確認します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 ブラウザーにページを読み込んだ後、リンクを含むコントロールのタイトルバーにある動詞メニュー (下向きの矢印で表されます) をクリックします。 動詞メニューで **[エクスポート]** を選択すると、カスタム警告と共にメッセージボックスが表示されます。 エクスポートを続行する場合は、**[OK]** をクリックします。これにより、XML 記述ファイルのローカルコピーを、コントロールに関するすべてのデータと共に保存できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ExportWebPart (webPart As WebPart, writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">データのエクスポート元となるコントロール。</param>
        <param name="writer">エクスポートされたデータを <see cref="T:System.Xml.XmlWriter" /> から XML 記述ファイルに書き込む <paramref name="webPart" />。</param>
        <summary>サーバー コントロールの状態データとプロパティ データが格納された XML 記述ファイルを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> メソッドは、`webPart` のさまざまな状態データとプロパティデータを XML ファイルにアセンブルします。 データには、そのアセンブリ、状態データ、プロパティデータなど、コントロール自体に関する情報が含まれます。 エクスポートを開始するユーザーは、ローカルコンピューターまたはネットワーク上のディスクに XML ファイルを保存できます。 その後、他のユーザーが説明ファイルを別のページまたは Web サイトにインポートし、状態とプロパティのデータを `webPart`の別のインスタンスに適用できます。 これにより、ユーザーがサーバーコントロールで設定を共有して再利用するための高速で便利な機構が提供されます。また、開発者は、エクスポートおよびインポートされたコントロールの外観と動作を制御することもできます。  
  
 `webPart` のプロパティは、既定ではエクスポートされません。 プロパティのエクスポートを有効にするには、ソースコードの `[Personalizable]` 属性でマークする必要があります。 必要に応じて、`[Personalizable]` 属性の `isSensitive` パラメーターを `true`に設定して、エクスポート可能なプロパティを機密データを含むものとしてマークすることもできます。 既定では、`isSensitive` は `false`です。 開発者は、パラメーターを `true` に設定して、データが機密情報であることを示すことができます。  
  
 有効にする`webPart`開発者の設定をエクスポートするには、その<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>プロパティの値をいずれか<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>(を含む、すべてのパーソナル化できると機微なプロパティです、) または<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>、機微なプロパティを除くすべてをエクスポートします。  
  
> [!IMPORTANT]
>  ユーザーがコントロールからデータをエクスポートしたり、データを他のコントロールにインポートできるようにしたりすると、セキュリティ上のリスクが生じます。 開発者は、上で説明した方法を使用して機密データを保護する必要があります。また、データを完全に公開するリスクを回避する必要がある場合は、`webPart` でのエクスポートを有効にしないでください。 Web パーツのセキュリティの問題の詳細については、「 [Web パーツページのセキュリティ保護](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。  
  
または 
 <paramref name="writer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> で参照されるコントロールのコレクションに格納されていません。  
  
または 
<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> の <paramref name="webPart" /> プロパティが、<see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> の値に設定されています。これは、<paramref name="webPart" /> のエクスポートが無効になっていることを示します。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Web パーツページのセキュリティ保護</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オーバーライドして、ユーザー インターフェイス (UI) のない <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにフォーカスが設定されるのを防ぎます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> メソッドは、基本 <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> メソッドをオーバーライドし、呼び出し元がメソッドを呼び出した場合に例外をスローします。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールには UI がないため、ユーザーには表示されないため、フォーカスをそれ自体に設定することはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出し元が、UI のないコントロールではサポートされていない <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> メソッドを呼び出そうとします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetConsumerConnectionPoints (webPart As WebPart) As ConsumerConnectionPointCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でコンシューマーとして動作するサーバー コントロール。</param>
        <summary>Web パーツ接続内でコンシューマーとして動作するサーバー コントロールから、コネクション ポイントとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> オブジェクトのコレクションを取得します。</summary>
        <returns>コンシューマーのすべてのコネクション ポイントが格納された <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツ接続には常に、データのプロバイダーとして機能する2つのコントロールが含まれ、もう1つはデータのコンシューマーとして機能します。 各コントロールには、コネクションポイントとして定義されている1つ以上のメソッドが必要です。 コンシューマーコントロールの場合、その接続ポイントはオブジェクト <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> ます。 コンシューマー接続ポイントの取得は、Web パーツ接続を形成するために必要な手順です。  
  
 コンシューマーは、接続を確立するために、少なくとも1つのコネクションポイントを常に持っている必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドは、コンシューマーコントロールを確認し、すべての接続ポイントのコレクションを取得します。 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールに接続ポイントがない場合、メソッドは空のコレクションを返します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドの使用方法を示します。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと、`<asp:webpartmanager>` 要素を含む Web ページ。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 Web ページの宣言型マークアップには、ユーザーコントロールとカスタムコントロールの両方の `Register` ディレクティブが含まれています。 `<asp:webpartmanager>` 要素、カスタムコントロールを格納する `<asp:webpartzone>` 要素、および `<asp:connectionszone>` 要素があります。 `Page_Load` メソッドで、コードは接続が既に存在するかどうかを確認し、存在しない場合はプロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティによって参照される静的接続のセットに新しい接続を追加します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> メソッドを使用して取得された <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> オブジェクトを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドに渡して、2つのコントロール間の接続を作成できるかどうかを判断することに注意してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 このコードと、このコードをコンパイルする手順については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要に関するセクションを参照してください。  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは、`<asp:connectionszone>` 要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、`Page_Load` メソッドに含まれるコードによって接続が既に作成されていることを確認します。 後のブラウザーセッションでこのページに戻ると、この静的接続は既に確立されているので、ページを読み込むたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentWebPartManager (page As Page) As WebPartManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> のインスタンスが含まれている Web ページ。</param>
        <summary>ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの現在のインスタンスへの参照を取得します。</summary>
        <returns>ページ上のコントロールの現在のインスタンスを参照する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドは、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールへの参照を取得するコンテキストで役立ちます。 この問題が発生する一般的なシナリオは、開発時に認識できないカスタムコントロールを作成する場合です。これは、ページ上の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの ID がどのようになるかということです。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドは静的であるため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールのインスタンスを必要とせずに直接呼び出すことができます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールなどの Web パーツコントロールセット内の一部のコントロールには、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールへの参照を取得できる <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> プロパティがあります。 そのため、このようなコントロールを操作する場合は、このプロパティを使用して参照を取得する必要があります。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの ID がわかっているコンテキストでコードを記述している場合 (Web ページ内にインラインでコードを記述する場合など)、ID を使用して <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを直接参照するのが最も簡単で効率的です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドの使用方法を示します。 この例には、カスタムサーバーコントロールと、コントロールをホストする Web ページの2つの部分があります。  
  
 カスタム <xref:System.Web.UI.WebControls.Label> コントロールは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> メソッドを使用して、現在のページの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの ID を取得し、ID を表示します。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 次のコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーン内のコントロールをホストする Web ページを提供します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 ブラウザーにページを読み込むと、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールの ID がカスタム <xref:System.Web.UI.WebControls.Label> コントロール内に表示されることがわかります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> が <see langword="null" /> です。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetDisplayTitle (webPart As WebPart) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">このメソッドが <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> の値を返す対象となるコントロール。</param>
        <summary><see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティの値が含まれた文字列を取得します。</summary>
        <returns><see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> の <paramref name="webPart" /> の計算された値が格納される文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `webPart`の <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> プロパティの計算値を取得します。 開発者が <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> プロパティに値を割り当てない場合、このメソッドによって、タイトルとして表示する値が生成されます。 無題のコントロールの計算値は、文字列に付加された数字で構成され、現在のゾーン内のコントロールのシーケンスを示す数値で構成されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コレクション内にありません。</exception>
        <block subset="none" type="overrides"><para>このメソッドをオーバーライドすると、既定の表示タイトルの計算方法を変更できます。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExportUrl (webPart As WebPart) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">エクスポートされる <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>ユーザーが <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールをエクスポートしようとするときの要求に含まれる相対仮想パスとクエリ文字列を取得します。</summary>
        <returns>コントロールのエクスポート要求を構成する相対仮想パスとクエリ文字列が含まれた文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> メソッドによって返される値は、コントロールを含むページのサーバーの場所への相対仮想パスと、サーバーに送信されるエクスポート要求を形成するクエリ文字列値が追加されたものです。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> メソッドは、悪意のあるスクリプトによる攻撃から保護するために、要求の送信を許可する前に文字列をエンコードします。  
  
> [!NOTE]
>  Web パーツアプリケーションのセキュリティ保護の詳細については、「 [Web パーツページのセキュリティ保護](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGenericWebPart (control As Control) As GenericWebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 内に存在し、実行時に <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> の子コントロールとしてラップされるサーバー コントロール。</param>
        <summary>サーバー コントロールが含まれた <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> コントロールのインスタンスへの参照を取得します。</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> を子コントロールとしてラップする <paramref name="control" />。 このメソッドは、<see langword="null" /> に <paramref name="control" /> が含まれていない場合は <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般に、開発者が Web パーツアプリケーションに参加するために <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに配置するコントロールには、<xref:System.Web.UI.WebControls.WebParts.WebPart> 基底クラスを継承する <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと、標準の ASP.NET コントロール、カスタムコントロール、またはユーザーコントロールのような他のサーバーコントロールの2つのカテゴリがあります。 これらのコントロールのいずれかが <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに配置されると、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの機能を利用できます。 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールには本質的にこの機能がありますが、他の種類のサーバーコントロールにはありません。 他のサーバーコントロールが <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに配置されるときに <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとして機能するようにするには、ASP.NET が <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールでラップします。 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールは <xref:System.Web.UI.WebControls.WebParts.WebPart> クラスから直接継承されるので、子コントロールに真の Web パーツ機能が提供されます。  
  
 多くの場合、ページ開発者は、ゾーン内のいずれかのサーバーコントロールを含む <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールへの参照を取得する必要があります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> メソッドを使用すると、<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールへの参照を取得できます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> メソッドの使用方法を示しています。 このコード例には、<xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーン内で宣言された <xref:System.Web.UI.WebControls.Calendar> コントロールが含まれています。 `Button1_Click` メソッドはまず、<xref:System.Web.UI.WebControls.Calendar> コントロールの ID をラベルに出力します。次に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> メソッドを使用して、カレンダーをラップする <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールへの参照を取得します。 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールの ID と子コントロール (<xref:System.Web.UI.WebControls.Calendar> コントロール) の ID は両方とも2番目のラベルに印刷されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetProviderConnectionPoints (webPart As WebPart) As ProviderConnectionPointCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">接続でプロバイダーとして動作するサーバー コントロール。</param>
        <summary>Web パーツ接続内でプロバイダーとして動作するサーバー コントロールから、コネクション ポイントとして機能できる <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> オブジェクトのコレクションを取得します。</summary>
        <returns>プロバイダーのすべてのコネクション ポイントが格納された <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツ接続には常に、データのプロバイダーとして機能する2つのコントロールが含まれ、もう1つはデータのコンシューマーとして機能します。 各コントロールには、コネクションポイントとして定義されている1つ以上のメソッドが必要です。 プロバイダーコントロールの場合、そのコネクションポイントはオブジェクト <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> ます。  
  
 接続を確立するには、プロバイダーに少なくとも1つのコネクションポイントが必要です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドは、プロバイダーコントロールを確認し、すべての接続ポイントのコレクションを取得します。 プロバイダー接続ポイントの取得は、Web パーツ接続を形成するために必要な手順です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドの使用方法を示します。  
  
 この例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと、`<asp:webpartmanager>` 要素を含む Web ページ。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 Web ページの宣言型マークアップには、ユーザーコントロールとカスタムコントロールの両方の `Register` ディレクティブが含まれています。 `<asp:webpartmanager>` 要素、カスタムコントロールを格納する `<asp:webpartzone>` 要素、および `<asp:connectionszone>` 要素があります。 `Page_Load` メソッドで、コードは接続が既に存在するかどうかを確認し、存在しない場合はプロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティによって参照される静的接続のセットに新しい接続を追加します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> メソッドを使用して取得された <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> オブジェクトを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> メソッドに渡して、2つのコントロール間の接続を作成できるかどうかを判断することに注意してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 この例の3番目の部分は、コントロールのソースコードです。 このコードと、このコードをコンパイルする手順については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要に関するセクションを参照してください。  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは、`<asp:connectionszone>` 要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、`Page_Load` メソッドに含まれるコードによって接続が既に作成されていることを確認します。 後のブラウザーセッションでこのページに戻ると、この静的接続は既に確立されているので、ページを読み込むたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader * string -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader * string -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">インポート元となる XML 記述ファイルから状態データとプロパティ データを読み取る <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="errorMessage">インポート中にエラーが発生した場合にユーザーに表示される <see cref="T:System.String" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの状態データとプロパティ データが格納された XML 記述ファイルをインポートし、コントロールにそのデータを適用します。</summary>
        <returns>インポート元となる XML 記述ファイルで参照される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> (または、<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> でラップされ、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> として扱われるサーバー コントロール)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> メソッドは、サーバーコントロールの <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> メソッドによって作成された XML 記述ファイルをインポートします。 これはインポートされる実際のサーバーコントロールではなく、コントロールに関する状態とプロパティデータを含む記述ファイルのみです。 説明ファイルで参照されているコントロールとアセンブリは、ユーザーが説明ファイルをインポートしようとしたサーバーで既に使用可能である必要があります。  
  
 開発者は、コントロールのインポートを有効にするために、インポートを有効にするページに <xref:System.Web.UI.WebControls.WebParts.CatalogZone> コントロールを追加する必要があります。 ゾーン内で、<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> コントロールを追加する必要があります。 このコントロールには、ユーザーがインポートする説明ファイルを参照および検索できるようにするファイルダイアログボックスが用意されています。  
  
 ユーザーが記述ファイルを見つけてインポートを開始すると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> メソッドによって説明ファイルが読み取られます。 エラーが発生せず、アセンブリとコントロールが見つかった場合は、サーバーコントロールが <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> コントロール内のカタログに追加され、説明ファイルに指定されているさまざまなプロパティと状態データがコントロールに適用されます。 ユーザーはコントロールを選択し、ページに追加できます。  
  
> [!IMPORTANT]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> メソッドと同様に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> メソッドは、セキュリティ上のリスクの可能性があります。 Web サイトにデータをインポートする必要があるため、悪意のあるユーザーが、インポートされた説明ファイルに不適切なデータを挿入したり、スクリプトコードを記述したりする可能性があります。 その場合、不適切なデータがページまたはデータベースに表示されるか、または挿入されたスクリプトが実行される可能性があります。 説明ファイルのインポートに関連する潜在的なリスクの概要と、それらのリスクを回避する方法については、「 [Web パーツページのセキュリティ保護](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.EndOfStreamException"><paramref name="reader" /> はこのファイルを読み取ることができませんでした。  
  
または 
 <paramref name="reader" /> は、インポート エラー メッセージを表示する必要がありましたが、ファイル内にそれが見つかりませんでした。  
  
または 
 <paramref name="reader" /> はファイルの末尾に到達しましたが、エクスポート データが格納された XML 要素が見つかりませんでした。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">Web パーツページのセキュリティ保護</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際には <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> クラスに実装されていても、ほとんどの場合コントロールの開発者に役立つメソッドのセットを構成したり分割したりするために使用する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> が、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> に分割されたさまざまなメソッドを参照できる、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> プロパティは、主に拡張機能のケースで使用される一連の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> メソッドを呼び出すための Api を公開します。  
  
 これらの内部メソッドを使用するように設計された方法は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> プロパティを使用してアクセスすることです。 このプロパティは保護されているので、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスから継承することで、このプロパティにアクセスして、<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> クラスのインスタンス内でメソッドを呼び出すことができます。  
  
> [!NOTE]
>  このプロパティは [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]の IntelliSense によって非表示にされます。 ただし、派生 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスでも、プロパティとそのさまざまなメンバーにアクセスできます。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールをページに追加できるかどうかを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web パーツ機能の柔軟性の一部として、実行時にサーバーコントロールを Web ページに追加する機能があります。 サーバーコントロール (カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、カスタムサーバーコントロール、ユーザーコントロール、または ASP.NET コントロール) を追加する一般的なシナリオがいくつかありますが、これにはさまざまな方法があります。  
  
 次の一般的なシナリオでは、Web パーツコントロールセットは、サーバーコントロールをページに追加しようとし、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドを呼び出して承認します。  
  
-   サーバーコントロールを追加するときに、<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン内の Web ページのマークアップでサーバーコントロールを宣言します。  
  
-   サーバーコントロールがプログラムによってゾーンに追加されたとき。  
  
-   ユーザーがコントロールの Web パーツカタログにサーバーコントロールをインポートするとき。  
  
-   既存のサーバーコントロールがパーソナル化データストアから読み込まれたとき。  
  
-   サーバーコントロールを <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> コントロールに追加して、サーバーコントロールのカタログで使用できるようにする場合。  
  
 コントロールが追加される各シナリオでは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドを呼び出して、コントロールを追加できるようにすべての承認条件が満たされていることを確認します。 コントロールが承認されると、フィルター処理のシナリオが存在しない場合と同様に、通常どおりに追加されます。 コントロールが承認されていない場合、Web パーツコントロールセットは、コンテキストに応じていくつかの方法で応答できます。 コントロールセットは、許可されていないパーツの追加をサイレントに失敗させることができます (ユーザーに通知する必要がない場合)。エラーメッセージを表示することも、<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> クラスのインスタンスをプレースホルダーとして追加することもできます。 このプレースホルダーオブジェクトはページには表示されませんが、承認されていないコントロールが除外されたことを示すためにページソースコードに表示されます。  
  
 コントロールが承認されているかどうかの決定は、承認フィルターです。 承認フィルターは、Web パーツコントロールセットの機能です。この機能を使用すると、開発者は、指定した条件を満たしていないコントロールをページから除外できます。  
  
 フィルター処理のシナリオを作成するには、開発者が2つの作業を行う必要があります。 最初に、シナリオで使用する予定の各 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティに、文字列値 (値は任意) を割り当てる必要があります。 また、コントロールが <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに配置されている場合は、コントロールが実行時にコントロールとして <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> ラップされ、このコントロールが <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティを継承するため、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではない他の種類のサーバーコントロールに対しても、このプロパティに値を割り当てることができます。  
  
 フィルター処理のシナリオを作成するために必要な2番目の手順は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> メソッドをオーバーライドするか、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントのイベントハンドラーを作成することです。 これらのメソッドでは、開発者は <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティを確認できます。また、コントロールが承認されていないことを値が示している場合は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドが `false`の値を返すことを保証します。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドを使用してカスタマイズされたフィルター処理シナリオを設定する方法のコード例と説明については、メソッドのオーバーロードに関するトピックを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAuthorized (webPart As WebPart) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">承認をチェックする対象の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロール。</param>
        <summary>ページへのコントロールの追加が承認されているかどうかを判断する最初の手順を実行します。</summary>
        <returns><paramref name="webPart" /> をページに追加できるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの承認を確認するために、Web パーツコントロールセットによって呼び出される最初のメソッドです。 このメソッドは、パラメーターとして `webPart` を受け取り、コントロールがページに追加されるかどうかを最終的に判断するプロセスを開始します。 特定のコントロールが承認されているかどうかを判断する必要がある場合は、コードからこのメソッドを直接呼び出します。  
  
 このメソッドは、コントロールが <xref:System.Web.UI.WebControls.WebParts.WebPart> クラスから継承されているかどうかを判断する最初のタスクを実行します。または、コントロールが <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> コントロールであるかどうかを判断し、存在する場合はそれに含まれる子コントロールの種類を決定します。 承認のタスクを完了するには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> のオーバーロードメソッドを呼び出します。  
  
   
  
## Examples  
 次のコード例は、コードから <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> メソッドを呼び出して、コントロールがページに追加されることが許可されているかどうかを判断する方法を示しています。  
  
 このコード例には、次の3つの部分があります。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドをオーバーライドするカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのフィルターを作成する Web ページ。  
  
-   コード例を実行する方法について説明します。  
  
 このコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> のオーバーロードメソッドをオーバーライドするカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを使用して、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティのカスタム処理を提供します。 このコントロールは `admin` のプロパティ値を確認し、値が存在する場合はコントロールを承認します。 別の値を持つコントロールは許可されていません。プロパティ値のないコントロールも、フィルター処理のシナリオに含まれないと見なされるため、承認されます。  
  
 このコード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイルメソッドを使用します。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 コード例の2番目の部分では、コントロールを除外する可能性があるフィルターを作成します。 次の Web ページには、`<asp:webpartzone>` 要素内の3つの ASP.NET サーバーコントロールが含まれています。 1番目と2番目のコントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティがそれぞれ異なる値に設定されており、3番目のコントロールではプロパティが割り当てられていないことに注意してください。 この承認値は実行時に確認でき、フィルターが開発者によって設定された条件に一致する場合は、コントロールをページに追加できます。 また、`Page_Load` メソッドでは、コードが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> メソッドを呼び出して、各コントロールが承認されているかどうかを判断し、その場合は各コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> プロパティを設定します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 コード例を使用するには、web.config ファイルに設定を追加して、Web パーツ記述ファイルのエクスポートを有効にする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 `<system.web>` セクション内で、次のマークアップのように `true`に `enableExport` 属性が設定された `<webParts>` 要素があることを確認します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーでページを読み込んだ後、最初のコントロールが表示されていることに注意してください。これは、オーバーライドされたメソッドの条件と一致するためです。 2番目のコントロールは、フィルターによって除外されるため、ページには追加されません。 3番目のコントロールも追加されます。これは、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが設定されていないためです。 いずれかのコントロールのタイトルバーで [動詞] メニューアイコンをクリックすると、それぞれの <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> プロパティ値が割り当てられているため、両方をエクスポートできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> が <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>このメソッドは、コードから直接呼び出されます。 承認プロセスをプログラムで制御できるようにするには、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> のオーバーロードメソッドをオーバーライドします。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAuthorized (type As Type, path As String, authorizationFilter As String, isShared As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">承認されているかどうかを確認するコントロールの <see cref="T:System.Type" />。</param>
        <param name="path">コントロールがユーザー コントロールの場合は、承認されるコントロールのソース ファイルへの相対アプリケーション パス。</param>
        <param name="authorizationFilter">コントロールをページに追加できるかどうかを判断して承認するために使用される、<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティに割り当てる任意の文字列値。</param>
        <param name="isShared">承認されているかどうかを確認するコントロールが共有コントロール (つまり、アプリケーションの多くのユーザーまたはすべてのユーザーに対して表示され、その <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> プロパティ値が <see langword="true" /> に設定されている) かどうかを示します。</param>
        <summary>ページへのコントロールの追加が承認されているかどうかを判断する最後の手順を実行します。</summary>
        <returns>ページへのコントロールの追加が承認されるかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> のオーバーロードメソッドは、コントロールがページに追加されることが承認されているかどうかを判断する最後の手順を実行します。 メソッドは、`type` が有効な型であること、およびチェックされるコントロールがユーザーコントロールである場合にのみ値を持つ `path` ことを保証します。 次に、重大な <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドを呼び出します。これにより、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントが発生します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドをオーバーライドして、コントロールがページに追加されることが許可されているかどうかを判断する方法を示します。  
  
 最初の手順では、コントロールを除外する可能性があるフィルターを作成します。 次の Web ページには、`<asp:webpartzone>` 要素内の3つの ASP.NET サーバーコントロールが含まれています。 1番目と2番目のコントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティがそれぞれ異なる値に設定されており、3番目のコントロールではプロパティが割り当てられていないことに注意してください。 この承認値は実行時に確認でき、フィルターが開発者によって設定された条件に一致する場合は、コントロールをページに追加できます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 2番目の手順では、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> メソッドをオーバーライドし、承認フィルターのカスタム処理を作成します。 このコードでは、まず、プロパティに値があるかどうかを確認します。これにより、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティを割り当てないコントロールが自動的に追加されることに注意してください。 コントロールにフィルターがある場合、コードはフィルター値が `admin`と等しい場合にのみ `true` を返します。 これは、ロールに応じて特定のユーザーに特定のコントロールを表示するために使用できる単純なメカニズムを示しています。 ロールを使用する完全な例はこのトピックでは扱いませんが、このコード例ではオーバーライドされたメソッドと同じロジックを使用できます。ただし、現在のユーザーが承認フィルターの値と一致するロールに存在するかどうかを確認できます。 をクリックし、そのユーザーに対してのみコントロールを追加します。 これにより、一部のユーザーがすべてのコントロールを表示するページを作成できるようになります。また、他のユーザーには選択したコントロールのみが表示されます。 これは、フィルターをチェックするロジックが、ロールを使用したかどうかを確認するためのものです。  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイルメソッドを使用します。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 ブラウザーでページを読み込んだ後、最初のコントロールが表示されていることに注意してください。これは、オーバーライドされたメソッドの条件と一致するためです。 2番目のコントロールは、フィルター値が除外されているため、ページに追加されません。 3番目のコントロールが追加されます。これは、<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティが設定されていないためです。 2番目のコントロールのプロパティ値を、最初のコントロールと一致するように変更した後、もう一度ページを実行すると、2番目のコントロールも追加されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> がユーザー コントロールで、<paramref name="path" /> が <see langword="null" /> または空の文字列 ("") のいずれかです。  
  
または 
 <paramref name="type" /> がユーザー コントロール以外で、<paramref name="path" /> に値が割り当てられています。</exception>
        <block subset="none" type="overrides"><para>このメソッドは、承認を確認するときに追加の処理を行う場合に、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスから継承することによってオーバーライドできます。 メソッドをオーバーライドして <paramref name="authorizationFilter" /> パラメーター内の特定の値を確認し、値に基づいてコントロールがページに追加されるかどうかを判断するブール値を返すことができます。  
  
承認フィルターを確認し、カスタム処理を提供するページ開発者に対しては、.aspx ページまたは分離コードファイルでこのインラインを実行するオプションがあります。クラスを継承する必要はありません。 ページで、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> メソッドの代替イベントハンドラーを宣言できます。 詳細と例については、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> メソッドを参照してください。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにより制御されるページ レベルのパーソナル化の情報に影響を与えるような、パーソナル化に関する変更が行われたかどうかを示す値を取得します。</summary>
        <value>パーソナル化に関する変更が行われたかどうかを示すブール値。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> プロパティを内部的に使用して、管理対象のページレベルのパーソナル化データが変更されたかどうかを追跡します。 パーソナル化データは、ユーザーがページレベルでさまざまなパーソナル化操作を実行するときに変更されます。たとえば、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの追加や削除、コントロールの接続や切断、コントロールの移動によるページのレイアウトの変更などの操作を行います。  
  
> [!NOTE]
>  ユーザーは、コントロールレベルで個人用設定を実行することもできます。つまり、特定のコントロールに個人用設定の変更が加えられ、変更はそのコントロールにのみ影響します。 たとえば、コントロールを編集したり、タイトルのテキストや背景色を変更したりします。 コントロールレベルのパーソナル化は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって追跡されるページレベルのパーソナル化データには影響しません。そのため、コントロールレベルのパーソナル化が発生した場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> プロパティ値は `true` に変更されません。  
  
 メソッドは保護されていて、呼び出し元が直接アクセスできない場合でも、呼び出し元が <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティに直接アクセスして、このプロパティの値を返すことができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">読み込む対象となる永続的な状態データを格納します。</param>
        <summary>前回のページ要求で保存され、後続の要求で復元する必要のある、コントロールの状態データを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> メソッドは、<xref:System.Web.UI.Control.EnableViewState%2A> プロパティが `false`に設定されている場合でも、ページのポストバック間で永続化されるプロパティデータを復元するのに役立ちます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="savedState" /> は有効な <see cref="P:System.Web.UI.PageStatePersister.ControlState" /> ではありません。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary>初期化プロセス中に後で使用するためにパーソナル化オブジェクトによって <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに渡されたカスタムのパーソナル化データを格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> メソッドは、保存された状態データを <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> オブジェクトの形式で提供します。 このデータは、Web パーツコントロールにパーソナル化データを読み込み、その他の初期化タスクを実行するために最終的に使用されます。  
  
> [!NOTE]
>  このメソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> メソッドが、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールにパーソナル化データを提供するために、関連付けられた <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> オブジェクトを最初に要求したときに開始されるメソッドのシーケンスによって呼び出されます。  
  
 このメソッドをコードから直接呼び出すことはできません。 ただし、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> メソッドを直接呼び出すこともできます。それ自体が <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> メソッドを呼び出し、パーソナル化データを返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスの <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> メソッドをオーバーライドできます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される <xref:System.Security.PermissionSet> オブジェクトは、型の逆シリアル化のインポート中に使用されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Security.PermissionSet" /> および <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> のアクセス許可のみを付与する <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> オブジェクトを取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される <xref:System.Security.PermissionSet> オブジェクトは、型の逆シリアル化以外のすべてのインポート中に使用されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveWebPart (webPart As WebPart, zone As WebPartZoneBase, zoneIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">移動される <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> またはその他のサーバー コントロール。</param>
        <param name="zone"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> の移動先の <paramref name="webPart" />。</param>
        <param name="zoneIndex"><paramref name="webPart" /> 内の他のコントロールに対する <paramref name="zone" /> の相対インデックスを示す整数。</param>
        <summary>1 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンから別のゾーンまたは同じゾーン内の新しい位置に、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはサーバー コントロールを移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 方法を使用して、`webPart` を同じゾーン内の新しい場所または別のゾーンに移動します。 このメソッドは、コードから直接呼び出すことができます。また、ユーザーが Web パーツユーザーインターフェイス (UI) のさまざまなオプションを使用してコントロールを新しい位置に移動したときにも呼び出されます。  
  
 `webPart` を移動する前に、いくつかの条件を満たす必要があります。これらのほとんどは、このトピックの「例外」セクションに記載されている項目によって示されています。 開始する <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに `webPart` が含まれていない場合は、ゾーンに移動できません。  
  
 条件が満たされた後、`webPart`を移動するには、次の一連の操作を実行します。  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントを発生させます。  
  
2.  `webPart` は、必要に応じて現在のゾーンから削除され、新しいゾーンまたは現在のゾーン内の新しい位置に追加されます。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントを発生させます。  
  
4.  元のゾーンと宛先の両方のゾーンのすべての <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの `zoneIndex` は、移動したコントロールを反映するようにリセットされます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドをコードから直接呼び出して、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをあるゾーンから別のゾーンに移動する方法を示しています。  
  
 このコード例には、次の3つの部分があります。  
  
-   表示モードを変更するためのユーザーコントロール。  
  
-   コントロールをホストする Web ページ。  
  
-   コード例を実行する方法について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 この例の2番目の部分は、2つのゾーンを含む Web ページで、それぞれに2つのサーバーコントロールが含まれています。 ユーザーがページの **[WebPart を移動]** ボタンをクリックすると、`Button1_Click` メソッドのコードによって、最初のゾーンから2番目のゾーンの新しい位置にコントロールが移動します。 コードはまず、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> メソッドを呼び出して、`list1` コントロールをラップする <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトを取得する必要があることに注意してください。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドの最初のパラメーターには <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールが必要であるのに対し、`list1` は ASP.NET サーバーコントロールであるため、この操作が必要になります。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 ページが読み込まれたら、**[WebPart WebPart]** ボタンをクリックします。リンクを含むコントロールが2番目のゾーンの中央の位置に移動することに注意してください。 このコントロールの移動は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドを呼び出すことによって、プログラムによって行われます。 **[表示モード]** ドロップダウンリストコントロールを使用して、ページをデザインモードに切り替えることもできます。デザインモードでは、コントロールを別のゾーンやゾーン内の別の位置にドラッグすることができます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドは、このようなユーザーが開始した移動を処理するために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによっても呼び出されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コレクションに格納されていません。  
  
または 
 <paramref name="zone" /> が、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> コントロールの <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コレクションに格納されていません。  
  
または 
<paramref name="webPart" /> コントロールの <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> プロパティで参照されるゾーンが <see langword="null" /> です。つまり、現在 <paramref name="webPart" /> がゾーン内にありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> または <paramref name="zone" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> に 0 より小さい値が指定されています。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> イベントを発生させ、イベントのハンドラーが存在する場合はそれを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドによって呼び出されます。これは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールがページに追加される承認を確認するときに行われます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドが呼び出されると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントが発生し、イベントのハンドラーメソッドがある場合はハンドラーが呼び出されます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを承認するプロセスは、重要な Web パーツ機能です。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによってゾーンに追加されたすべての <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールは、コントロールを追加できるかどうかを判断する承認プロセスを実行します。 既定では、Web パーツコントロールセットは、コントロールがゾーンに追加されないようにするためのフィルター選択条件を提供しません。 ただし、コントロールセットには、開発者が独自のフィルター条件を作成するために必要なメカニズムが用意されています。 これらのメカニズムを使用すると、カスタムのフィルター処理シナリオを作成できます。 たとえば、フィルターを作成すると、ユーザーが管理者ロールにある場合、ページが表示されたときに特定のコントロールがゾーンに追加され、ユーザーがユーザーロールに含まれていると、それらのコントロールは追加されません。  
  
 承認プロセス中にコントロールをフィルター処理するための機構は、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> と <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> のメソッド、および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> イベントです。  
  
 フィルター処理のシナリオを作成するには、基本的に2つのタスクがあります。 まず、フィルター処理する各 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティに文字列を割り当てます。 これらの文字列値には任意の値を指定できますが、フィルター処理に使用する条件を含める必要があります。 たとえば、管理者ユーザーがページを表示している場合にのみ、特定のコントロールをゾーンに追加したい場合は、プロパティに `admin` の文字列値を割り当てることができます。 次に、ASP.NET ロール機能を使用して、サイトのすべてのユーザーを管理者、マネージャー、ユーザーなどのさまざまなロールに追加できます。 ページを読み込んでいるときに、フィルター処理コードはユーザーのロールを確認し、チェックされるコントロールの承認フィルター値と比較します。ユーザーが管理者ロールにあり、コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 値を `admin`に設定している場合は、コントロールを追加できます。  
  
 フィルター処理シナリオを作成する2番目の手順は、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ値をチェックするコードを記述し、各コントロールがゾーンに追加される前に承認されているかどうかを判断することです。 このフィルター処理コードを配置する場所には、2つのオプションがあります。 最初のオプションは、ページ開発者に推奨されるオプションです。 Web ページサーバーのスクリプトコードまたはコード分離ファイルで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントを直接処理するメソッドを作成できます。 次のサンプルマークアップコードに示すように、ページの <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールのタグに `OnAuthorizeWebPart` 属性を追加して、メソッドをイベントに関連付けます。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 すべてのカスタムメソッドでは、フィルター条件に対して各 <xref:System.Web.UI.WebControls.WebParts.WebPart> 制御をチェックし、結果に基づいて <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> オブジェクトの <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> プロパティにブール値を割り当てて、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを追加できるかどうかを示す必要があります。 この例のコードでは、この方法を示しています。  
  
 フィルター処理コードを配置する場所の2つ目のオプションは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスを継承し、メソッドをオーバーライドしてフィルター条件をチェックすることです。 これを行うためにオーバーライドできる2つのメソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドまたは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドです。 どちらの方法も機能しますが、ほとんどの場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドをオーバーライドすることをお勧めします。これにより、承認プロセス全体をプログラムで制御できるようになります。一方、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドは、イベントを発生させ、ハンドラーを確認するための特定のタスクを1つだけ実行します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> メソッドをオーバーライドするカスタム <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスのコード例については、メソッドの <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> のオーバーロードに関する記述を参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> イベントのカスタムイベントハンドラーを設定して、ハンドラーが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> メソッドのカスタムフィルターコードを提供できるようにする方法を示しています。 この例は、ページ開発者がフィルター処理のシナリオを提供し、ページに追加される <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの承認を行うための一般的な方法です。  
  
 Web ページで、`<asp:webpartmanager>` 要素に、割り当てられているイベントハンドラーの名前を持つ `OnAuthorizeWebPart` 属性があることを確認します。 メソッドは、ページ上のコントロールのそれぞれの <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティ値が `admin` に設定されているかどうかを確認し、存在する場合は `true`を返します。これは、ページに承認されて追加されることを意味します。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> プロパティに値が割り当てられていないコントロールも追加されることに注意してください。これは、フィルター処理のシナリオに含まれないと想定されるためです。 これは、フィルター処理のシナリオにおける一般的な方法です。一部のコントロールはフィルター処理され、他のコントロールはすべてのユーザーが使用できると想定されるため、そうでない場合があります。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ロール内のユーザーの設定はこのトピックの範囲を超えているため、このコード例では、フィルター処理でユーザーロールを確認しません。 ただし、ユーザーロールに基づいてコントロールをフィルター処理するシナリオは、このフィルター処理機能の最も一般的な用途の1つです。 サイトにロールがあり、この方法でコントロールをフィルター処理するためにユーザーロールを確認する場合、メソッドは次のコードブロックのようになります (これは、ロールを使用しない前のコード例の単純なアプローチとは異なります)。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページとそのコントロールが読み込まれ、ページの接続がアクティブになってデータの共有が開始されることを示す <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> メソッドは、ページが読み込みプロセスを完了した後に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> イベントを発生させます。 メソッドは、イベントのハンドラーを追加する方法を提供します。  
  
 ページ開発者は、ページの `<asp:webpartmanager>` 要素に `OnConnectionsActivated` 属性を追加してから、カスタムメソッド名を属性に割り当てることにより、イベントのカスタムハンドラーを追加できます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスの <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> メソッドをオーバーライドできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページとそのコントロールが読み込まれ、接続をアクティブにするプロセスを開始できることを示す <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> メソッドは、接続をアクティブ化するプロセスをプログラムでカスタマイズするための機構を開発者に提供する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> イベントを発生させます。  
  
 ページ開発者は、ページの `<asp:webpartmanager>` 要素に `OnConnectionsActivating` 属性を追加してから、カスタムメソッド名を属性に割り当てることにより、イベントのカスタムハンドラーを追加できます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスの <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> メソッドをオーバーライドできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更された表示モードに関連付けられたイベント データを格納する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />。</param>
        <summary>Web ページ上で <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> コントロールが、ある表示モードから別の表示モードに切り替えるプロセスを完了したことを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本フォームの <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> メソッドは、単純に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> イベントを発生させます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> メソッドをオーバーライドできます。 たとえば、表示モードを変更した後、<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> プロパティに含まれている表示モードに応じて、ユーザーインターフェイス (UI) の外観を変更することができます。 または、特定のコンテンツを非表示にしたり、特定のコントロールを表示したりすることもできます。  
  
メソッドをオーバーライドする場合は、通常、オーバーライドされたメソッドの最後の手順として基本メソッドを呼び出す必要があります。これにより、最初にカスタムコードを実行し、最後にイベントを発生させて、モードの変更が完了したことを示します。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">変更中の表示モードに関連付けられたイベント データを格納する <see cref="T:System.EventArgs" />。</param>
        <summary>Web ページ上で <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> コントロールが、ある表示モードから別の表示モードに切り替えるプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本フォームの <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> メソッドは、単純に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> イベントを発生させます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> メソッドをオーバーライドできます。 たとえば、表示モードを変更しているときに、新しい表示モードがどのようになるかを (<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> プロパティを使用して) 確認し、新しい表示モードに応じてユーザーインターフェイス (UI) の内容を変更することができます。 カスタム表示モードを使用している場合は、カスタムモードを新しい表示モードにすると、特定のコントロールを表示することができます。  
  
このメソッドをオーバーライドする場合は、通常、オーバーライドされたメソッドの最初のステップとして基本メソッドを呼び出して、表示モードの変更が開始されたことを示すためにイベントが発生するようにする必要があります。 次に、新しい表示モードを実際に表示する前に、カスタムコードでユーザーインターフェイス (UI) を変更できます。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> コントロールの有効期間における最初のイベントとして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> メソッドは基本メソッドを呼び出します。これにより、コントロールの <xref:System.Web.UI.Control.Init> イベントが発生します。次に、ページ上の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールのインスタンスが1つだけであることを確認したり、パーソナル化データを読み込んだりするなど、いくつかの準備手順を実行します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">別の <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールがページ上に存在します。</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>Web ページに <see cref="E:System.Web.UI.Control.PreRender" /> コントロールを表示する直前に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> メソッドは、コントロールの <xref:System.Web.UI.Control.PreRender> イベントを発生させる基本メソッドを呼び出し、Web パーツコントロールを含むページに必要ないくつかのクライアントスクリプトを登録します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> コントロールを新しく選択した後またはその選択を解除した後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> イベントを発生させます。通常、開発者がユーザーインターフェイス (UI) の外観を変更する必要がある時点です。 たとえば、新しい <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを選択すると、Web パーツコントロールセットによって、新しく選択されたコントロールの表示が変更されます。 コントロールの選択がクリアされると、レンダリングは通常に戻ります。  
  
 ユーザーが編集のために特定の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを選択すると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドが呼び出されます。 ユーザーがコントロールの編集を終了し、コントロールの選択がクリアされたときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドが再度呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> イベントに関連するオプションがいくつかあります。これにより、開発者は、選択したコントロールが変更された後に発生するレンダリングをカスタマイズできます。 宣言型コードでは、<see langword="&lt;asp:webpartmanager&gt;" /> 要素内で <see langword="OnSelectedWebPartChanged" /> 属性を設定し、それにカスタムメソッドの名前を割り当てることができます。 カスタムメソッドでは、イベントが発生したときに、選択したコントロールの表示を変更できます。 別の方法として、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを継承し、メソッドをオーバーライドすることもできます。 3番目のオプションは、ゾーンレベルでレンダリングをカスタマイズすることです。たとえば、<see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> クラスから継承し、その <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> メソッドをオーバーライドして、編集プロセス中に選択およびクリアされたコントロールのレンダリングをカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> です。</param>
        <summary>現在選択されている <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> コントロールから選択を他に変更するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドは、現在選択されている <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを変更するプロセスの間に発生する <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> イベントを発生させます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、このメソッドと関連付けられたイベントを使用して、選択されたコントロールが変更されているプロセスをキャンセルする機会を提供します。 たとえば、メソッドは、プロセスをキャンセルする手段を提供するために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> メソッド内および <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> メソッド内で呼び出されます。 ユーザーが編集中のコントロールに対して cancel 動詞をクリックすると、コントロールが選択されなくなり、編集の変更は保存されません。これは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドによって編集の変更を取り消すことができるためです。  
  
> [!NOTE]
>  メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを別のコントロールに接続するプロセスを開始および終了するメソッドの実行中にも呼び出され、そのプロセスをキャンセルできるようにします。  
  
 ページ開発者は、宣言ページマークアップの `<asp:webpartmanager>` 要素に `OnSelectedWebPartChanging` 属性を追加し、カスタムメソッドの名前を属性に割り当てることによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">コントロールの削除に関連付けられたイベント データ。</param>
        <summary><see cref="E:System.Web.UI.Control.Unload" /> 基本イベントを発生させ、Web ページから <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> インスタンスを削除します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> コントロールがページに追加された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール (または <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに追加されたその他のサーバーコントロール) をページに追加する処理中に呼び出されます。  
  
 ページ開発者は、`OnWebPartAdded` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) を <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに追加するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> メソッドは、コントロールが追加されていることを示すために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> イベントを発生させます。 メソッドには、追加プロセスをキャンセルするオプションも用意されています。 コントロールが正常に追加された場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントは次のようになります。  
  
 ページ開発者は、関連付けられたイベントのカスタムハンドラーを指定できます。そのためには、Web ページの `<asp:webpartmanager>` 要素に `OnWebPartAdding` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを作成する開発者は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> メソッドをオーバーライドして、イベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> です。</param>
        <summary>コントロールがページから削除されたことを通知する <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントを発生させて、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール (またはその他のサーバーまたはユーザーコントロール) がページ上で正常に閉じられたことを示します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じるには、そのコントロールがページから削除され、レンダリングされないようにします。また、ページカタログと呼ばれる特別な保持オブジェクトに配置することもできます。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> コントロールに対応するページカタログは、各ページの終了した <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールへの参照を保持します。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> コントロールが <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーン内のページで宣言されている場合、ユーザーはページをカタログ表示モードに切り替えて、以前に閉じられたコントロールをページに戻すことができます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> メソッドは、開発者が <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントのカスタムハンドラーを作成する機会を提供します。 ページ開発者は、ページの `<asp:webpartmanager>` 要素に `OnWebPartClosed` 属性を追加してから、カスタムメソッド名を属性に割り当てることにより、イベントのカスタムハンドラーを追加できます。 開発者がこのメソッドで実行する便利なタスクの1つは、終了したコントロールの代わりにプレースホルダーを表示し、コントロールをページに戻す方法をユーザーに通知するツールヒントを使用して完了することです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> です。</param>
        <summary>ページから <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> コントロールまたはサーバー コントロールを削除するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> メソッドは、コントロールがページから閉じたり削除されたりしていることを示すために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントを発生させます。 メソッドには、終了プロセスをキャンセルするオプションも用意されています。 コントロールがページから正常に削除された場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントは次のようになります。  
  
 ページ開発者は、関連付けられたイベントのカスタムハンドラーを指定できます。そのためには、Web ページの `<asp:webpartmanager>` 要素に `OnWebPartClosing` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを作成する開発者は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> メソッドをオーバーライドして、イベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> コントロールがページから完全に削除された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール (または <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンに追加されるその他のサーバーコントロール) をページから削除する処理中に呼び出されます。  
  
 ページ開発者は、`OnWebPartDeleted` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" /> です。</param>
        <summary>動的な <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> コントロール (または、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに配置されたサーバー コントロールまたはユーザー コントロール) を削除するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的な <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのみを削除できます。コントロールが削除されると、コントロールインスタンスがページから完全に削除され、復元できなくなります。 動的な <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとは、Web ページのマークアップで宣言された静的コントロールではなく、プログラムまたは Web パーツカタログから追加されるコントロールです。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> メソッドは、コントロールがそのゾーンから完全に削除されていることを示すために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> イベントを発生させます。 メソッドでは、削除プロセスをキャンセルすることもできます。 コントロールがページから正常に削除された場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントは次のようになります。  
  
 ページ開発者は、関連付けられたイベントのカスタムハンドラーを指定できます。そのためには、Web ページの `<asp:webpartmanager>` 要素に `OnWebPartDeleting` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを作成する開発者は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> メソッドをオーバーライドして、イベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> コントロールがページ上の別の位置に移動された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> メソッドの最後で <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントを発生させます。これにより、イベントハンドラー内のコードが実行される前に、コントロールの移動プロセスが確実に完了します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントは、コントロールが現在のゾーン内または別のゾーン内で移動されたときに発生します。このイベントは、プログラムによって、またはコントロールをドラッグすることによって、移動が実行されるかどうかは関係ありません。  
  
 ページ開発者は、`OnWebPartMoved` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> ゾーン内の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) を移動するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPart> または他のサーバーコントロールがそのゾーン内または別のゾーン内で移動されるときに発生する、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントを発生させます。 メソッドは、移動プロセスをキャンセルする機会も提供します。 移動が正常に完了した場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントは次のようになります。  
  
 ページ開発者は、関連付けられたイベントのカスタムハンドラーを指定できます。そのためには、Web ページの `<asp:webpartmanager>` 要素に `OnWebPartMoving` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを作成する開発者は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> メソッドをオーバーライドして、イベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> コントロールの間に接続が確立された後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> メソッドの最後に対応するイベントを発生させます。これにより、イベントハンドラー内のコードが実行される前に、2つのコントロールを接続するために必要な手順が完了します。  
  
 メソッドを使用すると、接続の作成プロセスをプログラムで制御できます。関連イベントは、ユーザーインターフェイス (UI) を更新したり、接続が確立されたことをユーザーに通知したりするのに便利なポイントです。  
  
 ページ開発者は、`OnWebPartsConnected` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> ゾーンに配置されている 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の間に接続を確立するプロセスを実行しているときに発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> メソッドは、2つのコントロールが接続を確立しようとしたときに発生する <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> イベントを発生させます。 メソッドは、接続試行をキャンセルする機会を提供します。 接続に成功した場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントは次のようになります。  
  
 ページ開発者は、関連付けられたイベントのカスタムハンドラーを指定できます。そのためには、Web ページの `<asp:webpartmanager>` 要素に `OnWebPartsConnecting` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを作成する開発者は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> メソッドをオーバーライドして、イベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> コントロール間の接続が終了した後に発生する、<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドの最後に対応するイベントを発生させます。これにより、2つのコントロール間の接続を終了するプロセスが実行されます。  
  
 メソッドは、接続を終了するプロセスをプログラムで制御することにより、開発者がユーザーに通知したり、ユーザーインターフェイス (UI) に変更を加えたり、アプリケーションにその他の変更を加えたりできるようにします。  
  
 ページ開発者は、`OnWebPartsDisconnected` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを含んでいる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" /> です。</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> ゾーン内の 2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の接続を終了するプロセスを実行していることを示す、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> メソッドは、2つのコントロールが接続を終了するときに発生する <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを発生させます。 メソッドは、切断プロセスを取り消す機会を提供します。 接続が正常に削除された場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントは次のようになります。  
  
 ページ開発者は、関連付けられたイベントのカスタムハンドラーを指定できます。そのためには、Web ページの `<asp:webpartmanager>` 要素に `OnWebPartsDisconnecting` 属性を追加し、カスタムメソッド名を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを作成する開発者は、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> メソッドをオーバーライドして、イベント処理をカスタマイズできます。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページのパーソナル化データが格納されたオブジェクトへの参照を取得します。</summary>
        <value>パーソナル化データが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを使用してページに関連付けられた <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> オブジェクトにアクセスする手段を提供します。 このプロパティを使用すると、パーソナル化オブジェクトのさまざまなメンバーにアクセスできます。 たとえば、<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> メソッドを使用して、ページのパーソナル化スコープを共有からユーザースコープに切り替えることができます。また、その逆も可能です。 また、ページの現在のパーソナル化スコープ、ページで個人用設定が有効になっているかどうか、パーソナル化データで使用されているプロバイダーなどを確認することもできます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティによって参照されるデータは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって追跡されるページレベルのパーソナル化データのみであることに注意してください。 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのパーソナル化できるプロパティの値など、コントロール固有のパーソナル化データは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティの一部ではありません。  
  
> [!NOTE]
>  Web パーツパーソナル化の詳細については、「 [Web パーツパーソナル化の概要](https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100))」を参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティをプログラムで使用する方法を示しています。  
  
 次の Web ページでは、ユーザーが編集モードに入り、<xref:System.Web.UI.WebControls.Calendar> コントロールの特定の側面を編集することができます。 **[スコープの切り替え]** ボタンをクリックすると、ページがユーザーまたは共有のパーソナル化スコープに切り替わります。 **[編集モード]** ボタンと **[ブラウズモード]** ボタンを選択すると、ページが適切な表示モードに切り替わります。 ファイルの `<script>` タグセクションで、イベントを処理する2つのメソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティを使用して、基になるオブジェクトの有用なメンバーにアクセスすることに注意してください。 具体的には、これらのメソッドは、<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> メソッドと、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> プロパティを介してアクセスされるオブジェクトの <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> プロパティを使用します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 コード例を実行するには、ユーザーが共有スコープのページを個人用に設定できるようにする必要もあります。 次のマークアップのように、`<system.web>` セクション内の web.config ファイルにエントリを追加します。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 ブラウザーでページを読み込んだ後、**[スコープの切り替え]** ボタンをクリックすると、スコープが共有されていることがわかります。 **[編集モード]** をクリックして表示モードを変更し、表示されているコントロールの動詞メニューをクリックして、メニューから **[編集]** を選択します。 両方の編集コントロールのユーザーインターフェイス (UI) が表示されていることに注意してください。 次に、**[参照モード]** をクリックして、通常のブラウズに戻ります。 ページが共有スコープ内にあると表示されている場合は、**[スコープの切り替え]** をもう一度クリックして、ページがユーザースコープにあることを確認します。 次に、同じ手順に従ってコントロールをもう一度編集しますが、編集 UI には <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> コントロールが表示されないことに注意してください。 これは、このコントロールが、ページが共有パーソナル化スコープ内にある場合にのみ機能するためです。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web パーツパーソナル化の概要</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで、Web ページ内における <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールのドラッグなど、さまざまなパーソナル化機能に使用するクライアント側スクリプトを生成できるようにします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ページに書き込むコントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>オーバーライドして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールが何らかの内容を表示するのを防ぎます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールの状態データを保存し、今後このコントロールが含まれた Web ページを要求されたときにそのデータを復元できるようにします。</summary>
        <returns>コントロールの保存した状態データを格納する <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> メソッドは、<xref:System.Web.UI.Control.EnableViewState%2A> プロパティが `false`に設定されている場合でも、ページポストバック間で永続化する必要があるプロパティの状態データを保存します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールによって管理されるカスタムのパーソナル化状態データを保存します。これにより、ページの再読み込みを行うたびにこのデータを読み込めるようになります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> メソッドは、パーソナル化のプロセスにおいて重要です。これは、今後のブラウザーセッション用に個人用に設定されたユーザー設定を保存し、ページにアクセスできるようにするためです。 メソッドは、カスタムのパーソナル化状態データを保存します。これには、次のような項目が含まれます。たとえば、ページに追加された、またはページから削除された動的 <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールです。ページ上で移動されたコントロール。作成または削除された動的接続。  
  
 このメソッドをコードから直接呼び出すことはできません。 ただし、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> メソッドを呼び出すこともできます。このメソッド自体がこのメソッドを呼び出して、パーソナル化データを保存します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者は、派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスでこのメソッドをオーバーライドして、パーソナル化データを保存するプロセスをカスタマイズできます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>別のコントロールとの接続を編集または作成するために現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールへの参照を取得します。</summary>
        <value>接続の編集または接続の構成のために現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> プロパティは、編集のために現在選択されている <xref:System.Web.UI.WebControls.WebParts.WebPart> または他のコントロールとの接続を作成するために、現在選択されている他のサーバーコントロールへの参照を返します。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールには、コントロールを選択するプロセスを処理するための便利なメソッドとイベントがいくつか用意されています。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> イベントは、コントロールが選択された直後で、変更が行われる前に発生します。 コントロールを選択した後に操作を実行するには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドをオーバーライドします。 たとえば、選択されていてもまだ変更されていないコントロールの外観を変更して、どのコントロールが選択されているかを視覚的に強調することができます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> イベントは、選択したコントロールが変更された直後に発生します。 コントロールを変更した後に操作を実行するには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールの選択を変更して Web ページ上の別のコントロールに移動した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> メソッドと組み合わせて使用すると、選択したコントロールのユーザーインターフェイス (UI) を変更できます。 たとえば、ユーザーがページをデザインモードに切り替えた場合 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>)、新しい位置にドラッグする目的で <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを選択した場合は、選択したコントロールの表示を変更するのが一般的です。たとえば、選択した境界線や背景色を変更することができます。  
  
> [!NOTE]
>  イベントの使用方法の詳細については、「[方法: Web フォームアプリケーションでイベントを使用する](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上で現在選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールの変更プロセス中に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドと組み合わせて使用できます。 ページ開発者は、`OnSelectedWebPartChanging` 属性をページの `<asp:webpartmanager>` 要素に追加し、属性の値をそのイベントを処理するカスタムメソッドの名前に設定することにより、コード内にイベントハンドラーを作成できます。  
  
 このイベントは、コントロール間の接続を開始または終了するプロセス、およびコントロールの編集を開始および終了する処理中に発生します。 詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> メソッドを参照してください。  
  
 通常、選択したコントロールを変更するユーザーの操作の直接的な結果として <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> イベントが発生した場合、イベントを取り消すことができます。 ただし、イベントを取り消すことができないシナリオもあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> コントロールが削除された場合 <xref:System.Web.UI.WebControls.WebParts.WebPart>、そのコントロールに含まれるコントロールはすべて閉じられる必要があります。それ以外の場合は、孤立します。 この場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールはユーザーではなく <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じ、現在選択されているコントロールと、中断することなく選択を変更するタイミングを決定して、すべてのコントロールをクリーンアップするプロセスを完了できるようにする必要があります。 したがって、このシナリオでは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> メソッドを取り消すことができません。 キャンセルできる関連イベントについては、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントを参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールのカスタムのパーソナル化データが変更されたことを示すフラグを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> メソッドは、最終的に Web パーツコントロールセット内のパーソナル化コンポーネントが更新されたパーソナル化データを保存するフラグを設定します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって追跡されるパーソナル化データの変更を引き起こす可能性のあるシナリオの詳細については、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティを参照してください。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> メソッドは、コードから直接呼び出すことはできません。また、Web パーツパーソナル化機能の一部として Web パーツコントロールセットによって内部的に使用されるため、オーバーライドすることはできません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>メソッドは、派生 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスによって呼び出すことができます。 これは、Web パーツコントロールセットのパーソナル化コンポーネントをカスタマイズする必要があるため、パーソナル化データのフラグを設定するプロセスを制御する必要がある場合に便利です。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetSelectedWebPart (webPart As WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">選択されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール。</param>
        <summary>現在選択されている <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> コントロールまたはサーバー コントロールと同じ <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> プロパティ値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> メソッドは、`webPart` パラメーターによって指定されたコントロールの編集を開始または終了するプロセスと、`webPart`を含む接続を開始または終了するプロセスの間に呼び出されます。  
  
 編集および接続プロセスの開始時に、`webPart` は編集対象として選択されたコントロール、または接続を入力するためのコントロールです。  
  
 編集および接続プロセスの最後に、`null` が <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> メソッドに渡されます。これにより、現在選択されているコントロールが選択されなくなります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールにスキンを適用できないように、空の文字列 ("") を取得または設定します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールへのスキンの割り当てができないようにする空の文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> プロパティは、継承された <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> プロパティをオーバーライドして、スキンを使用した非表示のコントロールである <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールを防止します。 プロパティの実装は、常に `get` アクセサーから空の文字列を返すことによってスキンが割り当てられないようにし、`set` アクセサーに値を設定しようとした場合は常に例外をスローします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">プロパティ値を設定しようとしました。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の静的接続として定義されているすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> オブジェクトのコレクションへの参照を取得します。</summary>
        <value>ページ上のすべての静的接続が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティは、ページ上のすべての静的接続を追跡および管理するために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって使用されます。 静的接続は、動的接続とは対照的に、ページが表示されるたびにページに追加する必要はありません。  
  
 このプロパティによって参照されるコレクションには、ページ上に存在するすべての静的接続が含まれます。これらの接続は、プログラムによって作成されるか、ページのマークアップ内の `<asp:webpartconnection>` 要素で指定されます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティをプログラムで使用する方法を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツページの表示モードを変更できるユーザーコントロール。  
  
-   2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとカスタムインターフェイスを含むソースコードファイル。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールと、`<asp:webpartmanager>` 要素を含む Web ページ。  
  
-   ブラウザーでのこの例の動作について説明します。  
  
 次のコードには、例の Web ページ部分のみが含まれています。 また、この例の最初の2つの部分 (カスタムのユーザーコントロールとカスタムコントロールおよびインターフェイスのソースコード) を取得する必要もあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要に関するセクションを参照してください。 このトピックでは、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをコンパイルするためのオプションについても説明します。  
  
 コード例の3番目の部分は、Web ページです。 ページの宣言型マークアップには、ユーザーコントロールとカスタムコントロールの両方に対する `Register` ディレクティブが含まれています。 `<asp:webpartmanager>` 要素、カスタムコントロールを格納する `<asp:webpartzone>` 要素、および `<asp:connectionszone>` 要素があります。 `Page_Load` メソッドで、コードは接続が既に存在するかどうかを確認し、存在しない場合はプロバイダー、コンシューマー、およびそれぞれの接続ポイントを定義し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> プロパティによって参照される静的接続のセットに新しい接続を追加します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 ブラウザーに Web ページを読み込んだ後、**[表示モード]** ドロップダウンリストコントロールをクリックし、**[接続]** を選択してページを接続モードに切り替えます。 Connect モードでは、`<asp:connectionszone>` 要素を使用して、コントロール間の接続を作成できます。 接続モードで、**郵便番号**コントロールのタイトルバーにある下向きの矢印をクリックして動詞メニューをアクティブにし、**[接続]** をクリックします。 接続ユーザーインターフェイス (UI) が表示されたら、`Page_Load` メソッドに含まれるコードによって接続が既に作成されていることを確認します。 後のブラウザーセッションでこのページに戻ると、この静的接続は既に確立されているので、ページを読み込むたびに再作成する必要はありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の Web ページ上で使用できるすべての表示モードの読み取り専用のコレクションを取得します。</summary>
        <value>特定の Web ページ上で使用できる <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> オブジェクトのセットが格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティには、ページ上に存在するゾーンコントロールの種類に応じて、ページで実際に使用可能な表示モードのみが含まれます。  
  
> [!NOTE]
>  表示モードは無効にすることができます。表示モードが無効になっていると、その表示モードをサポートしている対応する種類のゾーンがページに存在する場合でも、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> コレクションには追加されません。  
  
 ブラウズモードとデザインモードは常にサポートされています。 表示モードは、編集、カタログ、および接続モードによって異なります。 これらの表示モードはそれぞれ、特定の種類の <xref:System.Web.UI.WebControls.WebParts.ToolZone> コントロールに関連付けられています。 Web ページに特別に型指定されたゾーンが存在し、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティによって参照されるコレクションに特定の表示モードが追加されます。 たとえば、Web ページに <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーンではなく <xref:System.Web.UI.WebControls.WebParts.EditorZone> ゾーンが含まれている場合、編集表示モードは、そのページでサポートされているモードの1つですが、カタログ表示モードはサポートされていません。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> プロパティとは異なります。このプロパティは、特定のページでサポートされていないすべての表示モードを含む、現在の <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールで使用できるすべての表示モードを含むコレクションを参照します。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> プロパティをプログラムで使用する方法を示しています。 このコードでは、このプロパティを使用して、現在の Web ページで使用可能な表示モードのみを一覧に設定します。  
  
 このページには、[参照]、[デザイン]、[編集] という3つのサポートされている表示モードがあります。 最初の2つは常に使用可能であり、このコード例では、このページには <xref:System.Web.UI.WebControls.WebParts.EditorZone> コントロールが含まれているので、編集モードを使用できます。 対応するゾーンがこのページにないため、カタログと接続の表示モードは表示されません。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 ブラウザーにページを読み込むと、ドロップダウンリストコントロールを使用して、ページをブラウズモードからデザインモードに切り替えてから編集モードに切り替えることができます。 編集モードでは、いずれかのサーバーコントロールのヘッダーのドロップダウン動詞メニューをクリックし、**[編集]** を選択してコントロールを編集することができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web パーツのページ表示モード</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty : bool" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールによって管理されているカスタムのパーソナル化状態データが Web ページ上で変更されたかどうかを示す値を取得します。</summary>
        <value>パーソナル化状態データが変更されたかどうかを示すブール値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって管理されるパーソナル化状態データが変更されたかどうかを呼び出し元が判断するための方法を提供します。 ページレイアウトの変更、接続の作成または削除、コントロールの追加や削除などによってページレベルの詳細をカスタマイズすると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって管理されるパーソナル化データが変更されます。 これは、呼び出し元に対して、呼び出し元が直接アクセスできない protected <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> プロパティの値を呼び出し元に返すパススルーメソッドです。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティは、パーソナル化できるプロパティ値、または個々の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールの外観に影響を与える個々のプロパティが変更されたかどうかを示すものではありません。 コントロールレベルのパーソナル化は、各コントロールに対して個別に追跡されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティは、ページレベルで、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって管理されているパーソナル化データが変更されたかどうかのみを示します。  
  
 次の一覧は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティが `true`の値を返すようにするパーソナル化の一般的なインスタンスを示しています。これは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールにいくつかのパーソナル化データが変更されていることを示しています。  
  
-   ページ上の静的な <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール (またはサーバーコントロールまたはユーザーコントロール) を閉じる。  
  
-   閉じた静的な <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールをページカタログからページに復元する。  
  
-   ゾーン内または別のゾーン内の任意のコントロールを移動します。  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールのカタログからのコントロールの追加、またはプログラムによるコントロールの追加。  
  
-   プログラムによって、または接続ユーザーインターフェイス (UI) を使用して、2つの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール間の接続を作成する。  
  
-   プログラムによって、または接続 UI を使用して、2つの <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール間の接続を削除します。  
  
 このプロパティ値にアクセスするには、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールインスタンスを <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> インターフェイスにキャストする必要があります。その後、<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> のプロパティ値を読み取ることができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールのパーソナル化データが変更される原因となる一般的なページパーソナル化インスタンスを示すために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> プロパティを簡単に使用する方法を示しています。  
  
 このコード例には、次の4つの部分があります。  
  
-   Web パーツコントロールを含むページの表示モードを変更できるユーザーコントロール。  
  
-   接続できる2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールのコードと、インターフェイスを含むソースファイル。  
  
-   すべてのコントロールをホストする Web ページ。  
  
-   コード例の動作について説明します。  
  
 コード例の最初の部分は、表示モードを変更するためのユーザーコントロールです。 ユーザーコントロールのソースコードは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> クラスの概要の「例」のセクションから入手できます。 表示モードとユーザーコントロールの動作の詳細については、「[チュートリアル: Web パーツページでの表示モードの変更](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)」を参照してください。  
  
 この例の2番目の部分は、カスタムコントロールとインターフェイスを含むソースファイルです。 `IZipCode` インターフェイスが1つのメソッドを公開しており、カスタム `ZipCodeWebPart` コントロールに実装されているこのメソッドは、接続シナリオで `ZipCodeWebPart` をプロバイダーとして機能させるためのコールバックメソッドとして機能することに注意してください。 もう1つのコントロールである `WeatherWebPart`は、接続のコンシューマーコントロールとして機能します。`ZipCodeWebPart`によって提供される特定のインターフェイスを使用できます。 実際のアプリケーションでは、`WeatherWebPart` がプロバイダーからパーソナライズされた郵便番号の値を使用して、ユーザーに気象情報を視覚的に提供することがあります。  
  
 コード例を実行するには、このソースコードをコンパイルする必要があります。 これを明示的にコンパイルし、生成されたアセンブリを Web サイトの Bin フォルダーまたはグローバルアセンブリキャッシュに格納することができます。 または、ソースコードをサイトの App_Code フォルダーに配置して、実行時に動的にコンパイルされるようにすることもできます。 このコード例では、動的コンパイルを使用します。このため、Web ページの上部にあるこのコンポーネントの `Register` ディレクティブには、`Assembly` 属性のない `TagPrefix` 属性と `Namespace` 属性のみが含まれていることに注意してください。 のコンパイル方法を示すチュートリアルについては、「[チュートリアル: カスタム Web サーバーコントロールの開発と使用](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)」を参照してください。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 コード例の3番目の部分は、Web ページです。 2つの <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンが含まれており、最初の2つのカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを含んでいることに注意してください。 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーンもあります。これには、ユーザーがページに追加できる標準の <xref:System.Web.UI.WebControls.Calendar> コントロールが含まれています。 `<asp:connectionszone>` 要素は、ユーザーがコントロール間の接続を作成するための接続 UI を提供します。 `Page_PreRender` メソッドで、パーソナル化データが変更されたかどうかを確認し、存在する場合は `Label1`のテキストを更新することに注意してください。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 ブラウザーでページを読み込んだ後、このトピックの「解説」に記載されているいくつかのシナリオを作成して、パーソナル化データを変更してみてください。 さまざまな変更を加えるときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって追跡されるパーソナル化シナリオの1つが変更されると、`Label1` コントロールのテキストが表示され、パーソナル化データが変更されたことが示されます。 たとえば、次のように操作できます。  
  
-   **[WebPart コントロールの接続]** ボタンをクリックして、コントロール間の接続を作成します。  
  
-   **[表示モード]** ドロップダウンリストコントロールを使用して、ページをカタログモードに切り替え、 **[マイカレンダー** ] コントロールを2番目の <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンに追加します。  
  
-   ページをブラウズモードに戻して、**[マイカレンダー]** コントロールの動詞メニュー (タイトルバーに矢印の記号が表示されます) をクリックし、**[閉じる]** をクリックして閉じ、ページカタログに追加します。  
  
-   ページをカタログモードに戻し、ページに **[My Calendar** ] コントロールを追加します。  
  
-   **[表示モード]** コントロールを使用して、ページをデザインモードに切り替え、コントロールのレイアウトを別のゾーンまたは同じゾーン内の別の位置にドラッグして配置を変更します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberSignature Language="F#" Value="abstract member System.Web.UI.WebControls.WebParts.IPersonalizable.Load : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.System.Web.UI.WebControls.WebParts.IPersonalizable.Load : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Load state" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">読み込む状態データを含む <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに読み込む必要がある、以前に保存したカスタムのパーソナル化状態データを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> メソッドを実装したもので、Web パーツコントロールセットがプロテクト <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> メソッドに直接アクセスする方法を提供します。 このメソッドが呼び出されると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって管理されていて、初期化プロセスで後で使用するために永続的なデータストアに保存されたカスタム個人用データが格納されます。  
  
> [!NOTE]
>  ほとんどの場合、ページおよびコントロールの開発者コードは、このメソッドを呼び出す必要はありません。これは、主にパーソナル化データを取得するための機構として Web パーツコントロールセットによって使用されるためです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者がこのメソッドを使用するシナリオの1つは、Web パーツコントロールセットによって提供されるものの代わりに使用するカスタムパーソナル化フレームワークを開発している場合です。 このような場合、開発者は <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを継承し、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> メソッドをオーバーライドして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> オブジェクトのカスタム実装を返すことができます。 カスタム <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> オブジェクトは、適切なタイミングで <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> メソッドの実装を呼び出して、カスタムパーソナル化データを読み込みます。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberSignature Language="F#" Value="abstract member System.Web.UI.WebControls.WebParts.IPersonalizable.Save : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.System.Web.UI.WebControls.WebParts.IPersonalizable.Save : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.System.Web.UI.WebControls.WebParts.IPersonalizable.Save state" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">保存する状態データを格納する <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />。</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールで管理されるカスタムのパーソナル化状態データを保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> メソッドは、<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> メソッドを実装したもので、Web パーツコントロールがプロテクト <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> メソッドに直接アクセスする方法を提供します。 このメソッドが呼び出されると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって管理されているすべての個人用データが、Web パーツアプリケーション用に構成された永続的なデータストアに保存されます。  
  
> [!NOTE]
>  ほとんどの場合、ページおよびコントロールの開発者コードは、このメソッドを呼び出す必要はありません。これは、パーソナル化データを保存するためのメカニズムとして、主に Web パーツコントロールセットによって使用されるためです。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>開発者がこのメソッドを使用するシナリオの1つとして、Web パーツコントロールセットによって提供されるものの代わりに使用するカスタムパーソナル化フレームワークを開発する場合があります。 このような場合、開発者は <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> クラスを継承し、<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> メソッドをオーバーライドして、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> オブジェクトのカスタム実装を返すことができます。 カスタム <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> オブジェクトは、適切なタイミングで <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> メソッドの実装を呼び出して、カスタムパーソナル化データを保存します。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>パーソナル化状態データを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールに適用し、基本メソッドを呼び出してコントロールのビューステート データに対する変更を追跡できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビューステートデータへの変更は、<xref:System.Web.UI.StateBag> オブジェクトに格納され、コントロールの <xref:System.Web.UI.Control.ViewState%2A> プロパティを使用してアクセスできます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>子コントロールを表示できるようにする値を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールおよびその子コントロールが表示されるかどうかを示す Boolean 値。 すべてのケースで <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、基本 <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> プロパティをオーバーライドして、常に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> プロパティの値 `true` を返します。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロール自体が表示されない場合でも、すべての子コントロールが既定で表示されるように、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> プロパティを `true` に設定する必要があります。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> プロパティの値を設定しようとすると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールが基本プロパティの動作をオーバーライドし、プロパティに値を割り当てないようにするため、常にエラーが生成されます。  
  
 このプロパティは、ビジュアルデザイナーではバインドできませんが、実行時にバインドできます。 詳細については、<xref:System.ComponentModel.BindableAttribute> を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このプロパティに値を割り当てようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに追加した後に発生し、そのコントロールが正常に追加されたことを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントは、動的コントロール (ページマークアップで宣言されているのではなく、プログラムによって追加されたコントロール) がゾーンに正常に追加されたことを示すために役立ちます。 イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> メソッドと共に、ユーザーインターフェイス (UI) を更新したり、コントロールが正常に追加されたことをユーザーに通知したりする方法を開発者に提供します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに追加するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> イベントは、コントロールをゾーンに追加するプロセスが開始された後に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> メソッドによって発生します。 このイベントは、プロセスが完了する前にキャンセルする機会を提供します。 追加プロセスが成功した場合、このイベントの後に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> イベントが続きます。  
  
 ページ開発者は、`OnWebPartAdding` 属性をページの `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることにより、イベントのカスタムハンドラーを提供できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) をページから削除すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントは、ユーザーまたはプログラムによってコントロールが正常に閉じられたことを示します。 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じるには、そのコントロールがページから削除され、レンダリングされないようにします。また、ページカタログと呼ばれる特別な保持オブジェクトに配置することもできます。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> コントロールに対応するページカタログは、各ページの終了した <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールへの参照を保持します。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> コントロールが <xref:System.Web.UI.WebControls.WebParts.CatalogZone> ゾーン内のページで宣言されている場合、ユーザーはページをカタログ表示モードに切り替えて、以前に閉じられたコントロールをページに戻すことができます。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> メソッドに関連付けられています。このメソッドは、イベントを発生させ、ハンドラーを提供します。  
  
 ページ開発者は、ページの `<asp:webpartmanager>` 要素に `OnWebPartClosed` 属性を追加してから、カスタムメソッド名を属性に割り当てることにより、イベントのカスタムハンドラーを追加できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) をページから削除するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールがコントロールを閉じる処理を行っているときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> メソッドによって発生します。 コントロールの削除が成功した場合、このイベントの後に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> イベントが続きます。  
  
 ページ開発者は、`OnWebPartClosed` 属性をページの `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを提供できます。  
  
 通常、<xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを終了したユーザーの直接的な結果として <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントが発生した場合、イベントを取り消すことができます。 ただし、イベントを取り消すことができないシナリオもあります。 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> コントロールが削除された場合 <xref:System.Web.UI.WebControls.WebParts.WebPart>、そのコントロールに含まれるコントロールはすべて閉じられる必要があります。それ以外の場合は、孤立します。 この場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、ユーザーではなく <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じます。 また、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールが、各コントロールを閉じるために <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> メソッドを呼び出しているときに、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントが発生した場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> はすべてのゾーンのコントロールをクリーンアップするタスクを完了する必要があるため、イベントを取り消すことはできません (仕様)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンから削除した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントは、動的コントロール (ページマークアップで宣言されているのではなく、プログラムによって追加されたコントロール) がゾーンから正常に削除されたことを示すために役立ちます。 イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> メソッドと共に、ユーザーインターフェイス (UI) を更新したり、コントロールが正常に削除されたことをユーザーに通知したりする方法を開発者に提供します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的な <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはその他のサーバー コントロールのインスタンスを <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンから完全に削除するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> イベントは、動的コントロール (プログラムによって追加された、またはユーザーが Web パーツユーザーインターフェイスを使用して追加されたコントロール) の削除処理中に、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> メソッドによって発生します。 イベントは、処理が完了する前にプロセスを取り消す機会を提供します。 削除プロセスが正常に完了した場合、このイベントの後に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> イベントが続きます。  
  
 ページ開発者は、`OnWebPartDeleting` 属性をページの `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることにより、イベントのカスタムハンドラーを提供できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロールを、Web ページ上の別の位置に移動した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、静的 (Web ページのマークアップで宣言) と動的コントロールの両方に適用されます。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> メソッドに関連付けられています。 イベントは移動の完了後に発生するため、開発者はイベントハンドラーを追加して、ユーザーに通知を提供したり、検証を行ったり、その他の操作を行ったりすることができます。 イベントハンドラーを追加するには、ページの `<asp:webpartmanager>` 要素に `OnWebPartMoved` 属性を追加し、カスタムメソッドの名前を属性に割り当てます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> ゾーンに配置されている <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> コントロールまたはその他のサーバー コントロールを移動するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPart> またはその他のサーバーコントロールが自身のゾーン内または別のゾーン内で移動されるときに発生します。 これは、ユーザーがコントロールをドラッグしたときと、プログラムによる移動があるときに発生する可能性があります。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> イベントは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> メソッドによって発生し、移動プロセスを完了する前にキャンセルする機会を提供します。 移動が完了し、コントロールが新しい位置に配置された場合、このイベントの後には <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> イベントが続きます。  
  
 ページ開発者は、`OnWebPartMoving` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを作成できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上の <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールで追跡されるすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> コントロールへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> コントロールのセットへの参照が格納された <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティは、ページ上の <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーン内に含まれるすべての <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを追跡するために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって使用されます。 コレクションは読み取り専用ですが、コレクションを通じて個々の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールにアクセスし、プログラムによって変更を加えることができます。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンの外部にあるページに <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを配置することができます。これにより、コントロールが <xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって追跡されたり、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> コレクション内で参照されたりしなくなります。 ただし、ゾーン外で <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを使用する理由はほとんどありません。そのため、Web パーツ機能が失われ、通常のサーバーコントロールとして機能します。  
  
 カスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、ユーザーコントロール、またはカスタムサーバーコントロールなど、ゾーンに配置できる任意の種類のコントロールを、実行時に <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとして扱うことができます。 <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールではないコントロールが <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンに配置されている場合、実行時に ASP.NET はコントロールを <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトでラップします。これにより、コントロールが真の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールとして動作するようになります。 したがって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティを使用すると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、<xref:System.Web.UI.WebControls.WebParts.WebPart> クラスから派生したかどうかにかかわらず、任意の種類のサーバーコントロールを追跡できます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティをプログラムで使用して、個々の <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールにアクセスする方法を示しています。 Web ページの宣言型マークアップの `<asp:webpartzone>` 要素内には、2つの標準 ASP.NET サーバーコントロールがあります。 これらは <xref:System.Web.UI.WebControls.WebParts.WebPart> クラスから継承されませんが、ゾーン内にあるため、実行時に <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> オブジェクトと共にラップされるため、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティによって参照されるコレクションに含まれます。 このゾーンにカスタム <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロール、ユーザーコントロール、またはカスタムサーバーコントロールを追加することもできます。これらのコントロールは同じように処理されます。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 コード例を使用するには、web.config ファイルに設定を追加して、Web パーツ記述ファイルのエクスポートを有効にする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 `<system.web>` セクション内で、次のマークアップのように `true`に `enableExport` 属性が設定された `<webParts>` 要素があることを確認します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーにページを読み込んだ後、**[WebPart Count]** ボタンをクリックすると、コードは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> プロパティを使用してコレクション内のコントロールの数を返します。 **[予定表のタイトルを隠す]** ボタンをクリックすると、コードによってカレンダーが変更され、タイトルではなく、境界線だけが表示されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (あるいは、サーバー コントロールまたはユーザー コントロール) の間に特定の接続が確立された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> メソッドに関連付けられています。 イベントは、接続が完了したことを確認した後に、ユーザーに通知したり、ページのユーザーインターフェイス (UI) を変更したりすることができます。 たとえば、2つのコントロール間の接続が成功したことを示すグラフィックイメージを表示したり、簡単なメッセージを表示したり、ページ表示モードをブラウズモードに戻したりすることができます。  
  
 ページ開発者は、`OnWebPartsConnected` 属性をページの `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、カスタムイベントハンドラーをこのイベントに関連付けることができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロール (または、<see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンに配置されたサーバー コントロールまたはユーザー コントロール) の間に接続を作成するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> メソッドによって発生し、接続プロセスが開始されたことを通知します (たとえば、ユーザーがコントロールを選択し、connect 動詞をクリックした場合など)。ただし、まだ完了していません。 イベントは、完了前に接続を取り消す機会を提供します。 接続が正常に完了した場合、このイベントの後に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> イベントが続きます。  
  
 ページ開発者は、`OnWebPartsConnecting` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを追加できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール間の接続が終了した後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> メソッドに関連付けられています。 イベントは、接続が終了したことがわかった後に、ユーザーに通知したり、コードでクリーンアップ操作を実行したり、ユーザーインターフェイス (UI) で他の変更を加えたりすることができます。  
  
 ページ開発者は、`OnWebPartsDisConnected` 属性をページの `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、カスタムイベントハンドラーをこのイベントに関連付けることができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以前に接続した <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> コントロールまたはサーバー コントロール間の接続を終了するプロセスを実行しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> メソッドによって発生し、ユーザーが切断動詞をクリックしたこと、または <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> メソッドが呼び出されていることを通知します。 イベントは、接続が完了する前に終了プロセスをキャンセルする機会を提供します。 接続が正常に終了した場合、このイベントの後に <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> イベントが続きます。  
  
 ページ開発者は、`OnWebPartsDisconnecting` 属性を `<asp:webpartmanager>` 要素に追加し、カスタムメソッド名を属性に割り当てることによって、イベントのカスタムハンドラーを追加できます。  
  
 通常、接続を終了するユーザーのアクションの直接的な結果として <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントが発生した場合、イベントを取り消すことができます。 ただし、イベントを取り消すことができないシナリオがいくつかあります。 最初のシナリオでは、<xref:System.Web.UI.WebControls.WebParts.WebPartZone> コントロールが <xref:System.Web.UI.WebControls.WebParts.WebPart> 削除された場合、それに含まれるコントロールはすべて閉じられる必要があります。それ以外の場合は、孤立します。 この場合、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールはユーザーではなく <xref:System.Web.UI.WebControls.WebParts.WebPart> コントロールを閉じます。また、すべてのコントロールをクリーンアップして終了するプロセスを完了できるように、中断することなく接続されたコントロールの接続を終了できる必要があります。 したがって、このシナリオでは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> メソッドを取り消すことができません。 キャンセルできる関連イベントについては、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> イベントを参照してください。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを取り消すことができない2番目のシナリオは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> メソッドが呼び出されたときです (たとえば、ページへの各要求の実行時に呼び出されます)。また、ページ上の既存の接続で何らかの競合が発生します。 たとえば、ユーザーがコントロール x をコントロール y に接続しているにもかかわらず、共有ユーザーがコントロール x をコントロール z に接続していても、コントロール x は複数の接続を形成することが許可されていません。 この場合、接続に対する個々のユーザーの設定が優先され、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールは、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドを呼び出し、特定のユーザーの x と z の間の接続を終了することで競合を解決します。 この切断は競合の解決に不可欠であるため、このシナリオでは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントを取り消すことはできません。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> メソッドを取り消すことができない3番目のシナリオは、現在接続されている <xref:System.Web.UI.WebControls.WebParts.WebPart> またはサーバーコントロールが削除されたか、閉じられた場合です。 コントロールはページから確実に削除されるため、接続を削除することが論理的に必要になります。 したがって、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールが <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> メソッドを呼び出すと、そのメソッドによって <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> イベントが発生します。設計上、イベントをキャンセルすることはできません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web パーツコントロール</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web ページ上のすべての <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> ゾーンのコレクションへの参照を取得します。</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> ゾーンのセットを参照する <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> プロパティは、Web ページ上の <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンを追跡するために、<xref:System.Web.UI.WebControls.WebParts.WebPartManager> コントロールによって使用されます。 プロパティでは、すべての種類のゾーンが参照されないことに注意してください。<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> クラスから派生したゾーン (<xref:System.Web.UI.WebControls.WebParts.WebPartZone> ゾーンを含む) のみを参照します。  
  
 プロパティによって参照されるコレクションは読み取り専用ですが、コレクション内の個々のオブジェクトにアクセスしてプログラムで操作することができます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> プロパティをプログラムで使用して、個々の <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> ゾーンコントロールにアクセスする方法を示しています。 Web ページの宣言型マークアップには、2つの `<asp:webpartzone>` 要素があり、それぞれにサーバーコントロールが含まれていることに注意してください。 ページの [`<script>`] セクションで、このコードは <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> プロパティを使用して個々のゾーンにアクセスし、すべてのゾーン Id を一覧表示して、2番目のゾーンの背景色を変更します。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 コード例を使用するには、web.config ファイルに設定を追加して、Web パーツ記述ファイルのエクスポートを有効にする必要があることに注意してください。 このコード例の web ページと同じディレクトリに web.config ファイルがあることを確認します。 `<system.web>` セクション内で、次のマークアップのように `true`に `enableExport` 属性が設定された `<webParts>` 要素があることを確認します。  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 ブラウザーにページを読み込むと、**[ゾーン id の一覧表示]** ボタンをクリックすると、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> プロパティが使用され、コレクション内のすべてのゾーンの id が一覧表示されます。 [ゾーンの背景の**変更**] ボタンをクリックすると、コードによって2番目のゾーンの背景色が変更されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
