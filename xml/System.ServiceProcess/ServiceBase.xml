<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="20cb893f511f234faa8114a773edd9f726186ff7" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75056533" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>4.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>サービス アプリケーションの一部として存在するサービスの基本クラスを提供します。 <see cref="T:System.ServiceProcess.ServiceBase" /> は、新しいサービス クラスの作成時に派生される必要があります。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスアプリケーションでサービスクラスを定義するときに、<xref:System.ServiceProcess.ServiceBase> から派生させます。 有用なサービスは、<xref:System.ServiceProcess.ServiceBase.OnStart%2A> および <xref:System.ServiceProcess.ServiceBase.OnStop%2A> メソッドよりも優先されます。 その他の機能については、サービスの状態の変化に応じて、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> をオーバーライドし、特定の動作を <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> することができます。  
  
 サービスは、ユーザーインターフェイスをサポートしておらず、ログオンしているユーザーアカウントで実行されない可能性がある、実行時間の長い実行可能ファイルです。 このサービスは、ユーザーがコンピューターにログオンしていなくても実行できます。  
  
 既定では、サービスはシステムアカウントで実行されますが、これは管理者アカウントと同じではありません。 システムアカウントの権限を変更することはできません。 または、<xref:System.ServiceProcess.ServiceProcessInstaller> を使用して、サービスを実行するユーザーアカウントを指定することもできます。  
  
 実行可能ファイルには複数のサービスを含めることができますが、サービスごとに個別の <xref:System.ServiceProcess.ServiceInstaller> が含まれている必要があります。 <xref:System.ServiceProcess.ServiceInstaller> インスタンスによって、サービスがシステムに登録されます。 インストーラーは、各サービスをイベントログに関連付けて、サービスコマンドを記録するために使用することもできます。 実行可能ファイルの `main()` 関数は、実行する必要があるサービスを定義します。 サービスの現在の作業ディレクトリは、実行可能ファイルが配置されているディレクトリではなく、システムディレクトリです。  
  
 サービスを開始すると、実行可能ファイルが検索され、実行可能ファイル内に含まれるそのサービスの <xref:System.ServiceProcess.ServiceBase.OnStart%2A> メソッドが実行されます。 ただし、サービスの実行は実行可能ファイルの実行と同じではありません。 実行可能ファイルは、サービスのみを読み込みます。 サービスは、サービスコントロールマネージャーを使用してアクセスされます (開始や停止など)。  
  
 実行可能ファイルは、サービスで Start を初めて呼び出すときに、<xref:System.ServiceProcess.ServiceBase> 派生クラスのコンストラクターを呼び出します。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> のコマンド処理メソッドは、コンストラクターが実行された直後に呼び出されます。 最初にサービスが読み込まれた後、コンストラクターは再実行されません。そのため、コンストラクターによって実行される処理を、<xref:System.ServiceProcess.ServiceBase.OnStart%2A>によって実行されるものから分離する必要があります。 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> によって解放できるリソースは、<xref:System.ServiceProcess.ServiceBase.OnStart%2A>で作成する必要があります。 コンストラクターにリソースを作成すると、<xref:System.ServiceProcess.ServiceBase.OnStop%2A> がリソースを解放した後にサービスが再起動された場合に、そのリソースが正しく作成されなくなります。  
  
 サービスコントロールマネージャー (SCM) は、サービスと対話する方法を提供します。 SCM を使用して、サービスに開始、停止、一時停止、続行、またはカスタムコマンドを渡すことができます。 SCM は <xref:System.ServiceProcess.ServiceBase.CanStop%2A> と <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> の値を使用して、サービスが停止、一時停止、または続行コマンドを受け入れるかどうかを判断します。 SCM のコンテキストメニューでは、対応するプロパティ <xref:System.ServiceProcess.ServiceBase.CanStop%2A> または <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> がサービスクラスで `true` 場合にのみ、停止、一時停止、および続行が有効になります。 有効にすると、コマンドがサービスに渡され、<xref:System.ServiceProcess.ServiceBase.OnStop%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>、または <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> が呼び出されます。 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>、<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>、または <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `false`の場合、メソッドを実装していても、対応するコマンド処理メソッド (<xref:System.ServiceProcess.ServiceBase.OnStop%2A>など) は処理されません。  
  
 <xref:System.ServiceProcess.ServiceController> クラスを使用すると、ユーザーインターフェイスを使用して SCM が行う操作をプログラムで実行できます。 コンソールで使用できるタスクを自動化できます。 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>、<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>、または <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `true` でも、対応するコマンド処理メソッド (<xref:System.ServiceProcess.ServiceBase.OnStop%2A>など) を実装していない場合、システムは例外をスローし、コマンドを無視します。  
  
 <xref:System.ServiceProcess.ServiceBase>で <xref:System.ServiceProcess.ServiceBase.OnStart%2A>、<xref:System.ServiceProcess.ServiceBase.OnStop%2A>、またはその他のメソッドを実装する必要はありません。 ただし、サービスの動作は <xref:System.ServiceProcess.ServiceBase.OnStart%2A>に記述されているので、少なくともこのメンバーをオーバーライドする必要があります。 実行可能ファイルの `main()` 関数は、<xref:System.ServiceProcess.ServiceBase.Run%2A> メソッドを呼び出すことによって、実行可能ファイル内のサービスをサービスコントロールマネージャーに登録します。 <xref:System.ServiceProcess.ServiceBase.Run%2A> メソッドに渡される <xref:System.ServiceProcess.ServiceBase> オブジェクトの <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> プロパティは、そのサービスのサービスインストーラーの <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> プロパティと一致する必要があります。  
  
 `InstallUtil.exe` を使用して、システムにサービスをインストールすることができます。  
  
> [!NOTE]
>  アプリケーションイベントログ以外のログを指定してサービス呼び出しの通知を受け取ることはできますが、<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> も <xref:System.ServiceProcess.ServiceBase.EventLog%2A> プロパティもカスタムログに書き込むことはできません。 自動ログを使用しない場合は、<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> を `false` に設定します。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.ServiceProcess.ServiceBase" /> クラスの新しいインスタンスを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase> クラスのインスタンスは作成しないでください。 代わりに、<xref:System.ServiceProcess.ServiceBase> から派生し、派生クラスをインスタンス化します。 <xref:System.ServiceProcess.ServiceBase> から継承されたクラスのコンストラクターに実装する必要がある最小値は、コンポーネントで <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> を設定することです。 コンストラクターでは、他の処理は特に必要ありません。 ほとんどの初期化は、コンストラクターではなく <xref:System.ServiceProcess.ServiceBase.OnStart%2A> で処理する必要があります。 そうしないと、停止後にサービスを再起動したときに、オブジェクトが再初期化される保証はありません。  
  
 派生クラスでコンストラクターをオーバーライドする場合は、コードで基底クラスのコンストラクターを呼び出します。  
  
 <xref:System.ServiceProcess.ServiceBase> コンストラクターは、<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> を `true`に設定します。 サービスコントロールマネージャー (SCM) からサービスの呼び出しを自動的にログに記録しない場合は、<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> を `false`に設定します。  
  
 実行可能ファイルに1つのサービスが含まれている場合、SCM から Start を選択すると、システムによってサービスのコンストラクターが呼び出され、Stop が呼び出されるとデストラクターが実行されます。  
  
 実行可能ファイルに複数のサービスが含まれている場合、1つのサービスで Start を呼び出すと、実行可能ファイル内のすべてのサービスに対してコンストラクターが呼び出されますが、指定されたサービスのみが開始されます。 サービスのデストラクターは、すべてのサービスが停止したときに一緒に実行されます。各サービスが停止したときに個別に実行されるわけではありません。  
  
> [!NOTE]
>  基底クラスのコンストラクターをオーバーライドする場合は、派生クラスのコンストラクターで明示的に呼び出す必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベント ログで、Start、Stop、Pause、Continue の各コマンドをレポートするかどうかを示します。</summary>
        <value>イベント ログで情報をレポートする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> を `true` に設定すると、サービスは、アプリケーションイベントログを使用して、コマンドのエラーを報告したり、サービスの開始、停止、一時停止、および続行イベントの状態変更情報をレポートするように指示します。 サービスの名前は、ログの <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>として使用されます。  
  
 アプリケーションログではなくカスタムイベントログに情報を報告するには、<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> を `false` に設定し、コマンド処理メソッド <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>、または <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 内の指示を記述して、適切なログにポストします。  
  
> [!NOTE]
>  イベントログのソース文字列を提供する <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>は、サービスがイベントログへの書き込みを試みる前に設定する必要があります。 ソース名を設定する前にイベントログにアクセスしようとすると、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サービスで、コンピューターの電源ステータスの変更の通知を処理できるかどうかを示す値を取得または設定します。</summary>
        <value><see langword="true" /> クラスで示されたコンピューターの電源ステータスの変更をサービスで処理する場合は <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンピューターの電源状態が変化すると、サービスコントロールマネージャー (SCM) は、サービスが <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>の値を使用して電源イベントコマンドを受け入れるかどうかを確認します。  
  
 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> が `true`場合は、コマンドがサービスに渡され、定義されている場合は <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> メソッドが呼び出されます。 派生クラスで <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> が実装されていない場合、SCM は空の基本クラス <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> メソッドを使用して power イベントを処理します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスの開始後にこのプロパティが変更されています。</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ターミナル サーバー セッションから受信したセッション変更イベントをサービスで処理できるかどうかを示す値を取得または設定します。</summary>
        <value>ターミナル サーバーのセッション変更イベントをサービスで処理できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">サービスの開始後にこのプロパティが変更されています。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サービスを一時中断および再開できるかどうかを示す値を取得または設定します。</summary>
        <value>サービスを一時中断できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスのコンストラクターで、<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> プロパティの値を設定します。  
  
 サービスを一時停止すると、サービスが停止します。 サービスを続行すると (サービスコントロールマネージャーまたはプログラムによって)、<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> が実行されます。  
  
 サービスに一時停止要求を送信すると、システムリソースを節約できます。 一時停止では、すべてのシステムリソースが解放されるとは限りませんが、停止します。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> は、多くの場合、<xref:System.ServiceProcess.ServiceBase.OnStop%2A> と <xref:System.ServiceProcess.ServiceBase.OnStart%2A>よりも少ない処理を実行するために実装されます。  
  
 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `true`場合は、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> をオーバーライドして、サービスコントロールマネージャー (SCM) が Pause または Continue 要求をサービスに渡すときに発生する処理を指定します。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>の処理を元に戻すには <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> を実装する必要があります。  
  
 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `false`場合、SCM はサービスに対して Pause または Continue 要求を渡しません。そのため、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> および <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> メソッドは、実装されている場合でも呼び出されません。 SCM では、<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `false`されている場合、`Pause` コントロールと `Continue` コントロールは無効になります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。 <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> プロパティは、サービスが開始された後は変更できません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>システムのシャットダウン時に、サービスにそれを通知する必要があるかどうかを示す値を取得または設定します。</summary>
        <value>システムのシャットダウン時にサービスに通知する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。  既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> が `true`場合は、システムのシャットダウン時にサービスに通知されます。 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> メソッドは、シャットダウン時に、派生クラスに実装されている場合に呼び出されます。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> メソッドを実行するのはシステムだけです。サービスはこのメソッドを呼び出すことができますが、これは推奨されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。 <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> プロパティは、サービスが開始された後は変更できません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サービスを開始した後に停止できるかどうかを示す値を取得または設定します。</summary>
        <value>サービスを停止でき、<see langword="true" /> メソッドを呼び出すことができる場合は <see cref="M:System.ServiceProcess.ServiceBase.OnStop" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスで Stop が呼び出されると、サービスコントロールマネージャー (SCM) は、サービスが <xref:System.ServiceProcess.ServiceBase.CanStop%2A>の値を使用して Stop コマンドを受け入れるかどうかを確認します。 ほとんどのサービスでは、<xref:System.ServiceProcess.ServiceBase.CanStop%2A> の値は `true`ますが、一部のオペレーティングシステムサービスではユーザーによる停止が許可されていません。  
  
 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> が `true`場合は、Stop コマンドがサービスに渡され、<xref:System.ServiceProcess.ServiceBase.OnStop%2A> メソッドが定義されている場合は呼び出されます。 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> が派生クラスに実装されていない場合、SCM は空の基本クラス <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> メソッドを使用して Stop コマンドを処理します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。 <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> プロパティは、サービスが開始された後は変更できません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.ServiceProcess.ServiceBase" /> で使用されていたリソース (メモリを除く) を解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスの使用が終了したときに、派生クラス (および <xref:System.ServiceProcess.ServiceBase> クラス内) で <xref:System.ServiceProcess.ServiceBase.Dispose%2A> を呼び出します。 <xref:System.ServiceProcess.ServiceBase.Dispose%2A> メソッドは、派生クラスを使用できない状態のままにします。 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>を呼び出した後、派生クラスと <xref:System.ServiceProcess.ServiceBase> へのすべての参照を解放して、占有されていたメモリがガベージコレクションによって回収されるようにする必要があります。  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase>から派生したクラスへの最後の参照を解放する前に、常に <xref:System.ServiceProcess.ServiceBase.Dispose%2A> を呼び出してください。 そうしないと、ガベージコレクションがオブジェクトのデストラクターを呼び出すまで、<xref:System.ServiceProcess.ServiceBase> と派生クラスが使用しているリソースは解放されません。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> は、多くの場合、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>のコードを <xref:System.ServiceProcess.ServiceBase.Dispose%2A>の呼び出しと組み合わせて処理するために実装されます。 派生クラスでこれを行う場合は、<xref:System.ServiceProcess.ServiceBase.OnStart%2A> を実装して、解放されたすべての <xref:System.ServiceProcess.ServiceBase.Dispose%2A> を割り当てることができます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Start や Stop などのサービス コマンドの呼び出し通知をアプリケーション イベント ログに書き込むために使用できるイベント ログを取得します。</summary>
        <value>ソースがアプリケーション ログに登録されている <see cref="T:System.Diagnostics.EventLog" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンストラクターは、<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> プロパティと <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> プロパティを設定して、<xref:System.ServiceProcess.ServiceBase.EventLog%2A> プロパティをインスタンスに初期化します。 ソースはサービスの <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> であり、ログはコンピューターのアプリケーションログです。 これらの値は自動的に設定され、サービスコマンドの自動ログ記録のためには変更できません。  
  
 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> が `true`場合、Start、Stop、Pause、Continue、およびカスタムコマンドはアプリケーションイベントログに自動的に記録されます。 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> プロパティを使用して、そのログに追加のメッセージを書き込むこともできます。 コンポーネントは、この <xref:System.ServiceProcess.ServiceBase.EventLog%2A> メンバーを使用して <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> を呼び出します。  
  
 アプリケーションログではなくカスタムイベントログに情報を報告するには、<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> を `false` に設定し、コマンド処理メソッド <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>、または <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 内の指示を記述して、適切なログにポストします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サービスの終了コードを取得または設定します。</summary>
        <value>サービスの終了コード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスを停止してサービスコントロールマネージャーにエラーを通知する前に、<xref:System.ServiceProcess.ServiceBase.ExitCode%2A> プロパティを0以外の値に設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>サービス名の最大サイズを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName と DisplayName の両方に、サービスクラスのプロパティを設定するときに確認する必要があるサイズ制限があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに実装されると、<see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> は、サービス コントロール マネージャー (SCM) によって Continue コマンドがサービスに送信されるときに実行されます。 サービスが一時中断してから通常の操作の再開時に実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションの応答を <xref:System.ServiceProcess.ServiceBase.OnPause%2A>に反映するには、<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> を実装します。 サービスを続行すると (サービスコンソールまたはプログラムによって)、<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 処理が実行され、サービスが再びアクティブになります。  
  
 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> プロパティが `true`場合、<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> はオーバーライドされることが想定されています。  
  
 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `false`場合、SCM はサービスに対して Pause または Continue 要求を渡しません。そのため、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> および <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> メソッドは、実装されている場合でも呼び出されません。 SCM では、<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `false`されている場合、`Pause` コントロールと `Continue` コントロールは無効になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">サービスに送信されたコマンド メッセージ。</param>
        <summary>派生クラスに実装されると、<see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> は、サービス コントロール マネージャー (SCM) でカスタム コマンドがサービスに渡されるときに、実行されます。 パラメーター値が設定されているコマンドの発生時に実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> を使用すると、サービスを開始、停止、一時停止、および続行する以外に、追加の機能を指定できます。  
  
 SCM はカスタムコマンドを調べて、渡された `command` パラメーターをサービスがサポートしているかどうかを確認しません。 カスタムコマンドがサービスに直接渡されます。 サービスが `command` パラメーターを認識しない場合は、何も実行されません。  
  
 カスタムコマンドは、<xref:System.ServiceProcess.ServiceController> コンポーネントの <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> ステートメントによって発生します。 Switch ステートメントを使用するか、..次に、サービスで定義するカスタムコマンドを処理する条件を指定します。  
  
 アプリケーションで定義したり <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> で使用したりできるカスタムコマンドの値は、128と255の間の値のみです。 128未満の整数は、システム予約値に対応します。  
  
 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> プロパティが `true`場合、他のすべてのコマンドと同様に、カスタムコマンドは、メソッドの実行が成功したか失敗したかを報告するために、イベントログにエントリを書き込みます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに実装されると、Pause コマンドがサービス コントロール マネージャー (SCM) によってサービスに送信されるときに実行されます。 サービスが一時中断したときに実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスが Pause コマンドを受信したときに発生する処理を指定するには、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> を使用します。 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> プロパティが `true`場合、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> はオーバーライドされることが想定されています。  
  
 (サービスコンソールまたはプログラムによって) 一時停止しているサービスを続行すると、<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 処理が実行され、サービスが再びアクティブになります。  
  
 Pause コマンドを使用すると、アプリケーションは特定のイベントにのみ応答できます。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> は、サービスに対して定義していないサービスに対して何も実行しません。  
  
 一時停止要求をサービスに送信すると、すべてのシステムリソースを解放する必要がなくなるため、システムリソースを節約できます。 たとえば、プロセスによってスレッドが開かれている場合、停止するのではなくサービスを一時停止すると、スレッドを開いたままにすることができます。サービスが続行されるときに再割り当てする必要が習得ます。 すべてのシステムリソースを解放するために Pause を定義すると、Stop コマンドのように動作します。  
  
 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> を `true`に設定し、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> と <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> をオーバーライドして、SCM が Pause または Continue 要求をサービスに渡すときに発生する処理を指定します。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>の処理を元に戻すには <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> を実装する必要があります。  
  
 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `false`場合、SCM はサービスに対して Pause または Continue 要求を渡しません。そのため、実装されていても、<xref:System.ServiceProcess.ServiceBase.OnPause%2A> および <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> メソッドは呼び出されません。 SCM では、<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> が `false`されている場合、`Pause` コントロールと `Continue` コントロールは無効になります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">システムからの電源ステータスに関する通知を示す <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />。</param>
        <summary>派生クラスに実装されると、コンピューターの電源ステータスの変更時に実行されます。 これは中断モードのラップトップ コンピューターに適用されるもので、システムのシャットダウンとは異なります。</summary>
        <returns>派生クラスに実装されると、アプリケーションの要求に応じて返される値が決定します。 たとえば、<see langword="QuerySuspend" /> ブロードキャスト ステータスが渡されると、<see langword="false" /> を返すことでアプリケーションでクエリを拒否できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> を使用して、<xref:System.ServiceProcess.PowerBroadcastStatus> 列挙に示されているシステムイベントが発生したときに発生する処理を指定します。たとえば、コンピューターが中断モードの場合、またはバッテリ低下の電源を示す場合などです。  
  
 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> プロパティが `true`場合、<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> はオーバーライドされることが想定されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription">変更の種類を識別する構造体。</param>
        <summary>変更イベントがターミナル サーバー セッションから受信された場合に実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの実行を有効にするには、<xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> プロパティを `true` に設定する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに実装されると、システムがシャット ダウンされるときに実行されます。 システムがシャット ダウンする直前に発生する処理を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> を使用して、システムのシャットダウン時に発生する処理を指定します。  
  
 このイベントは、コンピューターの電源がオフになっている場合ではなく、オペレーティングシステムがシャットダウンされた場合にのみ発生します。  
  
 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> プロパティが `true`場合、<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> はオーバーライドされることが想定されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Start コマンドによって渡されたデータ。</param>
        <summary>派生クラスに実装されると、Start コマンドがサービス コントロール マネージャー (SCM) によってサービスに送信されるとき、またはオペレーティング システムが (自動的に起動するサービスのために) 起動するときに実行されます。 サービスが開始するときに実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスが Start コマンドを受信したときに発生する処理を指定するには、<xref:System.ServiceProcess.ServiceBase.OnStart%2A> を使用します。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> は、サービスの動作を指定する方法です。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> はデータを渡す方法として引数を受け取ることができますが、この使用方法はほとんどありません。  
  
> [!CAUTION]
>  コンストラクターを使用して、<xref:System.ServiceProcess.ServiceBase.OnStart%2A>に含まれる処理を実行しないでください。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> を使用して、サービスのすべての初期化を処理します。 コンストラクターは、サービスの実行時ではなく、アプリケーションの実行可能ファイルの実行時に呼び出されます。 実行可能ファイルは <xref:System.ServiceProcess.ServiceBase.OnStart%2A>前に実行されます。 たとえば、SCM が既にメモリ内にオブジェクトを保持しているために、コンストラクターが再度呼び出されることはありません。 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> が <xref:System.ServiceProcess.ServiceBase.OnStart%2A>ではなくコンストラクターに割り当てられたリソースを解放した場合、2回目のサービスが呼び出されたときに必要なリソースが再度作成されることはありません。  
  
 サービスのインストーラーの <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> を <xref:System.ServiceProcess.ServiceStartMode.Automatic>に設定することによって、コンピューターを再起動すると、サービスを自動的に開始するように設定できます。 このような状況では、システムの起動時に <xref:System.ServiceProcess.ServiceBase.OnStart%2A> が呼び出されます。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> は、派生クラスでオーバーライドされることが想定されています。 サービスを有効にするには、<xref:System.ServiceProcess.ServiceBase.OnStart%2A> と <xref:System.ServiceProcess.ServiceBase.OnStop%2A> を両方ともサービスクラスに実装する必要があります。  
  
 Main メソッドではなく、<xref:System.ServiceProcess.ServiceBase.OnStart%2A> メソッドでのサービスの初期化引数を処理します。 `args` パラメーター配列内の引数は、サービスコンソールでサービスの [プロパティ] ウィンドウで手動で設定できます。 コンソールに入力した引数は保存されません。これらは、サービスがコントロールパネルから開始されたときに、一度にサービスに渡されます。 サービスが自動的に開始されるときに存在する必要がある引数は、サービスのレジストリキーの ImagePath 文字列値に配置できます (HKEY_LOCAL_MACHINE \SYSTEM\CurrentControlSet\Services\\*\<サービス名 >*)。 レジストリから引数を取得するには、<xref:System.Environment.GetCommandLineArgs%2A> メソッドを使用します。たとえば、`string[] imagePathArgs = Environment.GetCommandLineArgs();`のようになります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに実装されると、Stop コマンドがサービス コントロール マネージャー (SCM) によってサービスに送信されるときに実行されます。 サービスが実行を停止したときに実行されるアクションを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスが Stop コマンドを受信したときに発生する処理を指定するには、<xref:System.ServiceProcess.ServiceBase.OnStop%2A> を使用します。  
  
 SCM は、Stop コマンドを受信すると、<xref:System.ServiceProcess.ServiceBase.CanStop%2A> の値を使用して、サービスが停止コマンドを受け入れるかどうかを確認します。 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> が `true`場合は、Stop コマンドがサービスに渡され、<xref:System.ServiceProcess.ServiceBase.OnStop%2A> メソッドが定義されている場合は呼び出されます。 サービスに <xref:System.ServiceProcess.ServiceBase.OnStop%2A> が実装されていない場合、SCM は Stop コマンドを処理します。  
  
 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> が `false`の場合、SCM は Stop コマンドを無視します。 サービスに渡されません。 Stop コマンドはを返し、例外をスローします。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> は、派生クラスでオーバーライドされることが想定されています。 サービスを有効にするには、<xref:System.ServiceProcess.ServiceBase.OnStart%2A> と <xref:System.ServiceProcess.ServiceBase.OnStop%2A> を両方ともサービスクラスに実装する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds">要求する時間 (ミリ秒単位)。</param>
        <summary>保留中の操作について時間の延長を要求します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> メソッドは、オーバーライドされた <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>、<xref:System.ServiceProcess.ServiceBase.OnPause%2A>、<xref:System.ServiceProcess.ServiceBase.OnStart%2A>、または <xref:System.ServiceProcess.ServiceBase.OnStop%2A> メソッドによって呼び出され、保留中の操作に追加の時間を要求することを目的としています。これにより、サービスコントロールマネージャー (SCM) がサービスを応答なしとしてマークすることを防ぐことができます。  保留中の操作が [続行]、[一時停止]、[開始]、または [停止] でない場合は、<xref:System.InvalidOperationException> がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスは保留状態ではありません。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サービスの実行可能ファイルのメイン エントリ ポイントを示します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">開始するサービスを示す <see cref="T:System.ServiceProcess.ServiceBase" />。</param>
        <summary>サービス コントロール マネージャー (SCM) を使用してサービスの実行可能ファイルを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスの実行可能ファイルの `main()` 関数でこのオーバーロードを呼び出して、サービスをサービスコントロールマネージャーに登録します。 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>を呼び出した後、サービスコントロールマネージャーは Start コマンドを発行します。これにより、サービスの <xref:System.ServiceProcess.ServiceBase.OnStart%2A> メソッドが呼び出されます。 開始コマンドが実行されるまで、サービスは開始されません。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> メソッドは、Windows フォームアプリケーションの <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> とほぼ同じ方法で呼び出されます。  
  
 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> が `true`場合、`service` パラメーターで指定されたサービスを開始できないと、エントリがイベントログに書き込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" /> は <see langword="null" /> です。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">ServiceBase インスタンスの配列。開始するサービスを示します。</param>
        <summary>複数サービスの実行可能ファイルをサービス コントロール マネージャー (SCM) に登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスの実行可能ファイルの `main()` 関数でこのオーバーロードを呼び出して、サービスをサービスコントロールマネージャーに登録します。 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>を呼び出した後、サービスコントロールマネージャーは Start コマンドを発行します。これにより、サービスの <xref:System.ServiceProcess.ServiceBase.OnStart%2A> メソッドが呼び出されます。 開始コマンドが実行されるまで、サービスは開始されません。  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> メソッドは、Windows フォームアプリケーションの <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> メソッドとほぼ同じ方法で呼び出されます。  
  
 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> が `true`場合、配列内のいずれかのサービスの起動に失敗すると、エントリがイベントログに書き込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">開始するサービスが指定されていません。 配列が <see langword="null" /> または空である可能性があります。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サービスのサービス コントロール ハンドルを取得します。</summary>
        <value>サービスのサービス コントロール ハンドルを含む <see cref="T:System.IntPtr" /> 構造体。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスコントロールハンドルは、サービスコントロールマネージャー (SCM) との通信に使用されます。  ハンドルは、アンマネージ `SetServiceStatus` 関数を使用して、呼び出し元のサービスのサービスコントロールマネージャーの状態情報を更新するために使用できます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードへのアクセスに使用します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount">引数配列内の引数の数。</param>
        <param name="argPointer">引数配列を指す <see cref="T:System.IntPtr" /> 構造体。</param>
        <summary>コマンド ハンドラーを登録し、サービスを開始します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>システムでサービスを識別するために使用される短い名前を取得または設定します。</summary>
        <value>サービスの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サービスコントロールマネージャーに対してサービスを識別する <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>。 このプロパティの値は、対応するインストーラークラスの <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> プロパティでサービスに記録された名前と同じである必要があります。 コードでは、サービスの <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> は通常、実行可能ファイルの `main()` 関数で設定されます。  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> は、<xref:System.ServiceProcess.ServiceBase.EventLog%2A> プロパティに関連付けられた <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> を指定するためにも使用されます。 この <xref:System.ServiceProcess.ServiceBase.EventLog%2A> は、サービスコマンド情報をアプリケーションログに書き込むインスタンスです。  
  
 イベントログのソース文字列を提供する <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>は、サービスがイベントログに書き込む前に設定する必要があります。 ソース名を設定する前にイベントログにアクセスしようとすると、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">サービスが既に開始されています。 <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> プロパティは、サービスが開始された後は変更できません。</exception>
        <exception cref="T:System.ArgumentException">指定された名前が、長さ 0 の文字列であるか、または <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" /> より長い文字列です。または、指定された名前にスラッシュまたはバック スラッシュ文字が含まれています。</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>4.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サービスの実行を停止します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A> メソッドは、停止が保留中であることを示すようにサービスの状態を設定し、<xref:System.ServiceProcess.ServiceBase.OnStop%2A> メソッドを呼び出します。  アプリケーションが停止されると、サービスの状態が [停止] に設定されます。 アプリケーションがホステッドサービスの場合、アプリケーションドメインはアンロードされます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>
