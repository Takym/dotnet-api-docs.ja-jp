<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2aff9c38704f6ea2c128f56bc30e1614b8a40f79" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75028784" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>型宣言を表します。型には、クラス型、インターフェイス型、配列型、値型、列挙型、型パラメーター、ジェネリック型定義、およびオープン構築ジェネリック型またはクローズ構築ジェネリック型があります。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` は <xref:System.Reflection> 機能のルートであり、メタデータにアクセスする主な方法です。 型のメンバー (クラスのコンストラクター、メソッド、フィールド、プロパティ、イベントなど) と、そのクラスが配置されているモジュールとアセンブリについて、型宣言に関する情報を取得するには、<xref:System.Type> のメンバーを使用します。  
  
 アクセスレベルに関係なく、型とそのメンバーに関する情報を取得するためにリフレクションを使用するためのアクセス許可は必要ありません。 リフレクションを使用してパブリックメンバーにアクセスするコード、またはアクセスレベルが通常のコンパイル中に表示される他のメンバーにアクセスするためのアクセス許可は必要ありません。 ただし、プライベートメソッド、内部メソッド、またはクラスが継承しない型の保護されたフィールドなど、通常はアクセスできないメンバーにコードがリフレクションを使用してアクセスするためには、コードに <xref:System.Security.Permissions.ReflectionPermission>が必要です。 「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください。  
  
 `Type` は、複数の実装を許可する抽象基本クラスです。 システムは常に `RuntimeType`派生クラスを提供します。 リフレクションでは、word ランタイムで始まるすべてのクラスは、システム内のオブジェクトごとに1回だけ作成され、比較操作をサポートします。  
  
> [!NOTE]
>  マルチスレッドのシナリオでは、`static` データへのアクセスを同期するために <xref:System.Type> オブジェクトをロックしないでください。 コントロールがない他のコードも、クラス型をロックすることがあります。 これにより、デッドロックが発生する可能性があります。 代わりに、プライベート `static` オブジェクトをロックすることによって、静的データへのアクセスを同期します。  
  
> [!NOTE]
>  派生クラスは、呼び出し元のコードの基本クラスのプロテクトメンバーにアクセスできます。 また、呼び出し元のコードのアセンブリのメンバーにアクセスすることもできます。 規則として、事前バインディングされたコード内でアクセスが許可されている場合は、遅延バインディングされたコードでアクセスを許可することもできます。  
  
> [!NOTE]
>  他のインターフェイスを拡張するインターフェイスは、拡張インターフェイスで定義されているメソッドを継承しません。  
  
 このセクションの内容:  
  
 [Type オブジェクトはどのような型を表していますか。](#WhatTypes)   
 [型オブジェクトの取得](#Retrieve)   
 [型オブジェクトの等価性の比較](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Type オブジェクトはどのような型を表していますか。  
 このクラスはスレッドセーフです。この型のインスタンスから複数のスレッドが同時に読み取ることができます。 <xref:System.Type> クラスのインスタンスは、次のいずれかの型を表すことができます。  
  
-   クラス  
  
-   値型  
  
-   配列  
  
-   インターフェイス  
  
-   列挙  
  
-   デリゲート  
  
-   構築されたジェネリック型とジェネリック型の定義  
  
-   構築されたジェネリック型、ジェネリック型定義、ジェネリックメソッド定義の型引数と型パラメーター  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>型オブジェクトの取得  
 特定の型に関連付けられている <xref:System.Type> オブジェクトは、次の方法で取得できます。  
  
-   インスタンス <xref:System.Object.GetType%2A?displayProperty=nameWithType> メソッドは、インスタンスの型を表す <xref:System.Type> オブジェクトを返します。 すべてのマネージ型は <xref:System.Object>から派生するため、<xref:System.Object.GetType%2A> メソッドは任意の型のインスタンスで呼び出すことができます。  
  
     次の例では、<xref:System.Object.GetType%2A?displayProperty=nameWithType> メソッドを呼び出して、オブジェクト配列内の各オブジェクトのランタイム型を確認します。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   静的 <xref:System.Type.GetType%2A?displayProperty=nameWithType> メソッドは、完全修飾名で指定された型を表す <xref:System.Type> オブジェクトを返します。  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>、<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>、および <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> の各メソッドは、モジュールで定義されている型を表す `Type` オブジェクトを返します。 最初のメソッドを使用すると、モジュールで定義されているすべてのパブリック型とプライベート型の <xref:System.Type> オブジェクトの配列を取得できます。 (<xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> メソッドを使用して、または <xref:System.Type.Module%2A?displayProperty=nameWithType> プロパティを使用して `Module` のインスタンスを取得できます)。  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType> オブジェクトには、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>、<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>、<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>など、アセンブリで定義されているクラスを取得するためのメソッドが多数含まれています。  
  
-   <xref:System.Type.FindInterfaces%2A> メソッドは、型によってサポートされる、フィルター処理されたインターフェイスの型のリストを返します。  
  
-   <xref:System.Type.GetElementType%2A> メソッドは、要素を表す `Type` オブジェクトを返します。  
  
-   <xref:System.Type.GetInterfaces%2A> メソッドと <xref:System.Type.GetInterface%2A> メソッドは、型でサポートされているインターフェイス型を表す <xref:System.Type> オブジェクトを返します。  
  
-   <xref:System.Type.GetTypeArray%2A> メソッドは、任意のオブジェクトセットによって指定された型を表す <xref:System.Type> オブジェクトの配列を返します。 オブジェクトは <xref:System.Object>型の配列で指定されます。  
  
-   <xref:System.Type.GetTypeFromProgID%2A> および <xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM 相互運用性のために用意されています。 これらは、`ProgID` または `CLSID`によって指定された型を表す <xref:System.Type> オブジェクトを返します。  
  
-   <xref:System.Type.GetTypeFromHandle%2A> メソッドは、相互運用性を確保するために用意されています。 クラスハンドルによって指定された型を表す `Type` オブジェクトを返します。  
  
-   C# `typeof` 演算子、 C++ `typeid` 演算子、および Visual Basic `GetType` 演算子は、型の `Type` オブジェクトを取得します。  
  
-   <xref:System.Type.MakeGenericType%2A> メソッドは、構築されたジェネリック型を表す <xref:System.Type> オブジェクトを返します。これは、<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`を返した場合はオープン構築型、それ以外の場合は閉じた構築型です。 ジェネリック型は、閉じられている場合にのみインスタンス化できます。  
  
-   <xref:System.Type.MakeArrayType%2A>、<xref:System.Type.MakePointerType%2A>、および <xref:System.Type.MakeByRefType%2A> メソッドは、指定された型の配列、指定された型へのポインター、および参照パラメーターの型 ( C#`ref` では `ByRef`) を表す <xref:System.Type> オブジェクトを返します。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>型オブジェクトの等価性の比較  
 型を表す <xref:System.Type> オブジェクトは一意です。つまり、2つの <xref:System.Type> オブジェクト参照は、同じ型を表している場合に限り、同じオブジェクトを参照します。 これにより、参照の等価性を使用して <xref:System.Type> オブジェクトを比較できます。 次の例では、整数値の数を表す <xref:System.Type> オブジェクトを比較して、それらが同じ型であるかどうかを判断します。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 次の例は、<xref:System.Type>のいくつかの代表的な機能を示しています。 `typeof` C#演算子 (Visual Basic の`GetType` 演算子) を使用して、<xref:System.String>を表す <xref:System.Type> オブジェクトを取得します。 この <xref:System.Type> オブジェクトから、<xref:System.Type.GetMethod%2A> メソッドを使用して、開始位置と長さを受け取る <xref:System.String.Substring%2A?displayProperty=nameWithType> のオーバーロードを表す <xref:System.Reflection.MethodInfo> を取得します。
  
 オーバーロードシグネチャを識別するために、コード例では、`int` (Visual Basic で`Integer`) を表す2つの <xref:System.Type> オブジェクトを含む一時配列を作成します。  
  
> [!NOTE]
>  正確に言うと、配列には、現在のアプリケーションドメインの `int` を表す <xref:System.Type> のインスタンスへの2つの参照が含まれています。 任意の型の場合、アプリケーションドメインごとに <xref:System.Type> のインスタンスが1つだけ存在します。  
  
 このコード例では、<xref:System.Reflection.MethodInfo> を使用して、文字列 "Hello, World!" の <xref:System.String.Substring%2A> メソッドを呼び出し、結果を表示します。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <block subset="none" type="overrides"><para><see langword="Type" />から継承する場合は、次のメンバーをオーバーライドする必要があります。 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">型情報の表示</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターは、型オブジェクトの構築中に、派生クラスによって呼び出されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が宣言される <see cref="T:System.Reflection.Assembly" /> を取得します。 ジェネリック型の場合は、ジェネリック型が定義される <see cref="T:System.Reflection.Assembly" /> を取得します。</summary>
        <value>現在の型を含むアセンブリを説明する <see cref="T:System.Reflection.Assembly" /> インスタンス。 ジェネリック型の場合、インスタンスは特定の構築型を作成および使用するアセンブリではなく、ジェネリック型定義を含むアセンブリを説明します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> オブジェクトが構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義を含むアセンブリを返します。 たとえば、ジェネリック型定義 `MyGenericStack<T>` (`MyGenericStack(Of T)` Visual Basic では `generic<T> ref class MyGenericStack` C++) を含む mygenerics .dll という名前のアセンブリを作成したとします。 別のアセンブリに `MyGenericStack<int>` (Visual Basic で`MyGenericStack(Of Integer)`) のインスタンスを作成すると、構築された型の <xref:System.Type.Assembly%2A> プロパティによって、MyGenerics .dll を表す <xref:System.Reflection.Assembly> オブジェクトが返されます。  
  
 同様に、現在の <xref:System.Type> オブジェクトが割り当てられていないジェネリックパラメーター `T`を表している場合、このプロパティは `T`を定義するジェネリック型を含むアセンブリを返します。  
  
 .NET Core やユニバーサル Windows プラットフォームなど、特定の .NET 実装で <xref:System.Type.Assembly%2A?displayProperty=nameWithType> プロパティを使用できない場合は、代わりに <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> プロパティを使用します。      
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、クラスに関連付けられているアセンブリ名と、その型の完全修飾名を表示します。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> オブジェクトの読み込み元であるアセンブリの名前を含む型のアセンブリ修飾名を取得します。</summary>
        <value><see cref="T:System.Type" /> の読み込み元であるアセンブリの名前を含む、<see cref="T:System.Type" /> のアセンブリ修飾名。現在のインスタンスがジェネリック型パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型のアセンブリ修飾名は、名前空間を含む型名とその後に続くコンマ、およびアセンブリの表示名で構成されます。 アセンブリの表示名は、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> プロパティを使用して取得されます。  
  
> [!NOTE]
>  .NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。 たとえば、"ProcessorArchitecture = msil" のようになります。 ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。 以下を参照してください。<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>  
  
 共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。  
  
|Delimiter|説明|  
|---------------|-------------|  
|円記号 (\\)|エスケープ文字。|  
|コンマ (,)|アセンブリ名の前に指定します。|  
|プラス記号 (+)|入れ子になったクラスの前に置きます。|  
|ピリオド (.)|名前空間識別子を表します。|  
|角かっこ ([])|型名の後には、その型の配列を示します。<br /><br /> - または -<br /><br /> ジェネリック型の場合は、ジェネリック型引数リストを囲みます。<br /><br /> - または -<br /><br /> 型引数リスト内で、アセンブリ修飾型を囲みます。|  
  
 たとえば、クラスのアセンブリ修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 名前空間にプラス記号 (TopNamespace. Sub + Namespace など) が含まれている場合、プラス記号 (+) の前にエスケープ文字 (\\) があるため、入れ子の区切り記号として解釈されません。 リフレクションは、この文字列を次のように出力します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 "+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。  
  
 この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。 <xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。 型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。 アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。  
  
 型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。 末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型のジェネリック引数自体は、アセンブリ名によって修飾されます。 たとえば、`MyGenericClass<int>` (Visual Basic の`MyGenericClass(Of Integer)`) のアセンブリ修飾型名では、`int` が <xref:System.Int32>のアセンブリ修飾型名に拡張されます。  
  
 現在の <xref:System.Type> オブジェクトがジェネリックパラメーターを表している場合、このプロパティは `null`を返します。  
  
   
  
## Examples  
 次の例では、クラスに関連付けられているアセンブリ名と、その型の完全修飾名を表示します。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 次の例では、<xref:System.Type.ToString%2A> メソッドによって返される文字列と、`Name`、<xref:System.Type.FullName%2A>、および <xref:System.Type.AssemblyQualifiedName%2A> プロパティを比較します。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に関連付けられている属性を取得します。</summary>
        <value><see cref="T:System.Reflection.TypeAttributes" /> の属性セットを表す <see cref="T:System.Type" /> オブジェクト。ただし、<see cref="T:System.Type" /> がジェネリック型パラメーターを表す場合、値は未指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes> 列挙体の一部のメンバーは、値のグループを表すマスクです。 各グループには、基になる値が0である1つのメンバーが含まれます。 たとえば、<xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> グループの <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> メンバーの基になる値は、<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> グループの <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> メンバーと同様に0になります。 このため、これらの値をテストする前にマスクを使用する必要があります。 具体的な例を次に示します。  
  
> [!TIP]
>  ほとんどの場合、<xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>、<xref:System.Type.IsSpecialName%2A> などのプロパティは、型属性よりも簡単に使用できます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティはジェネリック型定義の属性を返します。 たとえば、`MyGenericClass<int>` (Visual Basic の`MyGenericClass(Of Integer)`) に対して返される属性は `MyGenericClass<T>` (`MyGenericClass(Of T)` では Visual Basic) の属性です。  
  
 現在の <xref:System.Type> がジェネリック型パラメーターを表している場合 (つまり、<xref:System.Type.IsGenericParameter%2A> プロパティが `true` を返した場合、このプロパティによって返される <xref:System.Reflection.TypeAttributes> 値は指定されていません。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.Attributes%2A> プロパティを使用します。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の直接の継承元である型を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> の直接の継承元の <see cref="T:System.Type" />。現在の <see langword="null" /> が <see langword="Type" /> クラスまたはインターフェイスを表す場合は <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本型は、現在の型が直接継承する型です。 <xref:System.Object> が基本型を持たない唯一の型であるため、`null` は <xref:System.Object>の基本型として返されます。  
  
 インターフェイスは、0個以上の基本インターフェイスから継承します。したがって、`Type` オブジェクトがインターフェイスを表す場合、このプロパティは `null` を返します。 基本インターフェイスは <xref:System.Type.GetInterfaces%2A> または <xref:System.Type.FindInterfaces%2A>で決定できます。  
  
 現在の <xref:System.Type> が構築されたジェネリック型を表している場合、基本型はジェネリック引数を反映します。 たとえば、次のような宣言があるとします。  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 構築された型 `C<int>` (Visual Basic で`C(Of Integer)`) の場合、<xref:System.Type.BaseType%2A> プロパティは `B<int>`を返します。  
  
 現在の <xref:System.Type> がジェネリック型定義の型パラメーターを表している場合、<xref:System.Type.BaseType%2A> は、クラスの制約、つまり、型パラメーターが継承する必要があるクラスを返します。 クラスの制約がない場合、<xref:System.Type.BaseType%2A> は <xref:System.Object?displayProperty=nameWithType>を返します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.BaseType%2A> プロパティの使用方法を示します。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 次の例では、再帰を使用して、アセンブリ内で見つかった各クラスの完全な継承階層を一覧表示します。 この例では、`B`という名前のクラスから派生する `C` という名前のクラスを定義しています。これは、`A`という名前のクラスから派生します。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが特定の型で置き換えられていない型パラメーターを持っているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> オブジェクト自体がジェネリック型パラメーターであるか、特定の型が指定されていない型パラメーターを持っている場合は <see cref="T:System.Type" />。そうでない場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型のインスタンスを作成するには、型自体の型引数、外側のジェネリック型、または型の任意の要素で、ジェネリック型定義またはオープン構築型が存在しない必要があります。 これを示すもう1つの方法は、再帰的に検査するときに、型にジェネリック型パラメーターが含まれていなければならないということです。  
  
 型は任意に複雑になる可能性があるため、この決定を行うことは困難です。 利便性を高めると共に、エラーの可能性を減らすために、<xref:System.Type.ContainsGenericParameters%2A> プロパティは、インスタンス化できる閉じた構築型と、作成できないオープン構築型を区別するための標準的な方法を提供します。 <xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`を返す場合、型をインスタンス化することはできません。  
  
 <xref:System.Type.ContainsGenericParameters%2A> プロパティは、型パラメーターを再帰的に検索します。 たとえば、配列自体がジェネリックではない場合でも、要素が型 `A<T>` (Visual Basic では`A(Of T)`) である配列の `true` を返します。 これは、<xref:System.Type.IsGenericType%2A> プロパティの動作と比較して、配列の `false` を返します。  
  
 一連のクラスの例と、<xref:System.Type.ContainsGenericParameters%2A> プロパティの値を示す表については、「<xref:System.Type.IsGenericType%2A>」を参照してください。  
  
   
  
## Examples  
 次の例では、2つの型パラメーターを持つジェネリッククラスを定義し、最初のクラスから派生する2番目のジェネリッククラスを定義します。 派生クラスの基底クラスには、2つの型引数があります。1つ目は <xref:System.Int32>、2つ目は派生型の型パラメーターです。 この例では、<xref:System.Type.GenericParameterPosition%2A> プロパティによって報告された位置を含む、これらのジェネリッククラスに関する情報を表示します。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.MethodBase" /> がジェネリック メソッドの型パラメーターを表している場合に、宣言するメソッドを表す <see cref="T:System.Type" /> を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> がジェネリック メソッドの型パラメーターを表している場合は、宣言メソッドを表す <see cref="T:System.Reflection.MethodBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 宣言するメソッドは、ジェネリックメソッドの定義です。 つまり、<xref:System.Type.DeclaringMethod%2A> が `null`を返さない場合、`DeclaringMethod.IsGenericMethodDefinition` は `true`を返します。  
  
 <xref:System.Type.DeclaringType%2A> と <xref:System.Type.DeclaringMethod%2A> のプロパティは、ジェネリック型の定義またはジェネリック型パラメーターが最初に定義されたジェネリックメソッド定義を識別します。  
  
-   <xref:System.Type.DeclaringMethod%2A> プロパティが <xref:System.Reflection.MethodInfo>を返した場合、その <xref:System.Reflection.MethodInfo> はジェネリックメソッド定義を表し、現在の <xref:System.Type> オブジェクトはそのジェネリックメソッド定義の型パラメーターを表します。  
  
-   <xref:System.Type.DeclaringMethod%2A> プロパティが `null`を返す場合、<xref:System.Type.DeclaringType%2A> プロパティは常にジェネリック型定義を表す <xref:System.Type> オブジェクトを返し、現在の <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
-   <xref:System.Type.IsGenericParameter%2A> プロパティが `false` 型の <xref:System.Type.DeclaringMethod%2A> プロパティを取得すると、<xref:System.InvalidOperationException>がスローされます。  
  
 <xref:System.Type.DeclaringMethod%2A> プロパティによって返される <xref:System.Reflection.MethodBase> は、ジェネリックメソッドの場合は <xref:System.Reflection.MethodInfo>、ジェネリックコンストラクターの場合は <xref:System.Reflection.ConstructorInfo> になります。  
  
> [!NOTE]
>  .NET Framework バージョン2.0 では、ジェネリックコンストラクターはサポートされていません。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、ジェネリックメソッドを持つクラスを定義し、そのメソッドに型引数を割り当てて、構築されたジェネリックメソッドを呼び出します。 また、ジェネリックメソッドの定義と構築されたメソッドについての情報も表示します。 ジェネリックメソッド定義の型パラメーターについての情報を表示するときに、`DisplayGenericMethodInfo` メソッドのコード例では、メソッドのジェネリック型パラメーターの <xref:System.Type.DeclaringMethod%2A> プロパティの値を示しています。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public abstract Type DeclaringType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DeclaringType As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入れ子にされた型またはジェネリック型パラメーターを宣言する型を取得します。</summary>
        <value>現在の型が入れ子にされた型である場合、包含する型を表す <see cref="T:System.Type" /> オブジェクト。現在の型がジェネリック型の型パラメーターである場合、ジェネリック型定義。現在の型がジェネリック メソッドの型パラメーターである場合、ジェネリック メソッドを宣言する型。それ以外の場合、<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> オブジェクトがジェネリック型の型パラメーターを表している場合、このプロパティはジェネリック型定義を返します。  
  
 現在の <xref:System.Type> オブジェクトがジェネリックメソッドの型パラメーターを表している場合、このプロパティは、ジェネリックメソッド定義を含む型を返します。 型がジェネリックの場合は、ジェネリック型の定義が返されます。 つまり、次のコードは、<xref:System.Collections.Generic.List%601.ConvertAll%2A> ジェネリックメソッドを含む <xref:System.Collections.Generic.List%601> ジェネリッククラスのジェネリック型定義を返します。  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、<xref:System.Type.DeclaringType%2A> プロパティと <xref:System.Type.DeclaringMethod%2A> プロパティは、ジェネリック型パラメーターが最初に定義されたジェネリック型定義またはジェネリックメソッド定義を識別します。  
  
-   <xref:System.Type.DeclaringMethod%2A> プロパティが <xref:System.Reflection.MethodInfo>を返した場合、その <xref:System.Reflection.MethodInfo> はジェネリックメソッド定義を表し、現在の <xref:System.Type> オブジェクトはそのジェネリックメソッド定義の型パラメーターを表します。  
  
-   <xref:System.Type.DeclaringMethod%2A> プロパティが `null`を返す場合、<xref:System.Type.DeclaringType%2A> プロパティは常にジェネリック型定義を表す <xref:System.Type> オブジェクトを返し、現在の <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
-   <xref:System.Type.IsGenericParameter%2A> プロパティが `false` 型の <xref:System.Type.DeclaringType%2A> プロパティを取得すると、<xref:System.InvalidOperationException>がスローされます。  
  
   
  
## Examples  
 この例では、派生クラスのメソッドの宣言型を表示します。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のバインダーへの参照を取得します。このバインダーは、<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> によって呼び出される適切なメンバーを選択するための内部規則を実装します。</summary>
        <value>システムで使用される既定のバインダーへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイムに用意されている既定のバインダーは、特に特殊化されたすべての状況で適用できます。 指定された既定のバインダーとは異なる規則に従うバインダーが必要な場合は、<xref:System.Reflection.Binder> クラスから派生した型を定義し、<xref:System.Type.InvokeMember%2A> オーバーロードのいずれかの `binder` パラメーターを使用して、その型のインスタンスを渡します。  
  
 リフレクションは、共通型システムのアクセシビリティ規則をモデル化します。 たとえば、呼び出し元が同じアセンブリ内にある場合、呼び出し元は内部メンバーに対して特別なアクセス許可を必要としません。 それ以外の場合は、呼び出し元に <xref:System.Security.Permissions.ReflectionPermission>が必要です。 これは、protected、private などのメンバーの参照と一致します。  
  
 一般的な原則として、<xref:System.Reflection.Binder.ChangeType%2A> は、データを失うことのない拡大変換のみを実行する必要があります。 拡大変換の例として、32ビット符号付き整数の値を64ビット符号付き整数値に変換する場合が挙げられます。 これは縮小変換と区別されるため、データが失われる可能性があります。 縮小変換の例としては、64ビット符号付き整数を32ビット符号付き整数に変換することが挙げられます。  
  
 次の表に、既定のバインダーでサポートされている変換の一覧を示します。  
  
|ソースの種類|対象になる種類|  
|-----------------|-----------------|  
|任意の型|その基本型。|  
|任意の型|実装するインターフェイス。|  
|Char|Unt16、UInt32、Int32、UInt64、Int64、Single、Double|  
|Byte|Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|Double|  
|非参照|参照渡し。|  
  
   
  
## Examples  
 次の例では、`DefaultBinder` プロパティから既定のバインダーを取得し、`DefaultBinder` 値をパラメーターとして <xref:System.Type.InvokeMember%2A>に渡すことによって、MyClass のメンバーを呼び出します。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> の名前空間で、複数の名前を区切ります。 このフィールドは読み取り専用です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 型の空の配列を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、パラメーターをとらないコンストラクターを取得するために、いずれかの `GetConstructor` メソッドで使用される `EmptyTypes` フィールドを示しています。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Object" /> または <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。 比較を成功させるには、<paramref name="o" /> をキャストまたは型 <see cref="T:System.Type" /> のオブジェクトに変換できる必要があります。</param>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトの基になるシステム型が、指定した <see cref="T:System.Object" /> の基になるシステム型と同じかどうかを判断します。</summary>
        <returns><paramref name="o" /> の基になるシステム型が現在の <see cref="T:System.Type" /> の基になるシステム型と同じである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 次の場合にも、このメソッドは <see langword="false" /> を返します。 
-   <paramref name="o" /> は <see langword="null" /> です。  
  
-   <paramref name="o" /> をキャストまたは <see cref="T:System.Type" /> オブジェクトに変換できない。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Object.Equals%2A?displayProperty=nameWithType> をオーバーライドします。 `o` を <xref:System.Type> 型のオブジェクトにキャストし、<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出します。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.Equals%28System.Object%29> を使用して、さまざまな <xref:System.Type> オブジェクトインスタンスをさまざまな <xref:System.Object> インスタンスと比較します。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 この例については、特に注意すべき点が2つあります。  
  
-   <xref:System.Reflection.TypeInfo> が <xref:System.Type>から派生しているため `true` 整数を表す <xref:System.Reflection.TypeInfo> オブジェクトを持つ整数を表す <xref:System.Type> オブジェクトの比較。  
  
-   `List(Of String)` オブジェクト (クローズジェネリック型) を使用して <xref:System.Collections.Generic.IList%601> オブジェクト (オープンジェネリック型) を表す <xref:System.Type> オブジェクトを比較すると、`false`が返されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Type o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (o As Type) As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(Type ^ o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">基になるシステム型が、現在の <see cref="T:System.Type" /> の基になるシステム型との比較対象になるオブジェクト。</param>
        <summary>現在の <see cref="T:System.Type" /> の基になるシステム型が、指定した <see cref="T:System.Type" /> の基になるシステム型と同じかどうかを判断します。</summary>
        <returns><paramref name="o" /> の基になるシステム型が現在の <see cref="T:System.Type" /> の基になるシステム型と同じである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、`Equals` を使用して2つの型を比較します。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>属性に適用するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドは、<xref:System.Type.FindMembers%2A> メソッドによって使用されるデリゲートへの参照を保持します。 このデリゲートによってカプセル化されるメソッドは、2つのパラメーターを受け取ります。最初のパラメーターは <xref:System.Reflection.MemberInfo> オブジェクトで、2番目のパラメーターは `Object`です。 メソッドは、`MemberInfo` オブジェクトが `Object`によって指定された条件と一致するかどうかを判断します。 `Object` には、クラス <xref:System.Reflection.FieldAttributes>、<xref:System.Reflection.MethodAttributes>、または <xref:System.Reflection.MethodImplAttributes>のいずれかのフィールドの値が割り当てられる場合があります。  
  
 たとえば、`Object` には、`FieldAttributes` のフィールドの値 (Public など) を割り当てることができます。 この場合、`FilterAttribute` デリゲートが呼び出されると、`MemberInfo` オブジェクトによって表されるメソッドがメタデータのパブリックフィールド属性で修飾されている場合にのみ、`true` を返します。  
  
   
  
## Examples  
 次の例では、`FilterAttribute` デリゲートを取得し、それをパラメーターとして <xref:System.Type.FindMembers%2A> メソッドに渡して、指定されたメンバーとその属性を表示します。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別するメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドは、<xref:System.Type.FindMembers%2A> メソッドによって使用されるデリゲートへの参照を保持します。 このデリゲートによってカプセル化されるメソッドは、2つのパラメーターを受け取ります。最初のパラメーターは <xref:System.Reflection.MemberInfo> オブジェクトで、2番目のパラメーターは `Object`です。 メソッドは、`MemberInfo` オブジェクトが `Object`によって指定された条件と一致するかどうかを判断します。 `Object` には文字列値が割り当てられます。文字列値には、末尾に "*" というワイルドカード文字を含めることができます。 ワイルドカードの終了文字列の照合のみがサポートされています。  
  
 たとえば、`Object` に値 "Byte *" が割り当てられている可能性があります。 この場合、`FilterName` デリゲートが呼び出されると、`MemberInfo` オブジェクトによって表されるメソッドの名前が "Byte" で始まる場合にのみ、`true` が返されます。  
  
   
  
## Examples  
 次のコード例では、ユーザー定義 `Application` 型に関連付けられているメソッドを取得します。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に適用され、大文字と小文字を区別しないメンバー フィルターを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドは、<xref:System.Type.FindMembers%2A> メソッドによって使用されるデリゲートへの参照を保持します。 このデリゲートによってカプセル化されるメソッドは、2つのパラメーターを受け取ります。最初のパラメーターは <xref:System.Reflection.MemberInfo> オブジェクトで、2番目のパラメーターは `Object`です。 メソッドは、`MemberInfo` オブジェクトが `Object`によって指定された条件と一致するかどうかを判断します。 `Object` には文字列値が割り当てられます。文字列値には、末尾に "*" というワイルドカード文字を含めることができます。 ワイルドカードの終了文字列の照合のみがサポートされています。  
  
 たとえば、`Object` に値 "ByTe *" が割り当てられている可能性があります。 この場合、`FilterName` デリゲートが呼び出されると、`MemberInfo` オブジェクトによって表されるメソッドの名前が "byte" で始まり、大文字小文字が無視される場合にのみ、true が返されます。  
  
   
  
## Examples  
 次の例では、`MemberFilter` デリゲートを取得し、それをパラメーターとして <xref:System.Type.FindMembers%2A> メソッドに渡し、文字 "c" で始まる `String` クラスのメソッドとその属性を表示します。大文字と小文字は無視されます。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter">インターフェイスを <paramref name="filterCriteria" /> と比較するデリゲート。</param>
        <param name="filterCriteria">返される配列に、検出したインターフェイスを含めるかどうかを判断する検索条件。</param>
        <summary>現在の <see cref="T:System.Type" /> によって実装または継承されているインターフェイスのフィルター適用済みリストを表す、<see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> によって実装または継承されたインターフェイスのフィルター処理されたリストを表している <see cref="T:System.Type" /> オブジェクトの配列。または、フィルターに一致するインターフェイスが現在の <see cref="T:System.Type" /> によって実装または継承されていない場合は、空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
 <xref:System.Reflection.Module?displayProperty=nameWithType> クラスによって提供される <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> および <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> デリゲートは、<xref:System.Reflection.TypeFilter?displayProperty=nameWithType> デリゲートの代わりに使用することもできます。  
  
 このクラスによって実装されるすべてのインターフェイスは、基本クラスまたはこのクラス自体によって宣言されているかどうかにかかわらず、検索時に考慮されます。  
  
 このメソッドは、基底クラスの階層を検索し、各クラスが実装する各インターフェイスと、それらの各インターフェイスが実装するすべての一致するインターフェイスを返します (つまり、一致するインターフェイスの推移的なクロージャが返されます)。 重複するインターフェイスは返されません。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、<xref:System.Type.FindInterfaces%2A> は、型パラメーターの制約で宣言されているすべてのインターフェイスと、制約で宣言されたインターフェイスを介して継承されたすべてのインターフェイスを検索します。 現在の <xref:System.Type> がジェネリック型の型引数を表している場合、<xref:System.Type.FindInterfaces%2A> は、制約に一致するかどうかにかかわらず、型によって実装されているすべてのインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリックではない型でも、<xref:System.Type.FindInterfaces%2A> はジェネリックインターフェイスを返すことができます。 たとえば、非ジェネリック型は `IEnumerable<int>` (`IEnumerable(Of Integer)` Visual Basic) を実装する場合があります。  
  
   
  
## Examples  
 次の例では、指定した型によって実装または継承された指定のインターフェイスを検索し、インターフェイス名を表示します。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType">検索するメンバー型を示す、列挙値のビットごとの組み合わせ。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="filter">比較を実行して、現在調べているメンバーが <see langword="true" /> に一致する場合は <paramref name="filterCriteria" /> を返し、それ以外の場合は <see langword="false" /> を返すデリゲート。</param>
        <param name="filterCriteria"><see langword="MemberInfo" /> オブジェクトの配列でメンバーが返されたかどうかを判断する検索条件。  
  
<see langword="FieldAttributes" />、<see langword="MethodAttributes" />、<see langword="MethodImplAttributes" /> の各フィールドは、このクラスで提供される <see langword="FilterAttribute" /> デリゲートと組み合わせて使用できます。</param>
        <summary>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列にフィルターを適用して返します。</summary>
        <returns>指定したメンバー型の <see cref="T:System.Reflection.MemberInfo" /> オブジェクトのフィルター適用済みの配列。  
  
- または - 
現在の <see cref="T:System.Type" /> に、フィルター条件に一致する <paramref name="memberType" /> 型のメンバーが存在しない場合は、空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

このメソッドは、派生クラスによってオーバーライドできます。  
  
メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。  

`FindMembers` メソッドでメンバー情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、および少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。 

 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。  
  
-   インスタンスメンバーを検索に含めるには、`BindingFlags.Instance` を指定します。  
  
-   `BindingFlags.Static` を指定して、検索に静的メンバーを含めます。  
  
-   パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
このメソッドを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの型パラメーターを表している場合、は、クラス制約および型パラメーターのインターフェイス制約によって宣言されたすべてのメンバーを処理 <xref:System.Type.FindMembers%2A> ます。  

`filter` 引数には、<xref:System.Reflection.MemberFilter>型のカスタムデリゲートを指定することも、次の定義済みデリゲートのいずれかを指定することもできます。

- <xref:System.Type.FilterAttribute?displayProperty=nameWithType>、<xref:System.Reflection.FieldAttributes>、<xref:System.Reflection.MethodAttributes>、または <xref:System.Reflection.MethodImplAttributes> ビットマスクを `filterCriteria` 値として使用します。

- <xref:System.Type.FilterName?displayProperty=nameWithType>、`filterCriteria`に渡された文字列を使用して、各メンバー名の大文字と小文字を区別した比較を実行します。

- <xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>、`filterCriteria`に渡された文字列を使用して、各メンバー名の大文字と小文字を区別しない比較を実行します。

## Examples  
 次の例では、指定した検索条件に一致するクラスのすべてのメンバーを検索し、一致したメンバーを表示します。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の完全修飾名を取得します。その名前空間を含みますが、アセンブリは含みません。</summary>
        <value>型の完全修飾名で、名前空間を含むが、アセンブリは含まないもの。現在のインスタンスが、ジェネリック型パラメーター、配列型、ポインター型、または型パラメーターに基づく<see langword="null" /> 型、またはジェネリック型定義ではないが未解決の型パラメーターを含むジェネリック型を表す場合は、<see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、<xref:System.String> の種類の完全修飾名は `System.String`です。 これは、完全な名前と完全なアセンブリ名で構成される、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返されるアセンブリ修飾名と比較します。  
  
 現在の型がクローズジェネリック型を表している場合、ジェネリック型自体の文字列表現が完全なアセンブリ名で修飾されていなくても、<xref:System.Type.FullName%2A> プロパティによって返される文字列の型引数は完全なアセンブリ名で修飾されます。 次の例は、ジェネリック型定義を表す型の FullName プロパティと、クローズジェネリック型を表す型の違いを示しています。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 このプロパティは、次の場合に `null` を返します。  
  
-   現在の <xref:System.Type> オブジェクトは、ジェネリック型の型パラメーターを表します。  
  
     次の例では、<xref:System.Nullable%601> 型の型パラメーターを取得し、その <xref:System.Type.FullName%2A> プロパティを表示しようとしています。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   現在の <xref:System.Type> オブジェクトは、ジェネリック型パラメーターに基づく配列型、ポインター型、または `byref` 型を表します。  
  
     次の例では、型 T の配列に渡される3つの `Display(T[])`メソッドを使用して、`Generictype1<T>`のジェネリック型を定義しています。`HandleT(T)`。 T オブジェクトが渡されます。および `ChangeValue(ref T)`。参照渡しで T オブジェクトを渡します。 とC# Visual Basic では、`HandleT` メソッドのポインターとして T を定義することはできないため、ジェネリック型へのポインターを作成するには、メソッドのパラメーター型を表す <xref:System.Type> オブジェクトで <xref:System.Type.MakePointerType%2A> メソッドを呼び出す必要があります。 この例の出力は、3つのすべてのケースで、<xref:System.Type.FullName%2A> プロパティが `null`であることを示しています。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   現在の型には、特定の型で置き換えられていないジェネリック型パラメーターが含まれています (つまり、<xref:System.Type.ContainsGenericParameters%2A> プロパティは `true`を返します) が、型はジェネリック型定義ではありません (つまり、<xref:System.Type.IsGenericTypeDefinition%2A> プロパティはを返し `false`  
  
     次の例では、`Derived<T>` が `Base<T>`から継承されます。 <xref:System.Type.BaseType%2A> プロパティは `Derived<T>`の基本型を表す <xref:System.Type> オブジェクトを取得し、その <xref:System.Type.FullName%2A> プロパティは `null`を返します。  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     `null`ない <xref:System.Type.FullName%2A> を取得するには、例に示すように、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドを使用してジェネリック型定義を取得します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、指定された型の完全な名前を表示します。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 次の例では、<xref:System.Type.ToString%2A> メソッドによって返される文字列と、`Name`、<xref:System.Type.FullName%2A>、および <xref:System.Type.AssemblyQualifiedName%2A> プロパティを比較します。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のジェネリック型パラメーターの共変性および特殊な制約を説明する <see cref="T:System.Reflection.GenericParameterAttributes" /> フラグの組み合わせを取得します。</summary>
        <value>現在のジェネリック型パラメーターの共変性と特殊な制約を表す <see cref="T:System.Reflection.GenericParameterAttributes" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値には、現在のジェネリック型パラメーターが共変であるかどうかを示すフラグと、特殊な制約を示すフラグが含まれます。 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> 値を使用して共変性フラグを選択し、<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> 値を使用して制約フラグを選択します。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、異なる制約を持つ2つの型パラメーターを持つジェネリック型 `Test` を定義しています。 プログラムの実行時には、<xref:System.Type.GenericParameterAttributes%2A> プロパティと <xref:System.Type.GetGenericParameterConstraints%2A> メソッドを使用して制約が検査されます。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public abstract int GenericParameterPosition { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int GenericParameterPosition { int get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> オブジェクトがジェネリック型またはジェネリック メソッドの型パラメーターを表す場合に、パラメーターを宣言したジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置を取得します。</summary>
        <value>パラメーターを定義するジェネリック型またはジェネリック メソッドの型パラメーター リスト内の型パラメーターの位置。 位置の番号は 0 で始まります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> プロパティは、型パラメーターが最初に定義されたジェネリック型定義またはジェネリックメソッド定義のパラメーターリスト内の型パラメーターの位置を返します。 <xref:System.Type.DeclaringType%2A> プロパティと <xref:System.Type.DeclaringMethod%2A> プロパティは、ジェネリック型またはメソッドの定義を識別します。  
  
-   <xref:System.Type.DeclaringMethod%2A> プロパティが <xref:System.Reflection.MethodInfo>を返した場合、その <xref:System.Reflection.MethodInfo> はジェネリックメソッド定義を表し、現在の <xref:System.Type> オブジェクトはそのジェネリックメソッド定義の型パラメーターを表します。  
  
-   <xref:System.Type.DeclaringMethod%2A> プロパティが `null`を返す場合、<xref:System.Type.DeclaringType%2A> プロパティは常にジェネリック型定義を表す <xref:System.Type> オブジェクトを返し、現在の <xref:System.Type> オブジェクトはそのジェネリック型定義の型パラメーターを表します。  
  
 <xref:System.Type.GenericParameterPosition%2A> プロパティの値に適切なコンテキストを提供するには、型パラメーターが属するジェネリック型またはメソッドを識別する必要があります。 たとえば、次のコードでは、ジェネリックメソッド `GetSomething` の戻り値を考えてみます。  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 `GetSomething` によって返される型は、クラス `A` に指定された型引数に依存し、それ自体を `GetSomething` します。 `GetSomething`の <xref:System.Reflection.MethodInfo> を取得できます。また、戻り値の型を取得できます。 戻り値の型の型パラメーターを確認すると、<xref:System.Type.GenericParameterPosition%2A> は両方に対して0を返します。 `V` の位置は0です。これは `V` がクラス `A`の型パラメーターリストの最初の型パラメーターであるためです。 `X` の位置は0です。これは、`X` が `GetSomething`の型パラメーターリストの最初の型パラメーターであるためです。  
  
> [!NOTE]
>  現在の <xref:System.Type> が型パラメーターを表していない場合、<xref:System.Type.GenericParameterPosition%2A> プロパティを呼び出すと例外が発生します。 オープン構築型の型引数を調べる場合は、<xref:System.Type.IsGenericParameter%2A> プロパティを使用して、型パラメーターと型を指定します。 <xref:System.Type.IsGenericParameter%2A> プロパティは、型パラメーターの `true` を返します。その後、<xref:System.Type.GenericParameterPosition%2A> メソッドを使用してその位置を取得し、<xref:System.Type.DeclaringMethod%2A> プロパティと <xref:System.Type.DeclaringType%2A> プロパティを使用して、それを定義するジェネリックメソッドまたは型定義を確認できます。  
  
   
  
## Examples  
 次の例では、2つの型パラメーターを持つジェネリッククラスを定義し、最初のクラスから派生する2番目のジェネリッククラスを定義します。 派生クラスの基底クラスには、2つの型引数があります。1つ目は <xref:System.Int32>で、2つ目は派生型の型パラメーターです。 この例では、<xref:System.Type.GenericParameterPosition%2A> プロパティによって報告された位置を含む、これらのジェネリッククラスに関する情報を表示します。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型は型パラメーターを表していません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> は <see langword="false" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public abstract Type[] GenericTypeArguments { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型のジェネリック型引数の配列を取得します。</summary>
        <value>この型のジェネリック型引数の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、ジェネリック型引数のみを取得します。これは、現在の型のジェネリック型パラメーターに対して指定された型です。 現在の型がジェネリック型定義の場合、このプロパティは空の配列を返します。  
  
> [!NOTE]
>  ジェネリック型がジェネリックメソッドまたは別のジェネリック型で使用されている場合、そのジェネリック型引数の一部は、外側のメソッドまたは型のジェネリック型パラメーターである可能性があります。  
  
 ジェネリック型の定義を表す型のジェネリック型パラメーターを取得するには、<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> プロパティを使用します。 現在の <xref:System.Type> オブジェクトの <xref:System.Reflection.TypeInfo> オブジェクトを取得するには、<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> 拡張メソッドを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public abstract int GetArrayRank ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetArrayRank () As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetArrayRank();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>配列の次元数を取得します。</summary>
        <returns>現在の型の次元数である整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、配列の次元数を表示します。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドの機能は、基底クラスではサポートされていないため、代わりに派生クラスで実装する必要があります。</exception>
        <exception cref="T:System.ArgumentException">現在の型は配列ではありません。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、<see cref="P:System.Type.Attributes" /> プロパティを実装し、<see cref="T:System.Type" /> に関連付けられている属性を示す列挙値のビットごとの組み合わせを取得します。</summary>
        <returns><see cref="T:System.Reflection.TypeAttributes" /> の属性のセットを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のコンストラクターを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types">目的のコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列。 このような空の配列は、<see langword="static" /> フィールド <see cref="F:System.Type.EmptyTypes" /> によって提供されます。</param>
        <summary>指定した配列の型に一致するパラメーターが設定されているパブリック インスタンス コンストラクターを検索します。</summary>
        <returns>パラメーター型配列の型と一致するパラメーターが設定されているパブリック インスタンス コンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドオーバーロードは、パブリックインスタンスコンストラクターを検索します。クラス初期化子 (静的コンストラクター) を取得するために使用することはできません。 クラス初期化子を取得するには、<xref:System.Reflection.BindingFlags>を受け取るオーバーロードを使用し&#124; 、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 要求されたコンストラクターがパブリックでない場合、このメソッドは `null`を返します。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.ConstructorInfo> を返します。 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは常に `null`を返します。  
  
   
  
## Examples  
 次の例では、`MyClass`の型を取得し、<xref:System.Reflection.ConstructorInfo> オブジェクトを取得して、コンストラクターシグネチャを表示します。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> が <see langword="null" /> です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。  
  
- または - 
 <see cref="F:System.Type.EmptyTypes" />。</param>
        <param name="modifiers">パラメーター型配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完全に一致するものが存在しない場合、一致を選択するために、`binder` は `types` 配列に指定されているパラメーターの型を強制的に強制しようとします。 `binder` が一致を選択できない場合は、`null` が返されます。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックコンストラクターを含めるには、`BindingFlags.Public` を指定します。  
  
-   `BindingFlags.NonPublic` を指定して、検索で非パブリックコンストラクター (プライベート、内部、およびプロテクトコンストラクター) を含めるようにします。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.ConstructorInfo> を返します。 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは常に `null`を返します。  
  
   
  
## Examples  
 次のプログラムは `MyClass1` クラスの型を取得し、指定したバインディングフラグに一致する <xref:System.Reflection.ConstructorInfo> オブジェクトを取得し、コンストラクターのシグネチャを表示します。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> が <see langword="null" /> です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。  
  
- または - 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規則を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 完全に一致するものが存在しない場合、一致を選択するために、`binder` は `types` 配列に指定されているパラメーターの型を強制的に強制しようとします。 `binder` が一致を選択できない場合は、`null` が返されます。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックコンストラクターを含めるには、`BindingFlags.Public` を指定します。  
  
-   `BindingFlags.NonPublic` を指定して、検索で非パブリックコンストラクター (プライベート、内部、およびプロテクトコンストラクター) を含めるようにします。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|スタティック|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.ConstructorInfo> を返します。 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは常に `null`を返します。  
  
   
  
## Examples  
 次の例では、`MyClass1`の型を取得し、指定したバインディングフラグと一致する <xref:System.Reflection.ConstructorInfo> オブジェクトを取得し、コンストラクターシグネチャを表示します。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> が <see langword="null" /> です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。  
  
- または - 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
<see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するコンストラクターのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないコンストラクターを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されているコンストラクターを検索します。</summary>
        <returns>指定した要件と一致するコンストラクターが存在する場合は、そのコンストラクターを表す <see cref="T:System.Reflection.ConstructorInfo" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 完全に一致するものが存在しない場合、一致を選択するために、`binder` は `types` 配列に指定されているパラメーターの型を強制的に強制しようとします。 `binder` が一致を選択できない場合は、`null` が返されます。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックコンストラクターを含めるには、`BindingFlags.Public` を指定します。  
  
-   `BindingFlags.NonPublic` を指定して、検索で非パブリックコンストラクター (プライベート、内部、およびプロテクトコンストラクター) を含めるようにします。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドは、<xref:System.Type.GetConstructor%2A> を実装します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> が <see langword="null" /> です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。  
  
- または - 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のコンストラクターを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> に対して定義されているパブリック コンストラクターをすべて返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.ConstructorInfo" /> に対して定義されたすべてのパブリック インスタンス コンストラクター (ただし、型初期化子 (静的コンストラクター) を除く) を表している <see cref="T:System.Type" /> オブジェクトの配列。 パブリック インスタンス コンストラクターが現在の <see cref="T:System.Type" /> に対して定義されている場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> メソッドは、宣言の順序など、特定の順序でコンストラクターを返しません。 コードは、コンストラクターが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 このメソッドオーバーロードは、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> Visual Basic) を使用して、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> メソッドのオーバーロードを呼び出します。 クラス初期化子 (静的コンストラクター) は見つかりません。 クラス初期化子を検索するには、<xref:System.Reflection.BindingFlags>を受け取るオーバーロードを使用&#124;し、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.ConstructorInfo> オブジェクトを返します。 たとえば、クラス `C<T>` にコンストラクター `C(T t1)` (Visual Basic 内の`Sub New(ByVal t1 As T)`) がある場合、<xref:System.Type.GetConstructors%2A> で `C<int>` を呼び出すと、(<xref:System.Reflection.ConstructorInfo> C#の `C(int t1)`) の`Sub New(ByVal t1 As Integer)` を表す Visual Basic が返されます。  
  
 現在の <xref:System.Type> がジェネリック型パラメーターを表している場合、<xref:System.Type.GetConstructors%2A> メソッドは空の配列を返します。  
  
   
  
## Examples  
 この例では、2つのインスタンスコンストラクターと1つの静的コンストラクターを持つクラスからの <xref:System.Type.GetConstructors%2A> オーバーロードの出力を示します。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力は次のとおりです。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors> のオーバーロードは <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>のみを使用するため、静的コンストラクターは `for` 式によってカウントされることも、`IsStatic`によって評価されることもありません。  
  
 静的コンストラクターを検索するには、次のコード例に示すように、<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> のオーバーロードを使用し、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>の組み合わせ (論理 `OR`) を渡します。  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 出力は次のようになります。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定した <see langword="BindingFlags" /> を使用して、現在の <see cref="T:System.Type" /> に対して定義されているコンストラクターを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.ConstructorInfo" /> にコンストラクターが定義されている場合は、型初期化子を含め、定義されているコンストラクターのうち指定したバインディング制約に一致するすべてのコンストラクターを表す <see cref="T:System.Type" /> オブジェクトの配列。 現在の <see cref="T:System.Type" /> に対してコンストラクターが定義されていない場合、または現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、型 <see cref="T:System.Reflection.ConstructorInfo" /> の空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
`bindingAttr` を使用すると、パブリックコンストラクターだけを返すか、パブリックコンストラクターと非パブリックコンストラクターの両方を返すかを指定できます。  
  
次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるコンストラクターを定義できます。  
  
- クラス初期化子 (静的コンストラクター) を取得するには、`BindingFlags.NonPublic` と共に `BindingFlags.Static` を指定します。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。

- インスタンスコンストラクターを取得するには、`BindingFlags.Public` と `BindingFlags.NonPublic` の一方または両方と共に `BindingFlags.Instance` を指定します。   
  
詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  

<xref:System.Type.GetConstructors%2A> メソッドは、宣言の順序など、特定の順序でコンストラクターを返しません。 コードは、コンストラクターが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  

現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.ConstructorInfo> オブジェクトを返します。 たとえば、クラス `C<T>` にコンストラクター `C(T t1)` (Visual Basic 内の`Sub New(ByVal t1 As T)`) がある場合、<xref:System.Type.GetConstructors%2A> で `C<int>` を呼び出すと、(<xref:System.Reflection.ConstructorInfo> C#の `C(int t1)`) の`Sub New(ByVal t1 As Integer)` を表す Visual Basic が返されます。  
  
現在の <xref:System.Type> がジェネリック型パラメーターを表している場合、<xref:System.Type.GetConstructors%2A> メソッドは空の配列を返します。  
  
## Examples  

この例では、2つのインスタンスコンストラクターと1つの静的コンストラクターを持つクラスからの <xref:System.Type.GetConstructors> オーバーロードの出力を示します。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 このコードの出力は次のとおりです。  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Type.GetConstructors%2A> のオーバーロードは <xref:System.Reflection.BindingFlags.Public> と <xref:System.Reflection.BindingFlags.Instance>のみを使用するため、静的コンストラクターは `for` 式によってカウントされることも、`IsStatic`によって評価されることもありません。  
  
 静的コンストラクターを検索するには、次のコード例に示すように、<xref:System.Type.GetConstructors%2A> のオーバーロードを使用し、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>の組み合わせ (論理 OR) を渡します。  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 出力は次のようになります。  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Type" /> が設定されている現在の <see cref="T:System.Reflection.DefaultMemberAttribute" /> に定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべての既定メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.MemberInfo" /> に既定のメンバーがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。 コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MemberInfo> オブジェクトを返します。 たとえば、クラス `C<T>` に `T`を返すプロパティ `P` がある場合、`C<int>` で <xref:System.Type.GetDefaultMembers%2A> を呼び出すとC# 、(`int P` の`Property P As Integer`) の Visual Basic が返されます。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。  
  
   
  
## Examples  
 次の例では、`MyClass` の既定のメンバー情報を取得し、既定のメンバーを表示します。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" /> を返します。</summary>
        <returns>現在の配列、ポインター、または参照型によって包含または参照されるオブジェクトの <see cref="T:System.Type" />。現在の <see langword="null" /> が配列またはポインターではない場合、参照によって渡されない場合、ジェネリック型やジェネリック型またはジェネリック メソッドの定義の型パラメーターを表している場合は、<see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Array> クラスの `null` を返します。  
  
   
  
## Examples  
 `GetElementType` メソッドの使用例を次に示します。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">名前を取得する対象の値。</param>
        <summary>現在の列挙型の指定された値を持つ定数の名前を返します。</summary>
        <returns>指定された値を持つ現在の列挙型のメンバーの名前。そのような定数が見つからない場合は、<see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
- または - 
 <paramref name="value" /> は、現在の型ではなく、基になる型が現在の型と同じでもありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型のメンバーの名前を返します。</summary>
        <returns>列挙型のメンバーの名前が含まれている配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 戻り値の配列の要素は、列挙定数のバイナリ値 (符号なしの値) によって並べ替えられます。 配列に同じ値を持つ列挙定数が含まれている場合は、対応する名前の順序が指定されていません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の基になる型を返します。</summary>
        <returns>現在の列挙型の基になる型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、 C#および Visual Basic の列挙型の基になる型は <xref:System.Int32>です。 その他の整数型を指定できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。  
  
 - または -  
  
 列挙型に複数のインスタンス フィールドが含まれているため、無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の列挙型の定数の値の配列を返します。</summary>
        <returns>値を格納する配列。 配列の要素は列挙定数のバイナリ値 (符号なしの値) に基づいて並べ替えられます。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されている特定のイベントを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</param>
        <summary>指定したパブリック イベントを表す <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で宣言または継承されている指定パブリック イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。 それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックの静的インスタンスイベントとパブリックインスタンスイベントが含まれます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.EventInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例では、<xref:System.Reflection.EventInfo> オブジェクトを作成し、指定したイベントのボタンクラスのイベントを取得します。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">現在の <see cref="T:System.Type" /> で宣言または継承されているイベントの名前を格納する文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定されたバイディング制約を使用して、指定されたイベントを表わす <see cref="T:System.Reflection.EventInfo" /> オブジェクトを返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で宣言または継承されている指定イベントが存在する場合は、そのイベントを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるイベントを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックイベントを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックイベント (プライベート、内部、および保護されたイベント) を含めるには、`BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたイベントではなく、<xref:System.Type>で宣言されたイベントのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。 それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.EventInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> メソッドを使用して、`static` (Visual Basic で`Shared`) ではない、"Click" という名前のパブリックまたは非パブリックイベントの型を検索します。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で宣言または継承されているすべてのパブリック イベントを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているすべてのパブリック イベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.EventInfo" /> にパブリック イベントがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。 それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 <xref:System.Type.GetEvents%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でイベントを返しません。 コードは、イベントが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.EventInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例では、<xref:System.Reflection.EventInfo> オブジェクトの配列を取得し、`Button` クラスのすべてのイベントを取得して、イベント名を表示します。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。

- または -

 空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> で宣言または継承されているイベントを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.EventInfo" /> で宣言または継承されているイベントのうち、指定したバインディング制約に一致するすべてのイベントを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.EventInfo" /> にイベントが存在しないか、またはイベントの中にバインディング制約に一致するものがない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でイベントを返しません。 コードは、イベントが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるイベントを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックイベントを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックイベント (プライベート、内部、および保護されたイベント) を含めるには、`BindingFlags.NonPublic` を指定します。 基底クラスのプロテクトイベントと内部イベントのみが返されます。基底クラスのプライベートイベントは返されません。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   単純に継承されたイベントではなく、<xref:System.Type>で宣言されたイベントのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 パブリックであるメソッドまたはアクセサーが少なくとも1つある場合、イベントはリフレクションに対してパブリックと見なされます。 それ以外の場合、イベントはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.EventInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のイベントを検索します。  
  
   
  
## Examples  
 次の例では、指定したバインディングフラグに一致する <xref:System.Reflection.EventInfo> オブジェクトの配列を取得し、`Button` クラスのすべてのイベントを取得して、イベント名を表示します。 Visual Basic の例をコンパイルするには、次のコマンドラインを使用します。  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のフィールドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック フィールドを検索します。</summary>
        <returns>指定した名前のパブリック フィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックの静的およびパブリックインスタンスフィールドが含まれます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.FieldInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のフィールドを検索します。  
  
   
  
## Examples  
 次の例では、指定されたクラスの `Type` オブジェクトを取得し、フィールドの <xref:System.Reflection.FieldInfo> オブジェクトを取得して、フィールドの値を表示します。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この <see cref="T:System.Type" /> オブジェクトは、<see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> メソッドがまだ呼び出されていない <see cref="T:System.Reflection.Emit.TypeBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するデータ フィールドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>指定したバインディング制約を使用して、指定したフィールドを検索します。</summary>
        <returns>指定した要件と一致するフィールドが存在する場合は、そのフィールドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるフィールドを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックフィールドを含めるには、`BindingFlags.Public` を指定します。  
  
-   `BindingFlags.NonPublic` を指定すると、パブリックでないフィールド (プライベート、内部、および保護されたフィールド) を検索に含めることができます。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたフィールドではなく、<xref:System.Type>で宣言されたフィールドのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.FieldInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のフィールドを検索します。  
  
   
  
## Examples  
 次の例では、指定されたクラスの `Type` オブジェクトを取得し、指定したバインディングフラグと一致するフィールドの <xref:System.Reflection.FieldInfo> オブジェクトを取得し、フィールドの値を表示します。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のフィールドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック フィールドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.FieldInfo" /> に対して定義されているすべてのパブリック フィールドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.FieldInfo" /> に対してパブリック フィールドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でフィールドを返しません。 この順序は変化するため、コードは返されるフィールドの順序に依存しないようにする必要があります。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.FieldInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のパブリックフィールドを検索します。  
  
   
  
## Examples  
 次の例は、`GetFields()` メソッドの使用方法を示しています。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。

- または -

 空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているフィールドを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> に対して定義されているフィールドのうち、指定したバインディング制約に一致するすべてのフィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.FieldInfo" /> に対してフィールドが定義されていないか、または定義されているフィールドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`GetFields(BindingFlags)` オーバーロードでプロパティ情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、および少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。 

次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるフィールドを定義できます。  
  
- インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。 

- 静的メソッドを含めるには `BindingFlags.Static` を指定します。 
    
- 検索にパブリックフィールドを含めるには、`BindingFlags.Public` を指定します。  
  
- `BindingFlags.NonPublic` を指定すると、パブリックでないフィールド (プライベート、内部、および保護されたフィールド) を検索に含めることができます。 基底クラスの protected フィールドと internal フィールドのみが返されます。基底クラスのプライベートフィールドは返されません。  
  
- `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  

- 空の <xref:System.Reflection.PropertyInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。

次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
- 単純に継承されたフィールドではなく、<xref:System.Type>で宣言されたフィールドのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
<xref:System.Type.GetFields%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でフィールドを返しません。 この順序は変化するため、コードは返されるフィールドの順序に依存しないようにする必要があります。  

 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.FieldInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラス制約のパブリックフィールドを検索します。  
  
## Examples  
 次の例は、`GetFields(BindingFlags)` メソッドの使用方法を示しています。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>クローズ ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>ジェネリック型の型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。 現在の型がジェネリック型でない場合は空の配列を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配列要素は、ジェネリック型の型引数のリストに出現する順序で返されます。  
  
-   現在の型が構築されたクローズ型である場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A> プロパティが `false`を返す場合)、<xref:System.Type.GetGenericArguments%2A> メソッドによって返される配列には、ジェネリック型定義のジェネリック型パラメーターに割り当てられた型が含まれます。  
  
-   現在の型がジェネリック型の定義の場合、配列には型パラメーターが含まれます。  
  
-   現在の型がオープン構築型である場合 (つまり、<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`を返します)、特定の型が、外側のジェネリック型または外側のジェネリックメソッドの型パラメーターと型パラメーターのすべてに割り当てられていない場合、配列には型と型の両方のパラメーターが含まれます。 <xref:System.Type.IsGenericParameter%2A> プロパティを使用して、それらを区別します。 このシナリオのデモについては、<xref:System.Type.ContainsGenericParameters%2A> プロパティのコード例を参照してください。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetGenericArguments%2A> メソッドを使用して、構築された型の型引数と、そのジェネリック型定義の型パラメーターを表示します。  
  
 このコード例は、<xref:System.Type.IsGenericTypeDefinition%2A> プロパティ用に用意されている大規模な例の一部です。 サンプル出力については、大きな例を参照してください。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> オブジェクトの配列を返します。</summary>
        <returns>現在のジェネリック型パラメーターの制約を表す <see cref="T:System.Type" /> の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型パラメーターの各制約は、<xref:System.Type> オブジェクトとして表されます。 制約が基底クラスの制約であるかどうかを判断するには、<xref:System.Type.IsClass%2A> プロパティを使用します。プロパティが `false`を返す場合、制約はインターフェイスの制約です。 型パラメーターにクラスの制約とインターフェイスの制約がない場合は、空の配列が返されます。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、異なる制約を持つ2つの型パラメーターを持つジェネリック型 `Test` を定義しています。 プログラムの実行時には、<xref:System.Type.GenericParameterAttributes%2A> プロパティと <xref:System.Type.GetGenericParameterConstraints%2A> メソッドを使用して制約が検査されます。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> オブジェクトは、ジェネリック型パラメーターではありません。 つまり、<see cref="P:System.Type.IsGenericParameter" /> プロパティが <see langword="false" /> を返します。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public abstract Type GetGenericTypeDefinition ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetGenericTypeDefinition () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetGenericTypeDefinition();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のジェネリック型を構築する元になるジェネリック型定義を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型を構築する元になるジェネリック型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型定義は、他の型を構築できるテンプレートです。 たとえば、ジェネリック型定義から `G<T>` (構文でC#表されます。 Visual Basic または `generic <typename T> ref class G` で `G(Of T)` C++)、型を構築およびインスタンス化できます (`G<int>` で`G(Of Integer)`)。 この構築された型を表す <xref:System.Type> オブジェクトがある場合、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドはジェネリック型の定義を返します。  
  
 同じ型引数を使用して、同じジェネリック型定義から2つの構築型が作成された場合、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドは、両方の型に対して同じ <xref:System.Type> オブジェクトを返します。  
  
 ジェネリック型定義を既に表す <xref:System.Type> オブジェクトで <xref:System.Type.GetGenericTypeDefinition%2A> メソッドを呼び出すと、現在の <xref:System.Type>が返されます。  
  
> [!IMPORTANT]
>  ジェネリック型の配列は、それ自体がジェネリックではありません。 C#コード `A<int>[] v;` または Visual Basic コード `Dim v() As A(Of Integer)`では、変数 `v` の型はジェネリックではありません。 <xref:System.Type.GetGenericTypeDefinition%2A>を呼び出す前に、型がジェネリックであるかどうかを判断するには、<xref:System.Type.IsGenericType%2A> を使用します。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次のコード例では、通常のインスタンス作成を使用して構築された型のインスタンスを作成した後、<xref:System.Type.GetType%2A> メソッドと <xref:System.Type.GetGenericTypeDefinition%2A> メソッドを使用して、構築された型とジェネリック型定義を取得します。 この例では、ジェネリック <xref:System.Collections.Generic.Dictionary%602> 型を使用します。構築された型は、文字列キーを持つ `Test` オブジェクトの <xref:System.Collections.Generic.Dictionary%602> を表します。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型ではありません。  つまり、<see cref="P:System.Type.IsGenericType" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>対象のインスタンスのハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> をオーバーライドします。  
  
   
  
## Examples  
 次の例では、`System.Windows.Forms.Button` クラスのハッシュコードを表示します。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> で実装または継承されている特定のインターフェイスを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <summary>指定した名前のインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` の検索では大文字と小文字が区別されます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Type> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、インターフェイスの制約と、クラスまたはインターフェイスの制約から継承されたインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリックインターフェイスの場合、`name` パラメーターは、完全に修飾された名前になります。最後に、アクサングラーブ (\`) と型パラメーターの数で終わります。 これは、ジェネリックインターフェイスの定義と構築されたジェネリックインターフェイスの両方に当てはまります。 たとえば、`IExample<T>` (Visual Basic で`IExample(Of T)`) または `IExample<string>` (`IExample(Of String)` で Visual Basic) を検索するには、``"IExample`1"``を検索します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%29> メソッドを使用して、<xref:System.Runtime.Serialization.IDeserializationCallback> インターフェイスの <xref:System.Collections.Hashtable> クラスを検索し、インターフェイスのメソッドを一覧表示します。  
  
 このコード例では、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> メソッドのオーバーロードと <xref:System.Type.GetInterfaceMap%2A> メソッドも示しています。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するインターフェイスの名前を格納している文字列。 ジェネリック インターフェイスの場合、これは完全修飾名です。</param>
        <param name="ignoreCase">単純なインターフェイス名を指定する <see langword="true" /> の部分 (名前空間が大文字と小文字を厳密に区別することを指定されている部分) で大文字と小文字の区別を無視する場合は、<paramref name="name" />。  
  
- または - 
 <see langword="false" /> のすべての部分の検索時に大文字と小文字を区別する場合は、<paramref name="name" />。</param>
        <summary>派生クラスでオーバーライドされた場合、インターフェイス名の大文字と小文字を区別するかどうかを指定して、指定したインターフェイスを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスのうち、指定した名前のインターフェイスが存在する場合は、そのインターフェイスを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` パラメーターは、名前空間ではなく、単純なインターフェイス名にのみ適用されます。 名前空間を指定する `name` の部分には、正しい case が必要です。そうでない場合、インターフェイスが見つかりません。 たとえば、文字列 "system.icomparable" は <xref:System.IComparable> インターフェイスを検出しますが、文字列 "system.icomparable" は検索しません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Type> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、インターフェイスの制約と、クラスまたはインターフェイスの制約から継承されたインターフェイスを検索します。  
  
> [!NOTE]
>  ジェネリックインターフェイスの場合、`name` パラメーターは、完全に修飾された名前になります。最後に、アクサングラーブ (\`) と型パラメーターの数で終わります。 これは、ジェネリックインターフェイスの定義と構築されたジェネリックインターフェイスの両方に当てはまります。 たとえば、`IExample<T>` (Visual Basic で`IExample(Of T)`) または `IExample<string>` (`IExample(Of String)` で Visual Basic) を検索するには、`"IExample`1 "' を検索します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Collections.IEnumerable> インターフェイスの <xref:System.Collections.Hashtable> クラスの大文字と小文字を区別せずに検索を実行します。  
  
 このコード例では、<xref:System.Type.GetInterface%28System.String%29> メソッドのオーバーロードと <xref:System.Type.GetInterfaceMap%2A> メソッドも示しています。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">現在の <see cref="T:System.Type" /> は、別の型の引数と同じジェネリック インターフェイスを実装する型を表します。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType">割り当ての取得対象であるインターフェイス型。</param>
        <summary>指定したインターフェイス型に対するインターフェイスの割り当てを返します。</summary>
        <returns><paramref name="interfaceType" /> に対するインターフェイスの割り当てを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インターフェイスマップは、インターフェイスが、そのインターフェイスを実装するクラスの実際のメンバーにどのようにマップされるかを示します。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、型パラメーターは、このメソッドによって返される <xref:System.Reflection.InterfaceMapping> の要素内の適切な型引数に置き換えられます。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.GetInterfaceMap%2A> メソッドを呼び出して、<xref:System.IFormatProvider> インターフェイスが <xref:System.Globalization.CultureInfo> メソッドにどのようにマップされるか、および <xref:System.IAppDomainSetup> インターフェイスが <xref:System.AppDomainSetup> プロパティにどのようにマップされるかを決定します。 <xref:System.IAppDomainSetup> インターフェイスは一連のプロパティを定義するため、返された <xref:System.Reflection.InterfaceMapping> オブジェクトには、プロパティの get アクセサーと set アクセサーに対して個別の <xref:System.Reflection.MethodInfo> オブジェクトが含まれていることに注意してください。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" /> は、現在の型では実装されていません。  
  
- または - 
<paramref name="interfaceType" /> 引数は、インターフェイスを参照しません。  
  
- または -

現在のインスタンスまたは <paramref name="interfaceType" /> 引数はオープン ジェネリック型です。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> プロパティは <see langword="true" /> を返します。

- または -


 <paramref name="interfaceType" /> ジェネリック インターフェイスで、現在の型は配列型です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Type" /> はジェネリック型パラメーターを表しています。つまり、 <see cref="P:System.Type.IsGenericParameter" /> は <see langword="true" />です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> で実装または継承されているすべてのインターフェイスを表す <see cref="T:System.Type" />オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Type" /> で実装または継承されているインターフェイスが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でインターフェイスを返しません。 この順序は変化するため、コードはインターフェイスが返される順序に依存しないようにする必要があります。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Type> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、インターフェイスの制約と、クラスまたはインターフェイスの制約から継承されたインターフェイスを検索します。  
  
   
  
## Examples  
 次の例では、指定したクラスの型を取得し、その型によって実装または継承されるすべてのインターフェイスを表示します。 Visual Basic の例をコンパイルするには、次のコンパイラコマンドを使用します。  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">静的初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメンバーのうち、指定したメンバーを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メンバーの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックな静的およびパブリックインスタンスのメンバーが含まれます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。  
  
 <xref:System.Type.GetMember%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。 コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 このメソッドオーバーロードは、クラス初期化子 (静的コンストラクター) を検索しません。 クラス初期化子を検索するには、<xref:System.Reflection.BindingFlags>を受け取るオーバーロードを使用&#124;し、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MemberInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。  
  
   
  
## Examples  
 次の例では、C 文字で始まる `String` クラスのすべてのメンバーを表示します。  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を含む文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>指定したバインディング制約を使用して、指定したメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
 メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。  
  
 <xref:System.Type.GetMember%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。 コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するには、`name`に対して "static &#124;コンストラクター" を指定し、`Or`の <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> する必要があります。`bindingAttr` <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MemberInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。  
  
   
  
## Examples  
 次の例では、C 文字で始まる `myString` クラスのすべてのパブリック静的メンバーを表示します。  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するメンバーの名前を含む文字列。</param>
        <param name="type">検索する値。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>指定されたバインディング制約を使用して、指定されたメンバー型の指定されたメンバーを検索します。</summary>
        <returns>指定した名前のパブリック メンバーが存在する場合は、そのメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの配列。それ以外の場合は空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーには、プロパティ、メソッド、フィールド、イベントなどが含まれます。  
  
 <xref:System.Type.GetMember%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。 コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するには、`name`の場合は "static コンストラクター"、`type`&#124;の場合は <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType>、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> の場合は <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>(`Or`で <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定する必要があります。`bindingAttr` <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MemberInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。  
  
   
  
## Examples  
 次の例では、C 文字で始まる `myString` クラスのすべてのメソッドが表示されます。  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">派生クラスにより実装が提供される必要があります。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメンバー (プロパティ、メソッド、フィールド、イベントなど) を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メンバーを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> のすべてのパブリック メンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.MemberInfo" /> にパブリック メンバーが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

メンバーには、プロパティ、メソッド、コンストラクター、フィールド、イベント、および入れ子にされた型が含まれます。
  
 <xref:System.Type.GetMembers%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。 コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 このメソッドオーバーロードは、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>で `Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>) を使用して <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> メソッドのオーバーロードを呼び出します。 クラス初期化子 (静的コンストラクター) は見つかりません。 クラス初期化子を検索するには、<xref:System.Type.GetMembers(System.Reflection.BindingFlags)> のオーバーロードを&#124;呼び出し、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or`で<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType><xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) を指定します。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MemberInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。 
  
## Examples  
 次のコード例は、<xref:System.Type.GetMembers> メソッドのオーバーロードを使用して、指定したクラスのすべてのパブリックメンバーに関する情報を収集する方法を示しています。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメンバーを検索します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MemberInfo" /> に対して定義されているメンバーのうち、指定したバインディング制約に一致するすべてのメンバーを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Type" /> に対してメンバーが定義されていないか、または定義されているメンバーの中にバインディング制約に一致するものが存在しない場合は、空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

メンバーには、プロパティ、メソッド、コンストラクター、フィールド、イベント、および入れ子にされた型が含まれます。

`GetMethods(BindingFlags)` オーバーロードでメソッド情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>を含める必要があります。また、少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。 唯一の例外は <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>を使用したメソッド呼び出しで、入れ子になった型に関するメンバー情報が返されます。

次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。 

- インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。 

- 静的メソッドを含めるには `BindingFlags.Static` を指定します。 
  
- 検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。  
  
- 検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。 基底クラスのプロテクトメソッドと内部メソッドのみが返されます。基底クラスのプライベートメソッドは返されません。  
  
- `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  

- 空の <xref:System.Reflection.MethodInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。

次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
- 単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  

<xref:System.Type.GetMembers%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメンバーを返しません。 コードは、メンバーが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  

 このメソッドオーバーロードを使用してクラス初期化子 (静的コンストラクター) を取得するに&#124;は、<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> で Visual Basic) を指定する必要があります。 <xref:System.Type.TypeInitializer%2A> プロパティを使用してクラス初期化子を取得することもできます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MemberInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメンバーを検索します。または、クラスの制約がない場合は <xref:System.Object> のメンバーを検索します。  

## Examples  
 次のコード例は、<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> メソッドオーバーロードを使用して、指定したクラスのすべてのパブリックインスタンスメンバーに関する情報を収集する方法を示しています。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のメソッドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック メソッドを検索します。</summary>
        <returns>指定した名前のパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックの静的およびパブリックインスタンスメソッドが含まれています。  
  
 メソッドがオーバーロードされ、複数のパブリックメソッドがある場合、<xref:System.Type.GetMethod%28System.String%29> メソッドは <xref:System.Reflection.AmbiguousMatchException> 例外をスローします。 次の例では、<xref:System.Int32.ToString%2A?displayProperty=nameWithType> メソッドのパブリックオーバーロードが複数存在するため、例外がスローされます。  一方、`Person.ToString` メソッドは <xref:System.Object.ToString%2A?displayProperty=nameWithType> をオーバーライドするため、オーバーロードされないため、<xref:System.Type.GetMethod%28System.String%29> メソッドは <xref:System.Reflection.MethodInfo> オブジェクトを取得できます。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 次のいずれかを実行して、特定のメソッドを取得できます。  
  
-   <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> メソッドを呼び出し、メソッドを一意に識別する `bindingAttr` 引数を指定します。 たとえば、型に静的およびインスタンスオーバーロードがあるために例外がスローされた場合は、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>の `bindingAttr` 引数を指定できます。  
  
-   メソッドのパラメーターの型を定義する `types` パラメーターを含む <xref:System.Type.GetMethod%2A> メソッドのオーバーロードを呼び出します。  
  
-   <xref:System.Type.GetMethods> メソッドを呼び出して、型に属するすべてのパブリックメソッドを含む配列を取得します。 その後、それを反復処理して、`name`という名前の重複するメソッドを識別できます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。  
  
   
  
## Examples  
 次の例では、`MethodA`という名前のメソッドを取得します。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のメソッドが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。  
  
-   戻り値を取得するには、<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> または <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> のいずれかを指定する必要があります。  
  
-   検索にパブリックメソッドを含めるには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> を指定します。  
  
-   検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> を指定します。  
  
-   <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> `name`の場合は無視します。  
  
-   単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 メソッドがオーバーロードされ、複数のオーバーロードが `bindingAttr` 引数で指定された制約を満たしている場合、メソッドは <xref:System.Reflection.AmbiguousMatchException> 例外をスローします。 次の例では、例外がスローされます。  
  
-   `TestClass` 型には、`DisplayValue` メソッド、`DisplayValue(String)`、および `DisplayValue(String, Object[])`の2つのパブリックインスタンスオーバーロードがあります。  
  
-   `TestClass` 型には、`Equals` メソッドの2つのパブリックインスタンスオーバーロードがあります。1つは <xref:System.Object>: `Equals(TestClass)` および `Equals(Object)`から継承されます。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 次のいずれかを実行して、特定のメソッドを取得できます。  
  
-   バインド制約を変更します。 前の例では、型によって宣言され、継承されていないメソッド `Equals` パブリックインスタンスを取得しようとすると、`Equals(TestClass)`が正常に取得されます。  
  
-   メソッドのパラメーターの型を定義する `types` パラメーターを含む <xref:System.Type.GetMethod%2A> メソッドのオーバーロードを呼び出します。  
  
-   <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> メソッドを呼び出して、指定したバインディング属性を持つ型に属するすべてのメソッドを含む配列を取得します。 その後、それを反復処理して、`name`という名前の重複するメソッドを識別できます。 この方法は、前の例の <xref:System.Reflection.AmbiguousMatchException> 例外のハンドラーに示されています。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。  
  
   
  
## Examples  
 次の例では、指定したバインディングフラグと一致するメソッドを取得します。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されたパブリック メソッドが存在する場合は、そのパブリック メソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックの静的およびパブリックインスタンスメソッドが含まれています。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。  
  
> [!NOTE]
>  `name` パラメーターに型引数を含めることはできません。 たとえば、コード `GetMethod("MyGenericMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyGenericMethod` という名前のメソッドではなく、テキスト名が "`MyGenericMethod<int>`" のメソッドを検索します。 代わりに、`types` 配列内の適切なパラメーターを指定して `GetMethod("MyGenericMethod")` を使用します。  
  
   
  
## Examples  
 次の例では、さまざまな引数の型を指定して、`MethodA`の特定のオーバーロードを検索します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] の例では、`/unsafe` コンパイラオプションが必要です。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 次の例では、非ジェネリック型 (<xref:System.Collections.ArrayList> クラス) の `Add` メソッド、オープンジェネリック型 (<xref:System.Collections.Generic.List%601> クラス)、およびクローズジェネリック型 (`List(Of String)` 型) を表す <xref:System.Reflection.MethodInfo> オブジェクトを取得します。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 この例では、適切な <xref:System.Reflection.MethodInfo> オブジェクトを取得する `GetAddMethod` メソッドを定義します。 オープンジェネリック型の `types` 引数を指定するには、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> メソッドを呼び出します。 クローズジェネリック型の `types` 引数を指定するために、<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> プロパティの値を取得します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="genericParameterCount">メソッドのジェネリック型パラメーターの数。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。

- または -

パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <summary>指定したジェネリック パラメーターの数と引数の型に一致するパラメーターを持つ、指定したパブリック メソッドを検索します。</summary>
        <returns>指定したジェネリック パラメーターの数と引数の型に一致するパラメーターを持つパブリック メソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。

- または -

<paramref name="types" /> は <see langword="null" />です。

- または -

<paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> が負の値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したパブリック メソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックの静的およびパブリックインスタンスメソッドが含まれています。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMethod("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。 代わりに、`types` 配列内の適切なパラメーターを指定して `GetMethod("MyMethod")` を使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前および指定されたパラメーターを持つメソッドが複数見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="genericParameterCount">メソッドのジェネリック型パラメーターの数。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。

- または -

パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したジェネリック パラメーターの数、引数の型、および修飾子に一致するパラメーターを持つ、指定したパブリック メソッドを検索します。</summary>
        <returns>指定したジェネリック パラメーターの数、引数の型、および修飾子に一致するパブリック メソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。

- または -

<paramref name="types" /> は <see langword="null" />です。

- または -

<paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> が負の値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。  
  
   
  
## Examples  
 次の例では、バインディング制約とさまざまな引数型を指定して、`MethodA`の特定のオーバーロードを検索します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] の例では、`/unsafe` コンパイラオプションが必要です。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="genericParameterCount">メソッドのジェネリック型パラメーターの数。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。

- または -

<see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。

- または -

<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。

- または -

パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定したメソッドのうち、指定したジェネリック パラメーターの数、引数の型、および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定したジェネリック パラメーターの数、引数の型、修飾子、およびバインディングの制約に一致するメソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。

- または -

<paramref name="types" /> は <see langword="null" />です。

- または -

<paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> が負の値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規約を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 次の表は、型に対してリフレクションを行うときに、`GetXXX` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.MethodInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。  
  
> [!NOTE]
>  ジェネリックメソッドの場合は、`name`に型引数を含めないでください。 たとえば、コード `GetMember("MyMethod<int>")` C#は、`int`型のジェネリック引数を1つ持つ `MyMethod` という名前のメソッドではなく、テキスト名 "`MyMethod<int>`" を持つメンバーを検索します。  
  
   
  
## Examples  
 次の例では、バインディング制約、呼び出し規約、およびさまざまな引数型を指定して、`MethodA`の特定のオーバーロードを検索します。  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] の例では、`/unsafe` コンパイラオプションが必要です。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック メソッドの名前を格納している文字列。</param>
        <param name="genericParameterCount">メソッドのジェネリック型パラメーターの数。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。

- または -

<see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。

- または -

<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックのクリーンアップの方法に関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。

- または -

パラメーターをとらないメソッドを取得するための <see cref="T:System.Type" /> オブジェクトの空の配列 (<see cref="F:System.Type.EmptyTypes" /> フィールドで指定)。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 COM 相互運用機能によって呼び出された場合のみ使用され、参照によって渡されたパラメーターのみが処理されます。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約および指定した呼び出し規約を使用して、指定したメソッドのうち、指定したジェネリック パラメーターの数、引数の型、および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定したジェネリック パラメーターの数、引数の型、修飾子、バインディングの制約、および呼び出し規約に一致するメソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。

- または -

<paramref name="types" /> は <see langword="null" />です。

- または -

<paramref name="types" /> 配列の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> が負の値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
パラメーターをとらないメソッドを取得するための、 <see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。  
  
- または - 
 <see langword="null" />。 <paramref name="types" /> が<see langword="null" /> の場合、引数は一致していません。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するメソッドが存在する場合は、そのメソッドを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 `types` が`null` の場合、引数は一致していません。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち、指定されたバインド制約に一致する 2 つ以上のメソッドが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。  
  
- または - 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" /> または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するメソッドの名前を格納している文字列。</param>
        <param name="genericParameterCount">メソッドのジェネリック型パラメーターの数。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。

- または -

<see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。

- または -

<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="callConvention">引数の順序とレイアウト、戻り値を渡す方法、引数を格納するレジスタ、スタックをクリーンアップするプロセスに関する一連の規則を指定するオブジェクト。</param>
        <param name="types">取得するメソッドのパラメーターの数、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。

- または -

パラメーターをとらないメソッドを取得するための、 <see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。

- または -

<see langword="null" />。 <paramref name="types" /> が<see langword="null" /> の場合、引数は一致していません。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約および指定した呼び出し規則を使用して、指定したメソッドのうち、指定したジェネリック パラメーターの数、引数の型、修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定したジェネリック パラメーターの数、引数の型、修飾子、バインディングの制約、および呼び出し規約に一致するメソッドが存在する場合は、それを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">メソッドはオーバーライドし、派生クラスで呼び出す必要があります。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のメソッドを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック メソッドを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.MethodInfo" /> に対して定義されているすべてのパブリック メソッドを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.MethodInfo" /> に対してパブリック メソッドが定義されていない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Type.GetMethods%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメソッドを返しません。 コードは、メソッドが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 コンストラクターは、この呼び出しによって返されるメソッドの配列には含まれません。 `GetConstructors()` を個別に呼び出して、コンストラクターメソッドを取得します。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
> [!NOTE]
>  コンストラクターとメソッドを参照するときにパラメーターを省略することはできません。 パラメーターを省略できるのは、の呼び出し時だけです。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MethodInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。

- または -

 空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> に対して定義されているメソッドを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> に対して定義されているメソッドのうち、指定したバインディング制約に一致するすべてのメソッドを表す <see cref="T:System.Reflection.MethodInfo" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Type" /> に対してメソッドが定義されていないか、または定義されているメソッドの中にバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Reflection.MethodInfo" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`GetMethods(BindingFlags)` オーバーロードでメソッド情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>を含める必要があります。また、少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。 
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメソッドを定義できます。  
  
- インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。 

- 静的メソッドを含めるには `BindingFlags.Static` を指定します。 
  
- 検索にパブリックメソッドを含めるには、`BindingFlags.Public` を指定します。  
  
- 検索に非パブリックメソッド (プライベート、内部、および保護されたメソッド) を含めるには `BindingFlags.NonPublic` を指定します。 基底クラスのプロテクトメソッドと内部メソッドのみが返されます。基底クラスのプライベートメソッドは返されません。  
  
- `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  

- 空の <xref:System.Reflection.MethodInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
- 単純に継承されたメソッドではなく、<xref:System.Type>で宣言されたメソッドのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  

<xref:System.Type.GetMethods%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でメソッドを返しません。 コードは、メソッドが返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  

現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.MethodInfo> オブジェクトを返します。  
  
現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のメソッド、またはクラスの制約がない場合は <xref:System.Object> のメソッドを検索します。 
  
## Examples  
 次の例では、2つのパブリックメソッドと1つのプロテクトメソッドを持つクラスを作成し、`MyTypeClass`に対応する `Type` オブジェクトを作成し、すべてのパブリックメソッドと非パブリックメソッドを取得し、それらの名前を表示します。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっている特定の型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <summary>指定した名前を持ち、入れ子にされたパブリックな型を検索します。</summary>
        <returns>存在する場合は、指定された名前を持つ入れ子にされたパブリックな型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` の検索では大文字と小文字が区別されます。  
  
 `name`には、入れ子になったクラスの簡易名を使用します。 外側のクラスの名前で修飾しないでください。 入れ子になったジェネリッククラスの場合は、破損した名前を使用します。つまり、アクサングラーブと汎用引数の数を追加します。 たとえば、"Inner\`1" という文字列を使用して、入れ子になったジェネリッククラス `Inner<T>` (Visual Basic では`Inner(Of T)`) を取得します。 型パラメーターには言語固有の構文を含めないでください。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。  
  
> [!NOTE]
>  現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。 これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。  
  
 入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得対象の入れ子にされた型の名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、指定されている入れ子にされた型を検索します。</summary>
        <returns>指定した要件と一致し、入れ子にされた型が存在する場合は、その型を表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name`には、入れ子になったクラスの簡易名を使用します。 外側のクラスの名前で修飾しないでください。 入れ子になったジェネリッククラスの場合は、破損した名前を使用します。つまり、アクサンアクセントとジェネリックパラメーターの数を追加します。 たとえば、"Inner\`1" という文字列を使用して、入れ子になったジェネリッククラス `Inner<T>` (Visual Basic では`Inner(Of T)`) を取得します。 型パラメーターには言語固有の構文を含めないでください。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含める入れ子にされた型を定義できます。  
  
-   戻り値を取得するには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> または <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> のいずれかを指定する必要があります。  
  
-   検索に入れ子になったパブリック型を含めるには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> を指定します。  
  
-   検索で非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている) を含めるには、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> を指定します。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基底クラスは検索されません。 基底クラスで入れ子になっている型を見つけるには、継承階層を調べて、各レベルで <xref:System.Type.GetNestedType%2A> を呼び出す必要があります。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> は無視されます。  
  
 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> フラグまたは <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> フラグだけを指定してこのメソッドを呼び出すと、指定した入れ子にされた型が返され、他のフラグは必要ありません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。  
  
> [!NOTE]
>  現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。 これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。  
  
 入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> 内で入れ子になっているすべてのパブリック型を返します。</summary>
        <returns>現在の <see cref="T:System.Type" /> 内で入れ子になっているパブリック型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、現在の <see cref="T:System.Type" /> で入れ子になっているパブリック型がない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序で型を返しません。 コードは、型が返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 現在の型ですぐに入れ子になっているパブリック型のみが返されます。検索は再帰的ではありません。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。  
  
> [!NOTE]
>  現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。 これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。  
  
 入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。  
  
   
  
## Examples  
 次の例では、入れ子になったクラスと `MyClass`の `struct` を定義し、`MyClass`の型を使用して、入れ子にされた型のオブジェクトを取得します。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> 内で入れ子になっている型を検索します。</summary>
        <returns>指定したバインディング制約と一致する現在の <see cref="T:System.Type" /> で入れ子にされたすべての型を表す <see cref="T:System.Type" /> オブジェクトの配列 (検索は非再帰的)。または、バインディング制約と一致する入れ子にされた型が見つからない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子になった型の検索は再帰的ではありません。  
  
 <xref:System.Type.GetNestedTypes%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序で型を返しません。 コードは、型が返される順序に依存しないようにする必要があります。これは、その順序が異なるためです。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含める入れ子にされた型を定義できます。  
  
-   戻り値を取得するには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> または <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> のいずれかを指定する必要があります。  
  
-   検索に入れ子になったパブリック型を含めるには、<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> を指定します。  
  
-   検索で非パブリックの入れ子にされた型 (つまり、プライベート、内部、および保護されている) を含めるには、<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> を指定します。  
  
 このメソッドは、現在の型の入れ子にされた型のみを返します。 現在の型の基底クラスは検索されません。 基底クラスで入れ子になっている型を見つけるには、継承階層を調べて、各レベルで <xref:System.Type.GetNestedTypes%2A> を呼び出す必要があります。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> は無視されます。  
  
 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> フラグまたは <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> フラグだけを指定してこのメソッドを呼び出すと、指定した入れ子にされた型が返され、他のフラグは必要ありません。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは、クラスの制約の入れ子にされた型を検索します。  
  
 入れ子にされた型がジェネリックの場合、このメソッドはそのジェネリック型定義を返します。 これは、外側のジェネリック型が構築されたクローズ型である場合にも当てはまります。  
  
> [!NOTE]
>  現在の <xref:System.Type> が、、Visual Basic、またはC# C++で定義されたジェネリック型を表している場合、その入れ子になった型は、独自のジェネリックパラメーターがない場合でも、すべてジェネリックになります。 これは、動的アセンブリで定義されている入れ子になった型や、 [Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)でコンパイルされた型には必ずしも当てはまりません。  
  
 入れ子になったジェネリック型の詳細、およびジェネリック型定義から入れ子になったジェネリック型を構築する方法については、「<xref:System.Type.MakeGenericType%2A>」を参照してください。  
  
   
  
## Examples  
 次の例では、2つの入れ子になったパブリッククラスと2つの入れ子になったプロテクトクラスを作成し、指定されたバインディング制約に一致するクラスの情報を表示します。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のプロパティを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のすべてのパブリック プロパティを返します。</summary>
        <returns>現在の <see cref="T:System.Reflection.PropertyInfo" /> のすべてのパブリック プロパティを表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.PropertyInfo" /> にパブリック プロパティが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードの呼び出しは、Visual Basic 内の `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` C#と等しい `bindingAttr` 引数を使用して <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> オーバーロードを呼び出すことと同じです。 このメソッドは、すべてのパブリックインスタンスと静的プロパティを返します。このプロパティは、現在の <xref:System.Type> オブジェクトによって表される型と、基本型から継承されたプロパティの両方で定義されます。  
  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 <xref:System.Type.GetProperties%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でプロパティを返しません。 コードは、プロパティが返される順序に依存しないようにする必要があります。これは、順序が異なるためです。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.PropertyInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
   
  
## Examples  
 `GetProperties` メソッドの使用例を次に示します。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。

- または -

 空の配列を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の <see cref="T:System.Type" /> のプロパティを検索します。</summary>
        <returns>現在の <see cref="T:System.Type" /> のプロパティのうち、指定したバインディング制約に一致するすべてのプロパティを表すオブジェクトの配列。  
  
- または - 
現在の <see cref="T:System.Reflection.PropertyInfo" /> にプロパティが設定されていないか、またはプロパティの中でバインディング制約に一致するものが存在しない場合は、<see cref="T:System.Type" /> 型の空の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`GetProperties(BindingFlags)` オーバーロードでプロパティ情報を正常に取得するには、`bindingAttr` 引数に少なくとも1つの <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、および少なくとも1つの <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> と <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>を含める必要があります。 

次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。  
  
- インスタンスメソッドを含めるには `BindingFlags.Instance` を指定します。 

- 静的メソッドを含めるには `BindingFlags.Static` を指定します。 
  
- 検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 
  
- 検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。 基底クラスの protected プロパティと internal プロパティのみが返されます。基底クラスのプライベートプロパティは返されません。  
  
- `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  

- 空の <xref:System.Reflection.PropertyInfo> 配列を返すには、`BindingFlags.Default` だけを指定します。

 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
- 単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
<xref:System.Type.GetProperties%2A> メソッドは、アルファベットまたは宣言の順序など、特定の順序でプロパティを返しません。 コードは、プロパティが返される順序に依存しないようにする必要があります。これは、順序が異なるためです。  

 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを持つ <xref:System.Reflection.PropertyInfo> オブジェクトを返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
   
  
## Examples  
 次の例では、6つのプロパティを含む `PropertyClass` という名前のクラスを定義しています。2つはパブリック、1つはプライベート、1つは保護、1つは内部 (Visual Basic では`Friend`)、もう1つは内部 (Visual Basic では`Protected Friend`) です。 次に、いくつかの基本的なプロパティ情報 (プロパティの名前と型、読み取り/書き込み可能かどうか、および指定されたバインディング制約に一致するプロパティの `get` と `set` のアクセサーの可視性) が表示されます。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のプロパティを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <summary>指定した名前のパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。  
  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
 <xref:System.Reflection.AmbiguousMatchException> が発生する状況には、次のようなものがあります。  
  
-   型には、同じ名前でパラメーターの数が異なる2つのインデックス付きプロパティが含まれています。 あいまいさを解決するには、パラメーターの型を指定する <xref:System.Type.GetProperty%2A> メソッドのオーバーロードを使用します。  
  
-   派生型は、`new` 修飾子 (Visual Basic で`Shadows`) を使用して、同じ名前の継承されたプロパティを非表示にするプロパティを宣言します。 あいまいさを解決するには、<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> メソッドオーバーロードを使用し、<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> フラグを追加して、継承されていないメンバーに検索を制限します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。 たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。 プロパティをオーバーロードすることができます。  
  
 でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。 既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。 たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。 以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。  
  
 型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。 型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、ユーザー定義クラスの `Type` オブジェクトを取得し、そのクラスのプロパティを取得して、プロパティ名を表示します。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 内部的には、このプロパティは "Item" という名前でメタデータで参照されます。 リフレクションを使用して `PropertyInfo` を取得しようとすると、`PropertyInfo` プロパティを正しく返すために、この内部名を指定する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
<see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <summary>指定されたバインディング制約を使用して、指定されたプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
 <xref:System.Reflection.AmbiguousMatchException> が発生する状況には、次のようなものがあります。  
  
-   型には、同じ名前でパラメーターの数が異なる2つのインデックス付きプロパティが含まれています。 あいまいさを解決するには、パラメーターの型を指定する <xref:System.Type.GetProperty%2A> メソッドのオーバーロードを使用します。  
  
-   派生型は、`new` 修飾子 (Visual Basic で`Shadows`) を使用して、同じ名前の継承されたプロパティを非表示にするプロパティを宣言します。 あいまいさを解決するには、<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> を含めて、継承されていないメンバーだけに検索を制限します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。 たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。 プロパティをオーバーロードすることができます。  
  
 でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。 既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。 たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。 以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。  
  
 型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。 型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、ユーザー定義クラスの型を取得し、そのクラスのプロパティを取得して、指定されたバインディング制約に従ってプロパティ名を表示します。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 1 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <summary>指定した名前および戻り値の型を持つパブリック プロパティを検索します。</summary>
        <returns>指定した名前のパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。 たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。 プロパティをオーバーロードすることができます。  
  
 でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。 既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。 たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。 以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。  
  
 型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。 型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、1つのプロパティを持つクラスを定義し、プロパティの名前と型を取得します。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前のプロパティが複数個見つかりました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> であるか、または <paramref name="returnType" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。 たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。 プロパティをオーバーロードすることができます。  
  
 でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。 既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。 たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。 以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。  
  
 型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。 型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、ユーザー定義クラスの `Type` オブジェクトを取得し、そのクラスのプロパティを取得して、`GetProperty`に渡される引数で指定されたプロパティの名前と型を表示します。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数型と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した引数型と一致するパラメーターが設定されているパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。 たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。 プロパティをオーバーロードすることができます。  
  
 でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。 既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。 たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。 以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。  
  
 型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。 型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定した名前を持ち引数の型が一致する複数のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するパブリック プロパティの名前を格納している文字列。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したパブリック プロパティのうち、指定した引数の型および修飾子と一致するパラメーターが設定されているものを検索します。</summary>
        <returns>指定した要件と一致するパブリック プロパティが存在する場合は、そのパブリック プロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 `name` の検索では大文字と小文字が区別されます。 検索には、パブリックな静的およびパブリックインスタンスのプロパティが含まれます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。 たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。 プロパティをオーバーロードすることができます。  
  
 でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。 既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。 たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。 以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。  
  
 型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。 型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。  
  
   
  
## Examples  
 次の例では、`MyPropertyClass`に対応する `Type` オブジェクトを取得し、`GetProperty` メソッドに渡された引数を使用して、このクラスのインデックス付きプロパティを取得します。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定された引数の型および修飾子に一致する 2 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。  
  
- または - 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>指定したバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定された指定のプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パブリックであるアクセサーが少なくとも1つある場合、プロパティはリフレクションに対してパブリックと見なされます。 それ以外の場合、プロパティはプライベートと見なされ、 &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (Visual Basic では、`Or`を使用して値を結合する) を使用して取得する必要があります。  
  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このメソッドは、適切な型引数によって置き換えられた型パラメーターを使用して <xref:System.Reflection.PropertyInfo> を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドはクラスの制約のプロパティを検索します。  
  
## <a name="indexers-and-default-properties"></a>インデクサーと既定のプロパティ  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]、および [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] には、インデックス付きプロパティにアクセスするための簡略化された構文があり、1つのインデックス付きプロパティをその型の既定値にすることができます。 たとえば、変数 `myList` が <xref:System.Collections.ArrayList>を参照している場合、構文 `myList[3]` (Visual Basic 内の`myList(3)`) は、インデックス3を持つ要素を取得します。 プロパティをオーバーロードすることができます。  
  
 でC#は、この機能はインデクサーと呼ばれ、名前で参照することはできません。 既定では、 C#インデクサーは "Item" という名前のインデックス付きプロパティとしてメタデータに表示されます。 ただし、クラスライブラリの開発者は、<xref:System.Runtime.CompilerServices.IndexerNameAttribute> 属性を使用して、メタデータ内のインデクサーの名前を変更できます。 たとえば、<xref:System.String> クラスには、<xref:System.String.Chars%2A>という名前のインデクサーがあります。 以外C#の言語を使用して作成されたインデックス付きプロパティには、Item 以外の名前を付けることもできます。  
  
 型に既定のプロパティがあるかどうかを確認するには、<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> メソッドを使用して、<xref:System.Reflection.DefaultMemberAttribute> 属性をテストします。 型が <xref:System.Reflection.DefaultMemberAttribute>の場合、<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> プロパティは既定のプロパティの名前を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 1 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。  
  
- または - 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> の要素は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するプロパティの名前を格納している文字列。</param>
        <param name="bindingAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。  
  
- または - 
 <see langword="null" /> を返す場合は <see cref="F:System.Reflection.BindingFlags.Default" />。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメンバーの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。</param>
        <param name="returnType">プロパティの戻り値の型。</param>
        <param name="types">取得するインデックス付きプロパティに対するパラメーターの数値、順序、および型を表す <see cref="T:System.Type" /> オブジェクトの配列。  
  
- または - 
インデックス付けされていないプロパティを取得するための、<see cref="T:System.Type" /> 型の空の配列 (Type[] types = new Type[0])。</param>
        <param name="modifiers"><paramref name="types" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 既定のバインダーでは、このパラメーターは処理されません。</param>
        <summary>派生クラスによってオーバーライドされるときに、指定のバインディング制約を使用して、指定した引数の型および修飾子と一致するパラメーターが設定されたプロパティを検索します。</summary>
        <returns>指定した要件と一致するプロパティが存在する場合は、そのプロパティを表すオブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Reflection.ParameterModifier> (`modifiers` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるプロパティを定義できます。  
  
-   戻り値を取得するには、`BindingFlags.Instance` または `BindingFlags.Static` のいずれかを指定する必要があります。  
  
-   検索にパブリックプロパティを含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックプロパティ (つまり、プライベート、内部、および保護されたプロパティ) を含めるには、`BindingFlags.NonPublic` を指定します。  
  
-   `BindingFlags.FlattenHierarchy` を指定して、`public` と `protected` の静的メンバーを階層の上位に追加します。継承されたクラスの `private` 静的メンバーは含まれません。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたプロパティではなく、<xref:System.Type>で宣言されたプロパティのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">指定された名前を持ち、指定されたバインディング制約に一致する 1 つ以上のプロパティが存在します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="types" /> は <see langword="null" />です。  
  
- または - 
<paramref name="types" /> の要素の 1 つが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> が多次元です。  
  
- または - 
 <paramref name="modifiers" /> が多次元です。  
  
- または - 
 <paramref name="types" /> と <paramref name="modifiers" /> の長さが同じではありません。</exception>
        <exception cref="T:System.NotSupportedException">現在の型は <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" />、または <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> です。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された型を表す <see cref="T:System.Type" /> オブジェクトを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>現在の <see cref="T:System.Type" /> です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 以下を参照してください。<see cref="P:System.Type.AssemblyQualifiedName" /> 型が現在実行されているアセンブリ内または Mscorlib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</param>
        <summary>大文字と小文字を区別する検索を実行して、指定した名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリ修飾名がわかっている場合は、<xref:System.Type.GetType%2A> メソッドを使用して、別のアセンブリ内の型の <xref:System.Type> オブジェクトを取得できます。これは <xref:System.Type.AssemblyQualifiedName>から取得できます。 <xref:System.Type.GetType%2A> により、`typeName`で指定されたアセンブリの読み込みが発生します。 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> メソッドを使用して <xref:System.Type> オブジェクトを取得することもできます。 コンパイル時にプログラムによって認識されるアセンブリに型が含まれている場合は、のC# `typeof`、または Visual Basic の `GetType` 演算子を使用する方が効率的です。
  
> [!NOTE]
>  `typeName` が見つからない場合、<xref:System.Type.GetType%28System.String%29> メソッドを呼び出すと `null`が返されます。 例外はスローされません。 例外がスローされるかどうかを制御するには、`throwOnError` パラメーターを持つ <xref:System.Type.GetType%2A> メソッドのオーバーロードを呼び出します。  
  
 <xref:System.Type.GetType%2A> は、ディスクから読み込まれたアセンブリに対してのみ機能します。 <xref:System.Reflection.Emit> サービスを使用して定義された動的アセンブリで定義されている型を検索するために <xref:System.Type.GetType%2A> を呼び出すと、一貫性のない動作が発生する可能性があります。 動作は、動的アセンブリが永続的であるかどうか、つまり、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 列挙体の `RunAndSave` アクセスモードまたは `Save` アクセスモードを使用して作成されたものかどうかによって異なります。 動的アセンブリが永続的で、`GetType` が呼び出される前にディスクに書き込まれた場合、ローダーはディスク上に保存されているアセンブリを検索し、そのアセンブリを読み込み、そのアセンブリから型を取得します。 `GetType` が呼び出されたときにアセンブリがディスクに保存されていない場合、メソッドは `null`を返します。 `GetType` は、一時的な動的アセンブリを認識しません。したがって、一時動的アセンブリの型を取得するために `GetType` を呼び出すと、`null`が返されます。  
  
 動的モジュールで `GetType` を使用するには、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントをサブスクライブして、保存する前に `GetType` を呼び出します。 それ以外の場合は、メモリ内のアセンブリのコピーが2つ取得されます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は、使用可能なクラスのテーブルに既に読み込まれていない限り、検索されません。  
  
 `typeName` には、名前空間で修飾された型名か、アセンブリ名の指定を含むアセンブリ修飾名を指定できます。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 名前空間が含まれて `typeName` いるがアセンブリ名を含まない場合、このメソッドは、呼び出し元のオブジェクトのアセンブリと Mscorlib.dll だけをこの順序で検索します。 TypeName が部分的または完全なアセンブリ名で完全修飾されている場合、このメソッドは指定されたアセンブリを検索します。 アセンブリに厳密な名前が付いている場合は、完全なアセンブリ名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A> プロパティは、入れ子にされた型、アセンブリ名、およびジェネリック型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。  
  
> [!NOTE]
>  .NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。 たとえば、"ProcessorArchitecture = msil" のようになります。 ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。 <xref:System.Reflection.AssemblyName> オブジェクトを作成し、それを <xref:System.Reflection.Assembly.Load%2A> メソッドの適切なオーバーロードに渡すことによって、型を読み込むこともできます。 その後、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを使用して、アセンブリから型を読み込むことができます。 「 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|Delimiter|意味|  
|---------------|-------------|  
|円記号 (\\)|エスケープ文字。|  
|バックティック (')|ジェネリック型の名前の末尾にある型パラメーターの数を表す1桁以上の数字に先行します。|  
|角かっこ ([])|構築されたジェネリック型のジェネリック型引数リストを囲みます。型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前に指定します。|  
|ピリオド (.)|名前空間識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスの前に置きます。|  
  
 たとえば、クラスの完全修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 名前空間が TopNamespace. Sub + 名前空間の場合、文字列は、入れ子の区切り記号として解釈されないように、正符号 (+) の前にエスケープ文字 (\\) を付ける必要があります。 リフレクションは、この文字列を次のように出力します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。  
  
 この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。 <xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。 型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。 アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。  
  
 型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。 末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、バックティック (\`) で終わり、その後にジェネリック型引数の数を表す数字が続きます。 この名前の変形の目的は、同じスコープで発生する、同じ名前で型パラメーターの数が異なるジェネリック型をコンパイラがサポートできるようにすることです。 たとえば、リフレクションは、`Tuple(Of T0, T1)` 内のジェネリックメソッド `Tuple(Of T)` および Visual Basic、またはビジュアルC#内の `Tuple<T>` と組`\<T0, T1>` で、`Tuple`1` and `タプル`2` から破損した名前を返します。  
  
 ジェネリック型の場合、型引数リストは角かっこで囲まれ、型引数はコンマで区切られます。 たとえば、ジェネリック <xref:System.Collections.Generic.Dictionary%602> には、2つの型パラメーターがあります。 <xref:System.String> 型のキーを持つ `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように表されます。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内でアセンブリ修飾型を指定するには、アセンブリ修飾型を角かっこで囲みます。 それ以外の場合、アセンブリ修飾名の一部を区切るコンマは、追加の型引数の区切りとして解釈されます。 たとえば、`MyType` の <xref:System.Collections.Generic.Dictionary%602> を <xref:System.String>型のキーと共に次のように指定することができます。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾型は、型パラメーターリスト内に出現する場合にのみ、角かっこで囲むことができます。 型パラメーターリスト内の修飾型および非修飾型のアセンブリを検索するための規則は、修飾された非修飾の非ジェネリック型の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 値が許容される <xref:System.Int32> は、"System. Nullable ' 1 [system.string]" という文字列で表されます。  
  
> [!NOTE]
>  、 C# C++、Visual Basic では、型演算子を使用して null 許容型を取得することもできます。 たとえば、null 値が許容される <xref:System.Boolean> 型は、 C#の `typeof(Nullable<bool>)` によっC++て返されます。また、の `Nullable<Boolean>::typeid`、および Visual Basic の `GetType(Nullable(Of Boolean))` によって返されます。  
  
 次の表は、さまざまな型の `GetType` で使用する構文を示しています。  
  
|取得するには|用途|  
|------------|---------|  
|Null 許容の <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|`MyType` するアンマネージポインター。|`Type.GetType("MyType*")`|  
|へのポインターへのアンマネージポインター `MyType`|`Type.GetType("MyType**")`|  
|`MyType` へのマネージポインターまたは参照|`Type.GetType("MyType&")` で初期化します。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限が0の1次元配列。|`Type.GetType("MyType[]")`|  
|不明な下限を持つ1次元配列。|`Type.GetType("MyType[*]")`|  
|N 次元配列|角かっこ内のコンマ (,) は、合計 n-1 回です。 たとえば、`System.Object[,,]` は3次元の `Object` 配列を表します。|  
|1次元配列の配列。|`Type.GetType("MyType[][]")`|  
|下限が不明な四角形の2次元配列|`Type.GetType("MyType[,]")`|  
|1つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`1[MyType]")``|  
|2つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|2つのアセンブリ修飾型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|アセンブリ修飾型引数を持つアセンブリ修飾ジェネリック型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|型引数が2つの型引数を持つジェネリック型であるジェネリック型。|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 次の例では、`System.Int32` の型を取得し、その型オブジェクトを使用して `System.Int32`の <xref:System.Type.FullName%2A> プロパティを表示します。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が、型引数の 1 つとしてポインター型、<see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
- または - 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
- または - 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 - または -  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 以下を参照してください。<see cref="P:System.Type.AssemblyQualifiedName" /> 型が現在実行されているアセンブリ内または Mscorlib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は<see langword="true" /> 。 <see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリ修飾名がわかっている場合は、<xref:System.Type.GetType%2A> メソッドを使用して、別のアセンブリ内の型の <xref:System.Type> オブジェクトを取得できます。これは <xref:System.Type.AssemblyQualifiedName>から取得できます。 <xref:System.Type.GetType%2A> により、`typeName`で指定されたアセンブリの読み込みが発生します。 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> メソッドを使用して <xref:System.Type> オブジェクトを取得することもできます。 コンパイル時にプログラムによって認識されるアセンブリに型が含まれている場合は、のC# `typeof`、または Visual Basic の `GetType` 演算子を使用する方が効率的です。
  
 `GetType` は、ディスクから読み込まれたアセンブリに対してのみ機能します。 <xref:System.Reflection.Emit> サービスを使用して定義された動的アセンブリで定義されている型を検索するために `GetType` を呼び出すと、一貫性のない動作が発生する可能性があります。 動作は、動的アセンブリが永続的であるかどうか、つまり、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 列挙体の `RunAndSave` アクセスモードまたは `Save` アクセスモードを使用して作成されたものかどうかによって異なります。 動的アセンブリが永続的で、`GetType` が呼び出される前にディスクに書き込まれた場合、ローダーはディスク上に保存されているアセンブリを検索し、そのアセンブリを読み込み、そのアセンブリから型を取得します。 `GetType` が呼び出されたときにアセンブリがディスクに保存されていない場合、メソッドは `null`を返します。 `GetType` は、一時的な動的アセンブリを認識しません。したがって、一時動的アセンブリの型を取得するために `GetType` を呼び出すと、`null`が返されます。  
  
 動的モジュールで `GetType` を使用するには、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントをサブスクライブして、保存する前に `GetType` を呼び出します。 それ以外の場合は、メモリ内のアセンブリのコピーが2つ取得されます。  
  
 `throwOnError` パラメーターは、型が見つからない場合の動作を指定します。また、「例外」セクションで説明されているように、他の特定の例外条件も抑制します。 `throwOnError`の値に関係なく、一部の例外がスローされます。 たとえば、型が見つかっても読み込むことができない場合、`throwOnError` が `false`場合でも、<xref:System.TypeLoadException> がスローされます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は、使用可能なクラスのテーブルに既に読み込まれていない限り、検索されません。  
  
 `typeName` には、名前空間で修飾された型名か、アセンブリ名の指定を含むアセンブリ修飾名を指定できます。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 名前空間が含まれて `typeName` いるがアセンブリ名を含まない場合、このメソッドは、呼び出し元のオブジェクトのアセンブリと Mscorlib.dll だけをこの順序で検索します。 TypeName が部分的または完全なアセンブリ名で完全修飾されている場合、このメソッドは指定されたアセンブリを検索します。 アセンブリに厳密な名前が付いている場合は、完全なアセンブリ名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A> プロパティは、入れ子にされた型、アセンブリ名、およびジェネリック引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。  
  
> [!NOTE]
>  .NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。 たとえば、"ProcessorArchitecture = msil" のようになります。 ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。 <xref:System.Reflection.AssemblyName> オブジェクトを作成し、それを <xref:System.Reflection.Assembly.Load%2A> メソッドの適切なオーバーロードに渡すことによって、型を読み込むこともできます。 その後、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを使用して、アセンブリから型を読み込むことができます。 「 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|Delimiter|意味|  
|---------------|-------------|  
|円記号 (\\)|エスケープ文字。|  
|バックティック (')|ジェネリック型の名前の末尾にある型パラメーターの数を表す1桁以上の数字に先行します。|  
|角かっこ ([])|構築されたジェネリック型のジェネリック型引数リストを囲みます。型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前に指定します。|  
|ピリオド (.)|名前空間識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスの前に置きます。|  
  
 たとえば、クラスの完全修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 名前空間が TopNamespace. Sub + 名前空間の場合、文字列は、入れ子の区切り記号として解釈されないように、正符号 (+) の前にエスケープ文字 (\\) を付ける必要があります。 リフレクションは、この文字列を次のように出力します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。  
  
 この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。 <xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。 型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。 アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。  
  
 型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。 末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、バックティック (\`) で終わり、その後にジェネリック型引数の数を表す数字が続きます。 この名前の変形の目的は、同じスコープで発生する、同じ名前で型パラメーターの数が異なるジェネリック型をコンパイラがサポートできるようにすることです。 たとえば、リフレクションは、`Tuple(Of T0, T1)` 内のジェネリックメソッド `Tuple(Of T)` および Visual Basic、またはビジュアルC#内の `Tuple<T>` と組`\<T0, T1>` で、`Tuple`1` and `タプル`2` から破損した名前を返します。  
  
 ジェネリック型の場合、型引数リストは角かっこで囲まれ、型引数はコンマで区切られます。 たとえば、ジェネリック <xref:System.Collections.Generic.Dictionary%602> には、2つの型パラメーターがあります。 <xref:System.String> 型のキーを持つ `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように表されます。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内でアセンブリ修飾型を指定するには、アセンブリ修飾型を角かっこで囲みます。 それ以外の場合、アセンブリ修飾名の一部を区切るコンマは、追加の型引数の区切りとして解釈されます。 たとえば、<xref:System.String>型のキーを使用して、MyAssembly の `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように指定することができます。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾型は、型パラメーターリスト内に出現する場合にのみ、角かっこで囲むことができます。 型パラメーターリスト内の修飾型および非修飾型のアセンブリを検索するための規則は、修飾された非修飾の非ジェネリック型の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 値が許容される <xref:System.Int32> は、"System. Nullable ' 1 [system.string]" という文字列で表されます。  
  
> [!NOTE]
>  、 C# C++、Visual Basic では、型演算子を使用して null 許容型を取得することもできます。 たとえば、null 値が許容される <xref:System.Boolean> 型は、 C#の `typeof(Nullable<bool>)` によっC++て返されます。また、の `Nullable<Boolean>::typeid`、および Visual Basic の `GetType(Nullable(Of Boolean))` によって返されます。  
  
 次の表は、さまざまな型の `GetType` で使用する構文を示しています。  
  
|取得するには|用途|  
|------------|---------|  
|Null 許容の <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|`MyType` するアンマネージポインター。|`Type.GetType("MyType*")`|  
|へのポインターへのアンマネージポインター `MyType`|`Type.GetType("MyType**")`|  
|`MyType` へのマネージポインターまたは参照|`Type.GetType("MyType&")` で初期化します。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限が0の1次元配列。|`Type.GetType("MyArray[]")`|  
|不明な下限を持つ1次元配列。|`Type.GetType("MyArray[*]")`|  
|N 次元配列|角かっこ内のコンマ (,) は、合計 n-1 回です。 たとえば、`System.Object[,,]` は3次元の `Object` 配列を表します。|  
|2次元配列の配列。|`Type.GetType("MyArray[][]")`|  
|下限が不明な四角形の2次元配列|`Type.GetType("MyArray[,]")`|  
|1つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`1[MyType]")``|  
|2つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|2つのアセンブリ修飾型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|アセンブリ修飾型引数を持つアセンブリ修飾ジェネリック型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|型引数が2つの型引数を持つジェネリック型であるジェネリック型。|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 次の例では、`System.Int32` の型を取得し、その型オブジェクトを使用して `System.Int32`の <xref:System.Type.FullName%2A> プロパティを表示します。 型オブジェクトが、存在しないアセンブリを参照している場合、この例では例外がスローされます。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は空の文字列です。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
- または - 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> が <see langword="true" /> で、 <paramref name="typeName" /> に正しくない構文が含まれています。 例: "MyType[,*,]"。  
  
- または - 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、 <see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
- または - 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
- または - 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 - または -  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型のアセンブリ修飾名。 以下を参照してください。<see cref="P:System.Type.AssemblyQualifiedName" /> 型が現在実行されているアセンブリ内または Mscorlib.dll にある場合は、名前空間で修飾された型名を提供するだけで十分です。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は<see langword="true" /> 。 <see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <paramref name="typeName" />。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <paramref name="typeName" />。</param>
        <summary>指定した名前を持つ <see cref="T:System.Type" /> を取得します。型が見つからない場合に例外をスローするかどうかと、大文字と小文字を区別する検索を実行するかどうかも指定します。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリ修飾名がわかっている場合は、<xref:System.Type.GetType%2A> メソッドを使用して、別のアセンブリ内の型の <xref:System.Type> オブジェクトを取得できます。これは <xref:System.Type.AssemblyQualifiedName>から取得できます。 <xref:System.Type.GetType%2A> により、`typeName`で指定されたアセンブリの読み込みが発生します。 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> または <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> メソッドを使用して <xref:System.Type> オブジェクトを取得することもできます。 コンパイル時にプログラムによって認識されるアセンブリに型が含まれている場合は、のC# `typeof`、または Visual Basic の `GetType` 演算子を使用する方が効率的です。
  
 `GetType` は、ディスクから読み込まれたアセンブリに対してのみ機能します。 <xref:System.Reflection.Emit> サービスを使用して定義された動的アセンブリで定義されている型を検索するために `GetType` を呼び出すと、一貫性のない動作が発生する可能性があります。 動作は、動的アセンブリが永続的であるかどうか、つまり、<xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> 列挙体の `RunAndSave` アクセスモードまたは `Save` アクセスモードを使用して作成されたものかどうかによって異なります。 動的アセンブリが永続的で、`GetType` が呼び出される前にディスクに書き込まれた場合、ローダーはディスク上に保存されているアセンブリを検索し、そのアセンブリを読み込み、そのアセンブリから型を取得します。 `GetType` が呼び出されたときにアセンブリがディスクに保存されていない場合、メソッドは `null`を返します。 `GetType` は、一時的な動的アセンブリを認識しません。したがって、一時動的アセンブリの型を取得するために `GetType` を呼び出すと、`null`が返されます。  
  
 動的モジュールで `GetType` を使用するには、<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> イベントをサブスクライブして、保存する前に `GetType` を呼び出します。 それ以外の場合は、メモリ内のアセンブリのコピーが2つ取得されます。  
  
 `throwOnError` パラメーターは、型が見つからない場合の動作を指定します。また、「例外」セクションで説明されているように、他の特定の例外条件も抑制します。 `throwOnError`の値に関係なく、一部の例外がスローされます。 たとえば、型が見つかっても読み込むことができない場合、`throwOnError` が `false`場合でも、<xref:System.TypeLoadException> がスローされます。  
  
 次の表は、型に対してリフレクションを行うときに、`Get` メソッドによって返される基底クラスのメンバーを示しています。  
  
|メンバーの型|静的|非静的|  
|-----------------|------------|-----------------|  
|コンストラクター|いいえ|いいえ|  
|フィールド|いいえ|はい。 フィールドは、常に名前と署名で隠ぺいされます。|  
|イベント|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
|メソッド|いいえ|はい。 メソッド (仮想と非仮想の両方) は、非表示にするか、名前と署名を隠すことができます。|  
|入れ子にされた型|いいえ|いいえ|  
|プロパティ|該当なし|共通型システムの規則は、継承が、プロパティを実装するメソッドと同じであることを示します。 リフレクションは、プロパティを名前で隠す、署名として扱います。 下記のメモ2を参照してください。|  
  
1.  名前による隠ぺいと署名では、カスタム修飾子、戻り値の型、パラメーターの型、sentinel、アンマネージ呼び出し規約を含む、シグネチャのすべての部分が考慮されます。 これは、バイナリ比較です。  
  
2.  リフレクションの場合、プロパティとイベントは、名前とシグネチャが隠ぺいされます。 基底クラスに get と set の両方のアクセサーを持つプロパティがあり、派生クラスに get アクセサーのみがある場合、派生クラスのプロパティは基底クラスのプロパティを非表示にします。基底クラスの setter にアクセスすることはできません。  
  
3.  カスタム属性は、共通型システムの一部ではありません。  
  
 配列または COM 型は、使用可能なクラスのテーブルに既に読み込まれていない限り、検索されません。  
  
 `typeName` には、名前空間で修飾された型名か、アセンブリ名の指定を含むアセンブリ修飾名を指定できます。 「<xref:System.Type.AssemblyQualifiedName%2A>」を参照してください。  
  
 名前空間が含まれて `typeName` いるがアセンブリ名を含まない場合、このメソッドは、呼び出し元のオブジェクトのアセンブリと Mscorlib.dll だけをこの順序で検索します。 TypeName が部分的または完全なアセンブリ名で完全修飾されている場合、このメソッドは指定されたアセンブリを検索します。 アセンブリに厳密な名前が付いている場合は、完全なアセンブリ名が必要です。  
  
 <xref:System.Type.AssemblyQualifiedName%2A> プロパティは、入れ子にされた型、アセンブリ名、および型引数を含む完全修飾型名を返します。 共通言語ランタイムをサポートするすべてのコンパイラは、入れ子になったクラスの簡易名を出力します。リフレクションは、次の規則に従って、クエリを実行すると、破損した名前を生成します。  
  
> [!NOTE]
>  .NET Framework バージョン2.0 では、プロセッサアーキテクチャがアセンブリ id に追加され、アセンブリ名文字列の一部として指定できるようになりました。 たとえば、"ProcessorArchitecture = msil" のようになります。 ただし、互換性上の理由から、<xref:System.Type.AssemblyQualifiedName%2A> プロパティによって返される文字列には含まれません。 <xref:System.Reflection.AssemblyName> オブジェクトを作成し、それを <xref:System.Reflection.Assembly.Load%2A> メソッドの適切なオーバーロードに渡すことによって、型を読み込むこともできます。 その後、<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを使用して、アセンブリから型を読み込むことができます。 「 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」も参照してください。  
  
|Delimiter|意味|  
|---------------|-------------|  
|円記号 (\\)|エスケープ文字。|  
|バックティック (')|ジェネリック型の名前の末尾にある型パラメーターの数を表す1桁以上の数字に先行します。|  
|角かっこ ([])|構築されたジェネリック型のジェネリック型引数リストを囲みます。型引数リスト内で、アセンブリ修飾型を囲みます。|  
|コンマ (,)|アセンブリ名の前に指定します。|  
|ピリオド (.)|名前空間識別子を表します。|  
|プラス記号 (+)|入れ子になったクラスの前に置きます。|  
  
 たとえば、クラスの完全修飾名は次のようになります。  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 名前空間が TopNamespace. Sub + 名前空間の場合、文字列は、入れ子の区切り記号として解釈されないように、正符号 (+) の前にエスケープ文字 (\\) を付ける必要があります。 リフレクションは、この文字列を次のように出力します。  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +" は "\\+\\+" になり、"\\" は "\\\\" になります。  
  
 この修飾名は永続化でき、後で <xref:System.Type>を読み込むために使用できます。 <xref:System.Type>を検索して読み込むには、型名だけを使用するか、アセンブリ修飾型名を指定して <xref:System.Type.GetType%2A> を使用します。 型名を指定した <xref:System.Type.GetType%2A> は、呼び出し元のアセンブリで <xref:System.Type> を検索し、次にシステムアセンブリで検索します。 アセンブリ修飾型名を使用して <xref:System.Type.GetType%2A> と、任意のアセンブリで <xref:System.Type> が検索されます。  
  
 型名には、型が参照型、ポインター型、配列型のいずれであるかなど、型に関する追加情報を示す末尾の文字を含めることができます。 末尾の文字を含まない型名を取得するには、`t.GetElementType().ToString()`を使用します。 `t` は型です。  
  
 スペースは、アセンブリ名を除くすべての型名のコンポーネントに関連します。 アセンブリ名では、', ' 区切り記号の前のスペースが関連しますが、', ' 区切り記号の後のスペースは無視されます。  
  
 ジェネリック型の名前は、バックティック (\`) で終わり、その後にジェネリック型引数の数を表す数字が続きます。 この名前の変形の目的は、同じスコープで発生する、同じ名前で型パラメーターの数が異なるジェネリック型をコンパイラがサポートできるようにすることです。 たとえば、リフレクションは、`Tuple(Of T0, T1)` 内のジェネリックメソッド `Tuple(Of T)` および Visual Basic、またはビジュアルC#内の `Tuple<T>` と組`\<T0, T1>` で、`Tuple`1` and `タプル`2` から破損した名前を返します。  
  
 ジェネリック型の場合、型引数リストは角かっこで囲まれ、型引数はコンマで区切られます。 たとえば、ジェネリック <xref:System.Collections.Generic.Dictionary%602> には、2つの型パラメーターがあります。 <xref:System.String> 型のキーを持つ `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように表されます。  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 型引数リスト内でアセンブリ修飾型を指定するには、アセンブリ修飾型を角かっこで囲みます。 それ以外の場合、アセンブリ修飾名の一部を区切るコンマは、追加の型引数の区切りとして解釈されます。 たとえば、<xref:System.String>型のキーを使用して、MyAssembly の `MyType` の <xref:System.Collections.Generic.Dictionary%602> は、次のように指定することができます。  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  アセンブリ修飾型は、型パラメーターリスト内に出現する場合にのみ、角かっこで囲むことができます。 型パラメーターリスト内の修飾型および非修飾型のアセンブリを検索するための規則は、修飾された非修飾の非ジェネリック型の規則と同じです。  
  
 Null 許容型は、ジェネリック型の特殊なケースです。 たとえば、null 値が許容される <xref:System.Int32> は、"System. Nullable ' 1 [system.string]" という文字列で表されます。  
  
> [!NOTE]
>  、 C# C++、Visual Basic では、型演算子を使用して null 許容型を取得することもできます。 たとえば、null 値が許容される <xref:System.Boolean> 型は、 C#の `typeof(Nullable<bool>)` によっC++て返されます。また、の `Nullable<Boolean>::typeid`、および Visual Basic の `GetType(Nullable(Of Boolean))` によって返されます。  
  
 次の表は、さまざまな型の `GetType` で使用する構文を示しています。  
  
|取得するには|用途|  
|------------|---------|  
|Null 許容の <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|`MyType` するアンマネージポインター。|`Type.GetType("MyType*")`|  
|へのポインターへのアンマネージポインター `MyType`|`Type.GetType("MyType**")`|  
|`MyType` へのマネージポインターまたは参照|`Type.GetType("MyType&")` で初期化します。 ポインターとは異なり、参照は 1 つのレベルに制限されます。|  
|親クラスと入れ子になったクラス|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限が0の1次元配列。|`Type.GetType("MyArray[]")`|  
|不明な下限を持つ1次元配列。|`Type.GetType("MyArray[*]")`|  
|N 次元配列|角かっこ内のコンマ (,) は、合計 n-1 回です。 たとえば、`System.Object[,,]` は3次元の `Object` 配列を表します。|  
|2次元配列の配列。|`Type.GetType("MyArray[][]")`|  
|下限が不明な四角形の2次元配列|`Type.GetType("MyArray[,]")`|  
|1つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`1[MyType]")``|  
|2つの型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|2つのアセンブリ修飾型引数を持つジェネリック型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|アセンブリ修飾型引数を持つアセンブリ修飾ジェネリック型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|型引数が2つの型引数を持つジェネリック型であるジェネリック型。|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は空の文字列です。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
- または - 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> が <see langword="true" /> で、 <paramref name="typeName" /> に正しくない構文が含まれています。 例: "MyType[,*,]"。  
  
- または - 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、 <see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
- または - 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
- または - 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 - または -  
  
 共通言語ランタイムの Version 2.0 以降を現在読み込み中です。またアセンブリは新しいバージョンでコンパイルされました。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 <paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。 <paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />. <paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。 <paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。 <paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、<paramref name="typeResolver" /> メソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <summary>指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定された名前の型。型が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの使用シナリオと `assemblyResolver` および `typeResolver` パラメーターの詳細については、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードに関する説明を参照してください。  
  
> [!NOTE]
>  `typeName` が見つからない場合、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> メソッドを呼び出すと `null`が返されます。 例外はスローされません。 例外がスローされるかどうかを制御するには、`throwOnError` パラメーターを持つ <xref:System.Type.GetType%2A> メソッドのオーバーロードを呼び出します。  
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`throwOnError` と `ignoreCase` のパラメーターに `false` を指定することと同じです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。  
  
- または - 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、 <see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
- または - 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
- または - 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。  
  
- または - 
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
- または - 
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 - または -  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 <paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。 <paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />. <paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。 <paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。 <paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、このメソッドで指定できます。 このメソッドは、大文字と小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには <see langword="false" /> が渡されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <summary>型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの使用シナリオと `assemblyResolver` および `typeResolver` パラメーターの詳細については、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードに関する説明を参照してください。  
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`ignoreCase` パラメーターの `false` を指定することと同じです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は空の文字列です。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
- または - 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 ("MyType[,*,]" など) が含まれています。  
  
- または - 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、 <see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
- または - 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
- または - 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。  
  
- または - 
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
- または - 
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 - または -  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する型の名前。 <paramref name="typeResolver" /> パラメーターを指定する場合は、<paramref name="typeResolver" /> が解決できる任意の文字列を型名として使用できます。 <paramref name="assemblyResolver" /> パラメーターを指定する場合、または標準の型解決を使用する場合は、<paramref name="typeName" /> をアセンブリ修飾名にする必要があります (<see cref="P:System.Type.AssemblyQualifiedName" />を参照)。ただし、現在実行されているアセンブリ内または Mscorlib.dll に型がある場合は、名前空間で修飾された型名を指定するだけで十分です。</param>
        <param name="assemblyResolver">で指定されたアセンブリを特定して返すメソッド<paramref name="typeName" />. <paramref name="assemblyResolver" /> には、アセンブリ名が <see cref="T:System.Reflection.AssemblyName" /> オブジェクトとして渡されます。 <paramref name="typeName" /> にアセンブリの名前が含まれていない場合、<paramref name="assemblyResolver" /> は呼び出されません。 <paramref name="assemblyResolver" /> を指定しない場合は、標準のアセンブリ解決が実行されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。 渡した場合は、悪意のあるコードに対して特権が昇格される可能性があります。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。</param>
        <param name="typeResolver"><paramref name="typeName" /> で指定された型を、<paramref name="assemblyResolver" /> または標準のアセンブリ解決によって返されたアセンブリから特定して返すメソッド。 アセンブリが指定されていない場合は、このメソッドで指定できます。 このメソッドは、大文字小文字を区別せずに検索を実行するかどうかを指定するパラメーターも受け取ります。そのパラメーターには、<paramref name="ignoreCase" /> の値が渡されます。  
  
注意   不明な呼び出し元や信頼関係のない呼び出し元からのメソッドは渡さないようにしてください。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。 また、<see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」を参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <see langword="true" /> の検索を実行するには <paramref name="typeName" />。大文字と小文字を区別して <see langword="false" /> の検索を実行するには <paramref name="typeName" />。</param>
        <summary>大文字と小文字を区別せずに検索を実行するかどうか、および型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の型を取得します。オプションとして、アセンブリおよび型を解決するカスタム メソッドを指定できます。</summary>
        <returns>指定した名前を持つ型。 型が見つからない場合、<paramref name="throwOnError" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwOnError" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドオーバーロードとそれに関連付けられているオーバーロード (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> および <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) を使用して、<xref:System.Type.GetType%2A> メソッドの既定の実装をより柔軟な実装に置き換えます。 型名とそれらを含むアセンブリの名前を解決する独自のメソッドを提供することで、次の操作を実行できます。  
  
-   型の読み込み元のアセンブリのバージョンを制御します。  
  
-   アセンブリ名を含まない型名を検索する別の場所を指定します。  
  
-   部分的なアセンブリ名を使用してアセンブリを読み込みます。  
  
-   共通言語ランタイム (CLR) によって作成されていない <xref:System.Type?displayProperty=nameWithType> のサブクラスを返します。  
  
 たとえば、バージョントレラントなシリアル化では、このメソッドを使用すると、部分名を使用して "最適" アセンブリを検索できます。 <xref:System.Type.GetType%2A> メソッドの他のオーバーロードには、アセンブリ修飾型名が必要です。これにはバージョン番号が含まれます。  
  
 型システムの代替実装では、CLR によって作成されていない <xref:System.Type?displayProperty=nameWithType> のサブクラスを返すことが必要になる場合があります。<xref:System.Type.GetType%2A> メソッドの他のオーバーロードによって返されるすべての型は、ランタイム型です。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>使用に関する注意事項  
 このメソッドのオーバーロードとそれに関連付けられているオーバーロードは、`typeName` を型の名前とアセンブリの名前に解析し、名前を解決します。 アセンブリ名の解決は、アセンブリのコンテキストで型名を解決する必要があるため、型名の解決の前に発生します。  
  
> [!NOTE]
>  アセンブリ修飾型名の概念に慣れていない場合は、<xref:System.Type.AssemblyQualifiedName%2A> プロパティを参照してください。  
  
 `typeName` がアセンブリ修飾名でない場合、アセンブリ解決はスキップされます。 修飾されていない型名は Mscorlib.dll または現在実行中のアセンブリのコンテキストで解決できます。また、必要に応じて `typeResolver` パラメーターにアセンブリを指定することもできます。 さまざまな種類の名前解決にアセンブリ名を含めたり省略したりした場合の効果は、[[混合名の解決](#mixed_name_resolution)] セクションにテーブルとして表示されます。  
  
 一般的な使用に関する注意事項:  
  
-   不明または信頼されていない呼び出し元からのものである場合は、メソッドを `assemblyResolver` に渡したり、`typeResolver` したりしないでください。 指定したメソッドまたは使い慣れているメソッドだけを使用してください。  
  
    > [!CAUTION]
    >  不明または信頼されていない呼び出し元のメソッドを使用すると、悪意のあるコードの特権が昇格される可能性があります。  
  
-   `assemblyResolver` パラメーターまたは `typeResolver` パラメーターを省略した場合は、既定の解決を実行するメソッドに `throwOnError` パラメーターの値が渡されます。  
  
-   `throwOnError` が `true`場合、このメソッドは `typeResolver` が `null`を返したときに <xref:System.TypeLoadException> をスローし、<xref:System.IO.FileNotFoundException> が `assemblyResolver` を返したときに `null`をスローします。  
  
-   このメソッドは、`assemblyResolver` および `typeResolver`によってスローされた例外をキャッチしません。 競合回避モジュールによってスローされる例外については、お客様が責任を負うものとします。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>アセンブリの解決  
 `assemblyResolver` メソッドは、`typeName`に含まれている文字列アセンブリ名を解析することによって生成される <xref:System.Reflection.AssemblyName> オブジェクトを受け取ります。 `typeName` にアセンブリ名が含まれていない場合、`assemblyResolver` は呼び出されず、`typeResolver`に `null` が渡されます。  
  
 `assemblyResolver` が指定されていない場合、アセンブリを検索するために標準のアセンブリプローブが使用されます。 `assemblyResolver` が指定されている場合、<xref:System.Type.GetType%2A> 方法では、標準のプローブは実行されません。その場合は、`assemblyResolver` が、渡すすべてのアセンブリを処理できることを確認する必要があります。  
  
 `assemblyResolver` メソッドは、アセンブリを解決できない場合に `null` を返す必要があります。 `assemblyResolver` が `null`を返す場合、`typeResolver` は呼び出されず、それ以上の処理は行われません。さらに、`throwOnError` が `true`場合は、<xref:System.IO.FileNotFoundException> がスローされます。  
  
 `assemblyResolver` に渡された <xref:System.Reflection.AssemblyName> が部分的な名前である場合、その1つ以上の部分が `null`ます。 たとえば、バージョンがない場合、<xref:System.Reflection.AssemblyName.Version%2A> プロパティは `null`になります。 <xref:System.Reflection.AssemblyName.Version%2A> プロパティ、<xref:System.Reflection.AssemblyName.CultureInfo%2A> プロパティ、および <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> メソッドがすべて `null`を返す場合は、アセンブリの簡易名のみが指定されています。 `assemblyResolver` メソッドでは、アセンブリ名のすべての部分を使用または無視できます。  
  
 アセンブリ解決のさまざまなオプションの効果は、単純型名とアセンブリ修飾型名のために、[混合名前解決](#mixed_name_resolution)のセクションにテーブルとして表示されます。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>解決 (型を)  
 `typeName` がアセンブリ名を指定しない場合、`typeResolver` は常に呼び出されます。 `typeName` アセンブリ名を指定すると、アセンブリ名が正常に解決された場合にのみ `typeResolver` が呼び出されます。 `assemblyResolver` または標準のアセンブリプローブが `null`を返した場合、`typeResolver` は呼び出されません。  
  
 `typeResolver` メソッドは、次の3つの引数を受け取ります。  
  
-   `typeName` にアセンブリ名が含まれていない場合に検索または `null` するアセンブリ。  
  
-   型の簡易名。 入れ子にされた型の場合、これは最も外側の型になります。 ジェネリック型の場合、これはジェネリック型の単純な名前です。  
  
-   型名の大文字と小文字の区別を無視する場合に `true` するブール値。  
  
 これらの引数の使用方法は、実装によって決まります。 `typeResolver` メソッドは、型を解決できない場合に `null` を返す必要があります。 `typeResolver` が `null` を返し、`throwOnError` が `true`場合、この <xref:System.Type.GetType%2A> のオーバーロードは <xref:System.TypeLoadException>をスローします。  
  
 さまざまな型解決オプションの効果は、単純型とアセンブリ修飾型の名前について、[混在する名前解決](#mixed_name_resolution)のセクションにテーブルとして表示されます。  
  
#### <a name="resolving-nested-types"></a>入れ子になった型の解決  
 `typeName` が入れ子にされた型である場合は、最も外側にある型の名前だけが `typeResolver`に渡されます。 `typeResolver` がこの型を返すと、最も内側の入れ子にされた型が解決されるまで、<xref:System.Type.GetNestedType%2A> メソッドが再帰的に呼び出されます。  
  
#### <a name="resolving-generic-types"></a>ジェネリック型の解決  
 <xref:System.Type.GetType%2A> は、ジェネリック型を解決するために再帰的に呼び出されます。まずジェネリック型自体を解決してから、その型引数を解決します。 型引数がジェネリックの場合は、型引数を解決するために <xref:System.Type.GetType%2A> が再帰的に呼び出されます。  
  
 指定する `assemblyResolver` と `typeResolver` の組み合わせは、この再帰のすべてのレベルを解決できる必要があります。 たとえば、`MyAssembly`の読み込みを制御する `assemblyResolver` を指定したとします。 ジェネリック型 `Dictionary<string, MyType>` (Visual Basic で`Dictionary(Of String, MyType)`) を解決するとします。 次のジェネリック型名を渡すことができます。  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 アセンブリ修飾型引数は `MyType` のみであることに注意してください。 <xref:System.Collections.Generic.Dictionary%602> クラスと <xref:System.String> クラスの名前はアセンブリ修飾されていません。 `typeResolver` は、<xref:System.Collections.Generic.Dictionary%602> および <xref:System.String>の `null` を受け取るため、アセンブリまたは `null`のいずれかを処理できる必要があります。 この場合、文字列を受け取る <xref:System.Type.GetType%2A> メソッドのオーバーロードを呼び出すことによって処理できます。これは、非修飾型名の両方が Mscorlib.dll にあるためです。  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` メソッドは、ディクショナリ型および文字列型に対しては呼び出されません。これらの型名はアセンブリ修飾名ではないためです。  
  
 ここで、`System.String`ではなく、最初のジェネリック引数の型が `YourAssembly`から `YourType`とします。  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 このアセンブリは Mscorlib.dll と現在実行中のアセンブリのどちらでもないため、アセンブリ修飾名を指定せずに `YourType` を解決することはできません。 `assemblyResolve` は再帰的に呼び出されるため、この場合は処理できる必要があります。 `MyAssembly`以外のアセンブリの `null` を返す代わりに、指定された <xref:System.Reflection.AssemblyName> オブジェクトを使用してアセンブリの読み込みが実行されるようになりました。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 「[使用状況のメモ](#usage_notes)」に戻ります。  
  
#### <a name="resolving-type-names-with-special-characters"></a>型名の解決 (特殊文字を使用した)  
 アセンブリ修飾名では、特定の文字が特別な意味を持ちます。 単純型名にこれらの文字が含まれている場合、単純名がアセンブリ修飾名の一部であると、文字によって解析エラーが発生します。 解析エラーを回避するには、アセンブリ修飾名を <xref:System.Type.GetType%2A> メソッドに渡す前に、円記号を使用して特殊文字をエスケープする必要があります。 たとえば、型に `Strange]Type`という名前が付いている場合は、次のように、角かっこの前にエスケープ文字を追加する必要があります: `Strange\]Type`。  
  
> [!NOTE]
>  これらの特殊文字を含む名前は Visual Basic またはC#で作成できませんが、Microsoft 中間言語 (MSIL) を使用して作成することも、動的アセンブリを出力することによって作成することもできます。  
  
 次の表は、型名の特殊文字を示しています。  
  
|文字|意味|  
|---------------|-------------|  
|`,` (コンマ)|アセンブリ修飾名の区切り記号。|  
|`[]` (角かっこ)|サフィックスペアとして、は配列型を示します。区切り記号のペアとして、ジェネリック引数リストとアセンブリ修飾名を囲みます。|  
|`&` (アンパサンド)|サフィックスとして、型が参照型であることを示します。|  
|`*` (アスタリスク)|サフィックスとして、型がポインター型であることを示します。|  
|`+` (プラス)|入れ子にされた型の区切り記号。|  
|`\` (円記号)|エスケープ文字。|  
  
 <xref:System.Type.AssemblyQualifiedName%2A> などのプロパティは、正しくエスケープされた文字列を返します。 正しくエスケープされた文字列を <xref:System.Type.GetType%2A> メソッドに渡す必要があります。 さらに、<xref:System.Type.GetType%2A> メソッドは、`typeResolver`、および既定の型解決メソッドに正しくエスケープされた名前を渡します。 `typeResolver`でエスケープ解除された名前と名前を比較する必要がある場合は、エスケープ文字を削除する必要があります。  
  
 「[使用状況のメモ](#usage_notes)」に戻ります。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>混合名前解決  
 次の表は、`typeName`内の型名とアセンブリ名のすべての組み合わせについて、`assemblyResolver`、`typeResolver`、および既定の名前解決の相互作用をまとめたものです。  
  
|型名の内容|アセンブリリゾルバーメソッド|型リゾルバーメソッド|結果|  
|---------------------------|------------------------------|--------------------------|------------|  
|型、アセンブリ|null|null|<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドのオーバーロードを呼び出すことと同じです。|  
|型、アセンブリ|指示|null|`assemblyResolver` はアセンブリを返すか、アセンブリを解決できない場合は `null` を返します。 アセンブリが解決された場合、<xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドのオーバーロードを使用して、アセンブリから型を読み込みます。それ以外の場合、型の解決は試行されません。|  
|型、アセンブリ|null|指示|アセンブリ名を <xref:System.Reflection.AssemblyName> オブジェクトに変換し、<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> メソッドオーバーロードを呼び出してアセンブリを取得する場合と同じです。 アセンブリが解決された場合は、`typeResolver`に渡されます。それ以外の場合、`typeResolver` は呼び出されず、型の解決を試行することはありません。|  
|型、アセンブリ|指示|指示|`assemblyResolver` はアセンブリを返すか、アセンブリを解決できない場合は `null` を返します。 アセンブリが解決された場合は、`typeResolver`に渡されます。それ以外の場合、`typeResolver` は呼び出されず、型の解決を試行することはありません。|  
|型|null (指定)|null|<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドのオーバーロードを呼び出すことと同じです。 アセンブリ名が指定されていないため、Mscorlib.dll と現在実行中のアセンブリだけが検索されます。 `assemblyResolver` が指定されている場合は無視されます。|  
|型|null (指定)|指示|`typeResolver` が呼び出され、アセンブリの `null` が渡されます。 `typeResolver` は、その目的のために読み込むアセンブリを含む、任意のアセンブリから型を提供できます。 `assemblyResolver` が指定されている場合は無視されます。|  
|アセンブリ|null (指定)|null (指定)|アセンブリ名がアセンブリ修飾型名であるかのように解析されるため、<xref:System.IO.FileLoadException> がスローされます。 これにより、無効なアセンブリ名が生成されます。|  
  
 に戻る:[使用状況に関するメモ](#usage_notes)、[アセンブリの解決](#resolving_assemblies)、[型の解決](#resolving_types)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> が <see langword="true" /> です。型が見つかりません。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は空の文字列です。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。 <paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
- または - 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> の配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> が型名とアセンブリ名に解析される際にエラーが発生します (たとえば、単純な型名にエスケープされていない特殊文字が含まれている場合など)。  
  
- または - 
 <paramref name="throwOnError" /> が <see langword="true" /> です。<paramref name="typeName" /> に無効な構文 ("MyType[,*,]" など) が含まれています。  
  
- または - 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、 <see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
- または - 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
- または - 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。  
  
- または - 
 <paramref name="typeName" /> に無効なアセンブリ名が含まれています。  
  
- または - 
 <paramref name="typeName" /> が、型名のない有効なアセンブリ名です。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 - または -  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">型を確認する対象のオブジェクトの配列。</param>
        <summary>指定した配列内のオブジェクトの型を取得します。</summary>
        <returns><paramref name="args" /> 内の対応する要素の型を表す <see cref="T:System.Type" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、<xref:System.Type.GetTypeArray%2A> メソッドを使用して、配列の要素の型を一覧表示する方法を示しています。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> が <see langword="null" /> です。  
  
- または - 
<paramref name="args" /> の要素の 1 つ以上が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、少なくとも 1 つは例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">基になる型コードを取得する対象となる型。</param>
        <summary>指定した <see cref="T:System.Type" /> の基になる型コードを取得します。</summary>
        <returns><paramref name="type" /> が <see langword="null" /> の場合、基になる型または <see cref="F:System.TypeCode.Empty" /> のコード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>から継承する場合は、<xref:System.Type.GetTypeCodeImpl%2A> メソッドをオーバーライドすることによって、このメソッドの動作を変更できます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.TypeCode> 列挙型の使用方法を示しています。 `WriteObjectInfo` メソッド内のデシジョンブロックでは、<xref:System.Object> パラメーターの <xref:System.TypeCode> が検査され、適切なメッセージがコンソールに書き込まれます。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Type" /> インスタンスの基になる型コードを返します。</summary>
        <returns>基になる型の型コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`static` ( C#) または `Shared` (Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> メソッドの実装を提供します。 <xref:System.Type>から継承する場合は、このメソッドをオーバーライドして、<xref:System.Type.GetTypeCode%2A>の独自の実装を提供できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <summary>指定したクラス識別子 (CLSID) に関連付けられている型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。  COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。 <xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。  
  
> [!TIP]
>  <xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。  
  
 アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。  
  
1.  <xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する`__ComObject` を表す <xref:System.Type> オブジェクトを取得します。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。  
  
 例については、図を参照してください。  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> のオーバーロードは、`clsid` 引数に基づいて <xref:System.Type> オブジェクトをインスタンス化するときに発生する可能性のある例外を無視します。 `clsid` がレジストリに見つからない場合は、例外がスローされないことに注意してください。  
  
   
  
## Examples  
 次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、microsoft word アプリケーションを表す COM 型を取得します。 次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。 COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。 メソッドは、.NET Framework オブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって、その <see cref="T:System.Type" /> オブジェクトを使用して型インスタンスを作成することはできません。  
  
[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
- または - 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したクラス ID (CLSID) に関連付けられた型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。  COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。 <xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。  
  
> [!TIP]
>  <xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。  
  
 アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。  
  
1.  <xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する `__ComObject` を表す <xref:System.Type> オブジェクトを取得します。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。  
  
 例については、図を参照してください。  
  
 `throwOnError`に `true` を指定すると、<xref:System.OutOfMemoryException> などの例外がスローされますが、登録されていない Clsid では失敗しません。  
  
   
  
## Examples  
 次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、microsoft word アプリケーションを表す COM 型を取得します。 次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。 型の読み込み中にエラーが発生した場合は、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。 COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。 メソッドは、.NET Framework オブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって、その <see cref="T:System.Type" /> オブジェクトを使用して型インスタンスを作成することはできません。  
  
[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したクラス ID (CLSID) に関連付けられている型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。  COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。 <xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。  
  
> [!TIP]
>  <xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。  
  
 アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。  
  
1.  <xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する `__ComObject` を表す <xref:System.Type> オブジェクトを取得します。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。  
  
   
  
## Examples  
 次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、computer17.central.contoso.com という名前のサーバーから microsoft word アプリケーションを表す COM 型を取得します。 次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。 COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。 メソッドは、.NET Framework オブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって、その <see cref="T:System.Type" /> オブジェクトを使用して型インスタンスを作成することはできません。  
  
[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">取得する型の CLSID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" />の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
- または - 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したクラス ID (CLSID) に関連付けられた型を取得します。</summary>
        <returns>CLSID が有効かどうかに関係なく <see langword="System.__ComObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> メソッドは、COM オブジェクトのクラス識別子 (CLSID) がわかっている場合に .NET Framework アプリからアンマネージ COM オブジェクトへの遅延バインディングアクセスをサポートします。  COM クラスのクラス識別子は、レジストリの HKEY_CLASSES_ROOT/CLSID キーで定義されています。 <xref:System.Type.IsCOMObject%2A> プロパティの値を取得して、このメソッドによって返される型が COM オブジェクトであるかどうかを判断できます。  
  
> [!TIP]
>  <xref:System.Type.GetTypeFromProgID%2A> メソッドを呼び出して、プログラム識別子 (ProgID) がわかっている COM オブジェクトへの遅延バインディングアクセスを行うことができます。  
  
 アンマネージ COM オブジェクトを CLSID からインスタンス化するには、次の2つの手順を実行します。  
  
1.  <xref:System.Type.GetTypeFromCLSID%2A> メソッドを呼び出すことによって、CLSID に対応する `__ComObject` を表す <xref:System.Type> オブジェクトを取得します。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> メソッドを呼び出して、COM オブジェクトをインスタンス化します。  
  
 `throwOnError`に `true` を指定すると、<xref:System.OutOfMemoryException> などの例外がスローされますが、登録されていない Clsid では失敗しません。  
  
   
  
## Examples  
 次の例では、Microsoft Word[アプリケーションオブジェクト](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)の CLSID を使用して、computer17.central.contoso.com という名前のサーバーから microsoft word アプリケーションを表す COM 型を取得します。 次に、<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> メソッドを呼び出して型をインスタンス化し、 [Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)メソッドを呼び出して閉じます。 型の読み込み中にエラーが発生した場合は、例外がスローされます。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>このメソッドは、.NET Framework オブジェクトではなく、COM オブジェクトを操作するときに使用することを目的としています。 COM から参照できるオブジェクト (つまり、<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> 属性が <see langword="true" />) を含むすべてのマネージオブジェクトには、<see cref="P:System.Type.GUID" /> プロパティによって返される GUID があります。 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> メソッドは、特定のマネージオブジェクトの GUID に対応する <see cref="T:System.Type" /> オブジェクトを返しますが、次の例に示すように、その <see cref="T:System.Type" /> オブジェクトを使用して、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドを呼び出すことによって型インスタンスを作成することはできません。  
  
[! code-csharp[GetTypeFromCLSID # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)][! code-vb[GetTypeFromCLSID # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
代わりに、<see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> はアンマネージ COM オブジェクトの GUID を取得するためにのみ使用する必要があり、<see cref="M:System.Activator.CreateInstance(System.Type)" /> メソッドに渡される結果の <see cref="T:System.Type" /> オブジェクトはアンマネージ COM オブジェクトを表す必要があります。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">型を参照するオブジェクト。</param>
        <summary>指定した型ハンドルによって参照される型を取得します。</summary>
        <returns>指定した <see cref="T:System.RuntimeTypeHandle" /> によって参照される型。または <paramref name="handle" /> の <see cref="P:System.RuntimeTypeHandle.Value" /> プロパティが <see langword="null" /> の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、取得されたアプリケーションドメインでのみ有効です。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.GetTypeFromHandle%2A> メソッドを使用して、<xref:System.Type.GetTypeHandle%2A> メソッドによって提供される <xref:System.RuntimeTypeHandle> から <xref:System.Type> オブジェクトを取得します。  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したプログラム ID (ProgID) に関連付けられている型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <summary>指定したプログラム ID (ProgID) に関連付けられている型を取得し、<see cref="T:System.Type" /> の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したクラス ProgID に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、COM をサポートするために用意されています。 Progid は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は<see langword="true" /> 。  
  
- または - 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したプログラム ID (ProgID) に関連付けられた型を取得します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (ProgID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、COM をサポートするために用意されています。 プログラム Id は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、progid が無効な場合に例外をスローするかどうかを指定して、ProgID を渡すことによって型を取得します。 この例では、ProgID に関連する ClassID と、該当するすべての例外メッセージが表示されます。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された ProgID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">取得する型の ProgID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" /> の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <summary>指定したサーバーから、指定したプログラム ID (progID) に関連付けられている型を取得し、型の読み込み中にエラーが発生した場合は null を返します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、COM をサポートするために用意されています。 プログラム Id は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID とサーバー名を渡して型を取得します。 次に、ProgID に関連する ClassID を表示します。 ProgID またはサーバー名が無効な場合は、例外をスローします。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">取得する <see cref="T:System.Type" /> のプログラム ID。</param>
        <param name="server">型の読み込み元のサーバー。 サーバー名が <see langword="null" />の場合、このメソッドは自動的にローカル マシンの名前を使用します。</param>
        <param name="throwOnError">発生した例外をすべてスローする場合は <see langword="true" />。  
  
- または - 
 発生した例外をすべて無視する場合は <see langword="false" />。</param>
        <summary>型の読み込み中にエラーが発生した場合に例外をスローするかどうかを指定して、指定したサーバーの指定したプログラム ID (ProgID) に関連付けられた型を取得します。</summary>
        <returns><paramref name="progID" /> がレジストリの有効なエントリで、型がそれに関連付けられている場合は、指定したプログラム ID (progID) に関連付けられている型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、COM をサポートするために用意されています。 プログラム Id は、名前空間の概念によって置き換えられているため、Microsoft .NET Framework では使用されません。  
  
   
  
## Examples  
 次の例では、ProgID とサーバー名を渡して型を取得します。 次に、progid に関連する ClassID が表示されます。 ProgID またはサーバー名が無効である場合に例外をスローするかどうかを指定します。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">指定された progID が登録されていません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">型ハンドルの取得対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <returns>指定した <see cref="T:System.Type" /> の <see cref="T:System.Object" /> のハンドル。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、取得されたアプリケーションドメインでのみ有効です。  
  
   
  
## Examples  
 次の例では、`MyClass1`クラスを定義し、そのインスタンスを取得して、オブジェクトのランタイムハンドルを取得します。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" />に関連付けられている GUID を取得します。</summary>
        <value><see cref="T:System.Type" /> に関連付けられている GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID は、<xref:System.Runtime.InteropServices.GuidAttribute> 属性を使用して型に関連付けられています。  
  
   
  
## Examples  
 次の例では、パブリックメソッドを使用して `MyClass1` クラスを作成し、`MyClass1`に対応する `Type` オブジェクトを作成し、`GUID` クラスの `Type` プロパティを使用して <xref:System.Guid> 構造体を取得します。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列、ポインター、または参照渡しかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、「GetType ("Int32 []")」と入力します。HasElementType は `true`を返しますが、タイプ GetType ("Int32") です。HasElementType は `false`を返します。 また、HasElementType は、"Int32 *" と "Int32 &" の `true` も返します。  
  
 現在の <xref:System.Type> がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例では、オブジェクトが配列、参照型、またはポインターであるかどうかに応じて、`true` または `false` を返します。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされた場合、<see cref="P:System.Type.HasElementType" /> プロパティを実装し、現在の <see cref="T:System.Type" /> が別の型を包含または参照しているかどうか、つまり現在の <see cref="T:System.Type" /> が配列やポインターであるか、参照渡しかどうかを判断します。</summary>
        <returns><see langword="true" /> が配列やポインターであるか、参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、「GetType ("Int32 []")」と入力します。HasElementTypeImpl は `true`を返しますが、タイプ GetType ("Int32") です。HasElementTypeImpl は `false`を返します。 また、HasElementTypeImpl では、"Int32 *" と "Int32 &" の `true` も返されます。  
  
   
  
## Examples  
 次の例では、`HasElementTypeImpl` メソッドをオーバーライドする `MyTypeDelegator`クラスを定義しています。 Main クラスは、`HasElementType` プロパティを確認し、要素の型を表示します。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> の特定のメンバーを呼び出します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
- または - 
既定メンバーを呼び出すための空の文字列 ("")。  
  
- または - 
<see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <summary>指定したバインディング制約を使用し、指定した引数リストと照合して、指定したメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Type.InvokeMember%2A> を使用してジェネリックメソッドを呼び出すことはできません。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。  
  
-   パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。  
  
-   `BindingFlags.NonPublic` を指定すると、パブリックでないメンバー (つまり、プライベートメンバーとプロテクトメンバー) を検索に含めることができます。  
  
-   階層の上位に静的メンバーを含めるには、`BindingFlags.FlattenHierarchy` を指定します。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 次の <xref:System.Reflection.BindingFlags> の呼び出しフラグを使用して、メンバーに対して実行するアクションを示すことができます。  
  
-   コンストラクターを呼び出すように `CreateInstance` します。 `name` は無視されます。 他の呼び出しフラグと共に使用することはできません。  
  
-   コンストラクターや型の初期化子ではなく、メソッドを呼び出すように `InvokeMethod` します。 `SetField` または `SetProperty`では無効です。 `InvokeMethod` が単独で指定されている場合、`BindingFlags.Public`、`BindingFlags.Instance`、および `BindingFlags.Static` が自動的に含まれます。  
  
-   フィールドの値を取得 `GetField`。 `SetField`では無効です。  
  
-   フィールドの値を設定 `SetField`。 `GetField`では無効です。  
  
-   プロパティを取得するために `GetProperty` します。 `SetProperty`では無効です。  
  
-   プロパティを設定する `SetProperty` ます。 `GetProperty`では無効です。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の両方の条件に該当する場合は、メソッドが呼び出されます。  
  
-   メソッド宣言内のパラメーターの数は、`args` 配列内の引数の数と等しくなります (既定の引数がメンバーに対して定義され、`BindingFlags.OptionalParamBinding` が指定されている場合を除く)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、一致するすべてのメソッドを検索します。 これらのメソッドは、要求されたバインディングの種類 (<xref:System.Reflection.BindingFlags> 値 `InvokeMethod`、`GetProperty`など) に基づいて検出されます。 メソッドのセットは、バインダーで定義されている名前、引数の数、および一連の検索修飾子によってフィルター処理されます。  
  
 メソッドが選択されると、呼び出されます。 その時点でアクセシビリティがチェックされます。 検索では、メソッドに関連付けられているアクセシビリティ属性に基づいて検索されるメソッドのセットを制御できます。 <xref:System.Reflection.Binder> クラスの <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> メソッドは、呼び出されるメソッドを選択する役割を担います。 既定のバインダーでは、最も限定的な一致が選択されます。  
  
 完全に信頼されたコードでは、アクセス制限は無視されます。つまり、プライベートコンストラクター、メソッド、フィールド、およびプロパティには、コードが完全に信頼されている場合は常に <xref:System.Reflection> を通じてアクセスおよび呼び出しを行うことができます。  
  
 `Type.InvokeMember` を使用すると、<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>を指定することによってフィールドを特定の値に設定できます。 たとえば、F という名前のパブリックインスタンスフィールドをクラス C に設定し、F が `String`である場合は、次のようなコードを使用できます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 F が `String[]`である場合は、次のようなコードを使用できます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 これにより、フィールド F がこの新しい配列に初期化されます。 また、`Type.InvokeMember` を使用して、値のインデックスを指定し、次のようなコードを使用して次の値を指定することによって、配列内の位置を設定することもできます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 これにより、F が保持する配列内の文字列 "z" が文字列 "b" に変更されます。  
  
 `IDispatch` メンバーを呼び出す場合は、"[DispID = # #]" という文字列形式を使用して、メンバー名の代わりに DispID を指定できます。 たとえば、MyComMethod の DispID が3の場合、"MyComMethod" ではなく "[DispID = 3]" という文字列を指定できます。 メンバーを DispID で呼び出す方が、メンバーを名前で検索するよりも高速です。 複雑な集計シナリオでは、DispID が目的のメンバーを呼び出す唯一の方法である場合があります。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されている場合、および非パブリックメンバーの許可セットが呼び出し元の許可セットまたはサブセットに制限されている場合に、このメソッドを使用して非パブリックメンバーにアクセスできます。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、`InvokeMember` を使用して、型のメンバーにアクセスします。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
- または - 
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、 <see langword="CreateInstance" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、 <see langword="SetProperty" />のいずれかが含まれていません。  
  
- または - 
 <paramref name="invokeAttr" /> に、 <see langword="CreateInstance" /> と <see langword="InvokeMethod" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、 <see langword="SetProperty" />との組み合わせが含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" />の両方が含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" />の両方が含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に、 <see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" />との組み合わせが含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、 <paramref name="args" /> に複数の要素があります。  
  
- または - 
COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
- または - 
名前付きパラメーター配列の 1 つに、 <see langword="null" />である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
- または - 
現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このメソッドをサポートしていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">許可セットに関係なく、非パブリックメンバーにアクセスする場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを呼び出す。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
- または - 
既定メンバーを呼び出すための空の文字列 ("")。  
  
- または - 
<see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see langword="Nothing" /> を使用する場合は、null 参照 (Visual Basic の場合は <see cref="P:System.Type.DefaultBinder" />)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="culture">使用するグローバリゼーション ロケールを表すオブジェクト。これは、<see cref="T:System.String" /> 型の数値を <see cref="T:System.Double" /> に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
- または - 
現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</param>
        <summary>指定したバインディング制約を使用し、指定したメンバーのうち、指定した引数リストおよびカルチャと一致するメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のバインダーでは <xref:System.Globalization.CultureInfo> (`culture` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`culture`を処理するカスタムバインダーを作成できます。  
  
> [!NOTE]
>  <xref:System.Type.InvokeMember%2A> を使用してジェネリックメソッドを呼び出すことはできません。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。  
  
-   パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。  
  
-   階層の上位に静的メンバーを含めるには、`BindingFlags.FlattenHierarchy` を指定します。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 次の <xref:System.Reflection.BindingFlags> の呼び出しフラグを使用して、メンバーに対して実行するアクションを示すことができます。  
  
-   コンストラクターを呼び出すように `CreateInstance` します。 `name` は無視されます。 他の呼び出しフラグと共に使用することはできません。  
  
-   コンストラクターや型の初期化子ではなく、メソッドを呼び出すように `InvokeMethod` します。 `SetField` または `SetProperty`では無効です。 `InvokeMethod` が単独で指定されている場合、`BindingFlags.Public`、`BindingFlags.Instance`、および `BindingFlags.Static` が自動的に含まれます。  
  
-   フィールドの値を取得 `GetField`。 `SetField`では無効です。  
  
-   フィールドの値を設定 `SetField`。 `GetField`では無効です。  
  
-   プロパティを取得するために `GetProperty` します。 `SetProperty`では無効です。  
  
-   プロパティを設定する `SetProperty` ます。 `GetProperty`では無効です。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の両方の条件に該当する場合は、メソッドが呼び出されます。  
  
-   メソッド宣言内のパラメーターの数は、`args` 配列内の引数の数と等しくなります (既定の引数がメンバーに対して定義され、`BindingFlags.OptionalParamBinding` が指定されている場合を除く)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、一致するすべてのメソッドを検索します。 これらのメソッドは、要求されたバインディングの種類 (<xref:System.Reflection.BindingFlags> 値 `InvokeMethod`、`GetProperty`など) に基づいて検出されます。 メソッドのセットは、バインダーで定義されている名前、引数の数、および一連の検索修飾子によってフィルター処理されます。  
  
 メソッドが選択されると、呼び出されます。 その時点でアクセシビリティがチェックされます。 検索では、メソッドに関連付けられているアクセシビリティ属性に基づいて検索されるメソッドのセットを制御できます。 <xref:System.Reflection.Binder> クラスの <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> メソッドは、呼び出されるメソッドを選択する役割を担います。 既定のバインダーでは、最も限定的な一致が選択されます。  
  
 完全に信頼されたコードでは、アクセス制限は無視されます。つまり、プライベートコンストラクター、メソッド、フィールド、およびプロパティには、コードが完全に信頼されている場合は常に、リフレクションを介してアクセスして呼び出すことができます。  
  
 `Type.InvokeMember` を使用すると、<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>を指定することによってフィールドを特定の値に設定できます。 たとえば、F という名前のパブリックインスタンスフィールドをクラス C に設定し、F が `String` である場合は、次のようなコードを使用できます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 F が `String[]`である場合は、次のようなコードを使用できます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 これにより、フィールド F がこの新しい配列に初期化されます。 また、`Type.InvokeMember` を使用して、値のインデックスを指定し、次のようなコードを使用して次の値を指定することによって、配列内の位置を設定することもできます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 これにより、F が保持する配列内の文字列 "z" が文字列 "b" に変更されます。  
  
 `IDispatch` メンバーを呼び出す場合は、"[DispID = # #]" という文字列形式を使用して、メンバー名の代わりに DispID を指定できます。 たとえば、MyComMethod の DispID が3の場合、"MyComMethod" ではなく "[DispID = 3]" という文字列を指定できます。 メンバーを DispID で呼び出す方が、メンバーを名前で検索するよりも高速です。 複雑な集計シナリオでは、DispID が目的のメンバーを呼び出す唯一の方法である場合があります。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されている場合、および非パブリックメンバーの許可セットが呼び出し元の許可セットまたはサブセットに制限されている場合に、このメソッドを使用して非パブリックメンバーにアクセスできます。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
- または - 
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、 <see langword="CreateInstance" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、 <see langword="SetProperty" />のいずれかが含まれていません。  
  
- または - 
 <paramref name="invokeAttr" /> に、 <see langword="CreateInstance" /> と <see langword="InvokeMethod" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、 <see langword="SetProperty" />との組み合わせが含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" />の両方が含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" />の両方が含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に、 <see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" />との組み合わせが含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、 <paramref name="args" /> に複数の要素があります。  
  
- または - 
COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
- または - 
名前付きパラメーター配列の 1 つに、 <see langword="null" />である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
- または - 
現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">許可セットに関係なく、非パブリックメンバーにアクセスする場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを呼び出す。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">呼び出すコンストラクター、メソッド、プロパティ、またはフィールド メンバーの名前を格納している文字列。  
  
- または - 
既定メンバーを呼び出すための空の文字列 ("")。  
  
- または - 
<see langword="IDispatch" /> メンバーの場合は、"[DispID=3]" のように DispID を表す文字列。</param>
        <param name="invokeAttr">検索を実施する方法を指定する列挙値のビットごとの組み合わせ。 アクセスは、<see langword="BindingFlags" />、<see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> など、<see langword="GetField" /> のうちの 1 つになります。 検索の種類を指定する必要はありません。 検索の種類が省略されている場合は、<see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> を使用します。</param>
        <param name="binder">一連のプロパティを定義し、バインディングを有効にするオブジェクト。バインディングには、オーバーロードされたメソッドの選択、引数の型の強制変換、リフレクションによるメンバーの呼び出しなどが含まれます。  
  
- または - 
<see cref="P:System.Type.DefaultBinder" /> を使用する場合は、null 参照 (Visual Basic の場合は Nothing)。 可変個の引数を指定してメソッド オーバーロードを正常に呼び出すには、<see cref="T:System.Reflection.Binder" /> オブジェクトを明示的に定義することが必要な場合があるのでご注意ください。</param>
        <param name="target">指定したメンバーを呼び出す対象となるオブジェクト。</param>
        <param name="args">呼び出すメンバーに渡される引数を格納する配列。</param>
        <param name="modifiers"><paramref name="args" /> 配列内の対応する要素に関連付けられている属性を表す <see cref="T:System.Reflection.ParameterModifier" /> オブジェクトの配列。 パラメーターに関連付けられた属性は、メンバーのシグネチャに格納されます。  
  
既定のバインダーは、COM コンポーネントを呼び出す場合のみ、このパラメーターを処理します。</param>
        <param name="culture">使用するロケールを表す <see cref="T:System.Globalization.CultureInfo" /> オブジェクト。これは、String 型の数値を Double に変換するなど、ロケール固有の変換を実行するために必要となる場合があります。  
  
- または - 
現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> を使用する場合は、null 参照 (Visual Basic の場合は <see langword="Nothing" />)。</param>
        <param name="namedParameters"><paramref name="args" /> 配列内の値が渡されるパラメーターの名前を格納する配列。</param>
        <summary>派生クラス内でオーバーライドされた場合、指定したバインディング制約を使用し、指定した引数リスト、修飾子、カルチャと照合して、指定されたメンバーを呼び出します。</summary>
        <returns>呼び出されるメンバーの戻り値を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` は、コンストラクターメンバーまたはメソッドメンバーを呼び出し、プロパティメンバーを取得または設定し、データフィールドメンバーを取得または設定します。または、配列メンバーの要素を取得または設定します。  
  
> [!NOTE]
>  <xref:System.Type.InvokeMember%2A> を使用してジェネリックメソッドを呼び出すことはできません。  
  
 `IDispatch` メンバーを呼び出す場合は、"[DispID = # #]" という文字列形式を使用して、メンバー名の代わりに DispID を指定できます。 たとえば、MyComMethod の DispID が3の場合、"MyComMethod" ではなく "[DispID = 3]" という文字列を指定できます。 メンバーを DispID で呼び出す方が、メンバーを名前で検索するよりも高速です。 複雑な集計シナリオでは、DispID が目的のメンバーを呼び出す唯一の方法である場合があります。  
  
 既定のバインダーでは、<xref:System.Reflection.ParameterModifier> または <xref:System.Globalization.CultureInfo> (`modifiers` パラメーターと `culture` パラメーター) は処理されませんが、抽象 <xref:System.Reflection.Binder?displayProperty=nameWithType> クラスを使用して、`modifiers` と `culture`を処理するカスタムバインダーを作成できます。 `ParameterModifier` は、COM 相互運用機能を使用してを呼び出す場合にのみ使用され、参照によって渡されるパラメーターのみが処理されます。  
  
 `namedParameters` 配列の各パラメーターは、`args` 配列内の対応する要素の値を取得します。 `args` の長さが `namedParameters` の長さより大きい場合、残りの引数の値は順番に渡されます。  
  
 `namedParameters` 配列は、入力配列内の引数の順序を変更するために使用できます。 たとえば、メソッド `M(string a, int b)` (Visual Basic で`M(ByVal a As String, ByVal b As Integer)`) と入力 `{ 42, "x" }`配列が指定されている場合、`args` に配列 `{ "b", "a" }` が指定されていれば、入力配列をそのまま `namedParameters`に渡すことができます。  
  
 次の <xref:System.Reflection.BindingFlags> のフィルターフラグを使用して、検索に含めるメンバーを定義できます。  
  
-   パブリックメンバーを検索に含めるには、`BindingFlags.Public` を指定します。  
  
-   検索に非パブリックメンバー (プライベート、内部、およびプロテクトメンバー) を含めるには `BindingFlags.NonPublic` を指定します。  
  
-   階層の上位に静的メンバーを含めるには、`BindingFlags.FlattenHierarchy` を指定します。  
  
 次の <xref:System.Reflection.BindingFlags> 修飾子フラグを使用して、検索の動作を変更できます。  
  
-   `BindingFlags.IgnoreCase` `name`の場合は無視します。  
  
-   単純に継承されたメンバーではなく、<xref:System.Type>で宣言されたメンバーのみを検索するように `BindingFlags.DeclaredOnly` します。  
  
 次の <xref:System.Reflection.BindingFlags> の呼び出しフラグを使用して、メンバーに対して実行するアクションを示すことができます。  
  
-   コンストラクターを呼び出すように `CreateInstance` します。 `name` は無視されます。 他の呼び出しフラグと共に使用することはできません。  
  
-   コンストラクターや型の初期化子ではなく、メソッドを呼び出すように `InvokeMethod` します。 `SetField` または `SetProperty`では無効です。 `InvokeMethod` が単独で指定されている場合、`BindingFlags.Public`、`BindingFlags.Instance`、および `BindingFlags.Static` が自動的に含まれます。  
  
-   フィールドの値を取得 `GetField`。 `SetField`では無効です。  
  
-   フィールドの値を設定 `SetField`。 `GetField`では無効です。  
  
-   プロパティを取得するために `GetProperty` します。 `SetProperty`では無効です。  
  
-   プロパティを設定する `SetProperty` ます。 `GetProperty`では無効です。  
  
 詳細については、「<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>」を参照してください。  
  
 次の両方の条件に該当する場合は、メソッドが呼び出されます。  
  
-   メソッド宣言内のパラメーターの数は、`args` 配列内の引数の数と等しくなります (既定の引数がメンバーに対して定義され、`BindingFlags.OptionalParamBinding` が指定されている場合を除く)。  
  
-   各引数の型は、バインダーによってパラメーターの型に変換できます。  
  
 バインダーは、一致するすべてのメソッドを検索します。 これらのメソッドは、要求されたバインディングの種類 (<xref:System.Reflection.BindingFlags> 値 `InvokeMethod`、`GetProperty`など) に基づいて検出されます。 メソッドのセットは、バインダーで定義されている名前、引数の数、および一連の検索修飾子によってフィルター処理されます。  
  
 メソッドが選択されると、呼び出されます。 その時点でアクセシビリティがチェックされます。 検索では、メソッドに関連付けられているアクセシビリティ属性に基づいて検索されるメソッドのセットを制御できます。 <xref:System.Reflection.Binder> クラスの <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> メソッドは、呼び出されるメソッドを選択する役割を担います。 既定のバインダーでは、最も限定的な一致が選択されます。  
  
 `InvokeMember` を使用すると、既定値を持つパラメーターを使用してメソッドを呼び出すことができます。 これらのメソッドにバインドするには、リフレクションで <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> を指定する必要があります。 既定値を持つパラメーターの場合は、別の値を指定するか、既定値を使用するように <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> を指定できます。  
  
 たとえば、MyMethod (int x, float y = 2.0) などのメソッドについて考えてみます。 1番目の引数だけを使用してこのメソッドを呼び出すには、3番目のバインドフラグの1つを渡し、2つの引数を渡します。つまり、最初の引数の場合は4、2番目の引数の場合は `Missing.Value` します。 `Missing.Value`を使用しない限り、`Invoke` メソッドで省略可能なパラメーターを省略することはできません。 この操作を行う必要がある場合は、代わりに `InvokeMember` を使用します。  
  
 完全に信頼されたコードでは、アクセス制限は無視されます。つまり、プライベートコンストラクター、メソッド、フィールド、およびプロパティには、コードが完全に信頼されている場合は常に <xref:System.Reflection> を通じてアクセスおよび呼び出しを行うことができます。  
  
 `Type.InvokeMember` を使用すると、<xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>を指定することによってフィールドを特定の値に設定できます。 たとえば、F という名前のパブリックインスタンスフィールドをクラス C に設定し、F が `String`である場合は、次のようなコードを使用できます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 F が `String[]`である場合は、次のようなコードを使用できます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 これにより、フィールド F がこの新しい配列に初期化されます。 また、`Type.InvokeMember` を使用して、値のインデックスを指定し、次のようなコードを使用して次の値を指定することによって、配列内の位置を設定することもできます。  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 これにより、F が保持する配列内の文字列 "z" が文字列 "b" に変更されます。  
  
> [!NOTE]
>  [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]以降では、呼び出し元に <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> フラグで <xref:System.Security.Permissions.ReflectionPermission> が付与されている場合、および非パブリックメンバーの許可セットが呼び出し元の許可セットまたはサブセットに制限されている場合に、このメソッドを使用して非パブリックメンバーにアクセスできます。 (「[リフレクションのセキュリティに関する考慮事項」を](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)参照してください)。  
>   
>  この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> に <see langword="CreateInstance" /> が含まれず、<paramref name="name" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> と <paramref name="modifiers" /> の長さが同じではありません。  
  
- または - 
 <paramref name="invokeAttr" /> が有効な <see cref="T:System.Reflection.BindingFlags" /> 属性ではありません。  
  
- または - 
 <paramref name="invokeAttr" /> にバインド フラグ <see langword="InvokeMethod" />、 <see langword="CreateInstance" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、 <see langword="SetProperty" />のいずれかが含まれていません。  
  
- または - 
 <paramref name="invokeAttr" /> に、 <see langword="CreateInstance" /> と <see langword="InvokeMethod" />、 <see langword="GetField" />、 <see langword="SetField" />、 <see langword="GetProperty" />、 <see langword="SetProperty" />との組み合わせが含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="GetField" /> と <see langword="SetField" />の両方が含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="GetProperty" /> と <see langword="SetProperty" />の両方が含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に、 <see langword="InvokeMethod" /> と <see langword="SetField" /> または <see langword="SetProperty" />との組み合わせが含まれています。  
  
- または - 
 <paramref name="invokeAttr" /> に <see langword="SetField" /> が含まれており、 <paramref name="args" /> に複数の要素があります。  
  
- または - 
名前付きパラメーター配列が、引数配列よりも長くなっています。  
  
- または - 
COM オブジェクトでこのメソッドが呼び出され、バインド フラグ <see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" />、<see langword="BindingFlags.PutRefDispProperty" /> のいずれかが渡されませんでした。  
  
- または - 
名前付きパラメーター配列の 1 つに、 <see langword="null" />である文字列が含まれています。</exception>
        <exception cref="T:System.MethodAccessException">指定されたメンバーは、クラス初期化子です。</exception>
        <exception cref="T:System.MissingFieldException">フィールドまたはプロパティが見つかりません。</exception>
        <exception cref="T:System.MissingMethodException"><paramref name="args" /> 内の引数と一致するメソッドが見つかりません。  
  
- または - 
<paramref name="namedParameters" /> の中で引数名が指定されているメンバーが見つかりません。  
  
- または - 
現在の <see cref="T:System.Type" /> オブジェクトは、オープン型のパラメーターを含む型を表します。つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返します。</exception>
        <exception cref="T:System.Reflection.TargetException">指定されたメンバーを <paramref name="target" /> で呼び出すことができません。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">複数のメソッドがバインディングの基準と一致します。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> によって表されるメソッドに、1 つ以上の未指定のジェネリック型パラメーターがあります。 つまり、このメソッドの <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> プロパティが <see langword="true" /> を返します。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">許可セットに関係なく、非パブリックメンバーにアクセスする場合。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを呼び出す。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が抽象型で、オーバーライドする必要があるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が抽象である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A> プロパティは、次の場合に `true` を返します。  
  
-   現在の型は abstract です。つまり、インスタンス化することはできませんが、派生クラスの基底クラスとしてのみ機能できます。 でC#は、抽象クラスは[abstract](~/docs/csharp/language-reference/keywords/abstract.md)キーワードでマークされます。Visual Basic では、 [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)キーワードでマークされます。  
  
-   現在の型はインターフェイスです。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例では、次の型を表す <xref:System.Type> オブジェクトの配列を作成します。指定されたオブジェクトが `abstract`場合、contains 型は `true` を返します。それ以外の場合は `false`を返します。  
  
-   `AbstractClass`、抽象クラス (でC#は `abstract` としてマークされ、Visual Basic では `MustInherit`)。  
  
-   `DerivedClass`、`AbstractClass`から継承するクラスです。  
  
-   `SingleClass`、継承できないクラスです。 `sealed` として定義さC#れ、Visual Basic で `NotInheritable` ます。  
  
-   `ITypeInfo`インターフェイス。  
  
-   `ImplementingClass`、`ITypeInfo` インターフェイスを実装するクラスです。  
  
 メソッドは、`AbstractClass`、抽象クラス、および `ITypeInfo`インターフェイスの `true` のみを返します。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AnsiClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" />に、文字列書式属性として<see langword="AnsiClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> は、文字列形式の属性を選択します。 文字列形式属性は、文字列の解釈方法を定義することで相互運用性を強化します。  
  
 現在の <xref:System.Type> がジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に関連します。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例では、フィールド情報を取得し、`AnsiClass` 属性を確認します。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public virtual bool IsArray { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsArray As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsArray { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が配列かどうかを示す値を返します。</summary>
        <value>現在の型が配列である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A> プロパティは、<xref:System.Array> クラスの `false` を返します。 また、現在のインスタンスが、コレクション型を表す <xref:System.Type> オブジェクト、または <xref:System.Collections.IEnumerable> や <xref:System.Collections.Generic.IEnumerable%601>などのコレクションを使用するように設計されたインターフェイスである場合にも `false` を返します。  
  
 配列を確認するには、次のようなコードを使用します。  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 現在の型がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.IsArray%2A> プロパティの使用方法を示します。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsArray" /> プロパティを実装し、<see cref="T:System.Type" /> が配列かどうかを判断します。</summary>
        <returns><see langword="true" /> が配列である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> クラスのインスタンスは、配列ではなくオブジェクトであるため、`false` を返す必要があります。  
  
   
  
## Examples  
 次の例では、`MyTypeDelegator` クラスの `IsArrayImpl` メソッドをオーバーライドし、変数が配列であるかどうかを確認し、結果を表示します。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>指定された型のインスタンスを現在の型の変数に割り当てることができるかどうかを判断します。</summary>
        <returns><see langword="true" /> が返されるのは、以下のいずれかの条件が満たされる場合です。 
-   <paramref name="c" /> と現在のインスタンスが同じ型を表す。  
  
-   <paramref name="c" /> が、現在のインスタンスから直接または間接に派生している。 <paramref name="c" /> が現在のインスタンスから継承している場合は、現在のインスタンスから直接派生し、<paramref name="c" /> が現在のインスタンスから継承している 1 つ以上のクラスの連続から継承している場合は、現在のインスタンスから間接的に派生します。  
  
-   現在のインスタンスが、<paramref name="c" /> が実装するインターフェイスである。  
  
-   <paramref name="c" /> がジェネリック型パラメーターであり、現在のインスタンスが <paramref name="c" /> の定数の 1 つを表している。  
  
次の例では、現在のインスタンスは、<see cref="T:System.IO.Stream" /> クラスを表す <see cref="T:System.Type" /> オブジェクトです。 <c>GenericWithConstraint</c> は、ジェネリック型パラメーターを <see cref="T:System.IO.Stream" /> 型にする必要があるジェネリック型です。 ジェネリック型パラメーターを <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> に渡すことで、ジェネリック型パラメーターのインスタンスを <see cref="T:System.IO.Stream" /> オブジェクトに割り当てられることを示します。  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> が値型を表し、現在のインスタンスが <c>Nullable&lt;c&gt;</c> (Visual Basic では <c>Nullable(Of c)</c>) を表している。  
  
 <see langword="false" /> が返されるのは、これらの条件がいずれも満たされない場合、または <paramref name="c" /> が <see langword="null" /> である場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A> メソッドを使用すると、`c` のインスタンスを現在の型のインスタンスに割り当てることができるかどうかを判断できます。メソッドは、次の例に示すように、デザイン時に型が不明で、条件付き割り当てが可能なオブジェクトを処理する場合に最も役立ちます。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 このメソッドにより、次のようなコード行が実行時に実行されるようになり、<xref:System.InvalidCastException> 例外や同様の例外がスローされることはありません。  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
> [!NOTE]
>  ジェネリック型定義は、閉じた構築型から割り当てることはできません。 つまり、閉じた構築型 `MyGenericList<int>` (`MyGenericList(Of Integer)` Visual Basic) を `MyGenericList<T>`型の変数に割り当てることはできません。  
  
 `c` パラメーターの型が <xref:System.Reflection.Emit.TypeBuilder>の場合、結果は構築される型に基づきます。 次のコード例は、`B`という名前のビルドされた型を使用してこれを示しています。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 次の例は、定義されたクラス、整数配列、ジェネリックを使用して `IsAssignableFrom` メソッドを示しています。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="AutoClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" />に、文字列書式属性として<see langword="AutoClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> は、文字列形式の属性を選択します。 文字列形式属性は、文字列の解釈方法を定義することで相互運用性を強化します。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、共通言語ランタイムによって自動的に配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の <see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは便宜上提供されています。 または、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 列挙値を使用して型レイアウト属性を選択し、<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> が設定されているかどうかをテストすることもできます。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 列挙値は、型のフィールドがどのようにメモリにレイアウトされるかを示します。  
  
 動的な型の場合は、型を作成するときに <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> を指定できます。 コードでは、<xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> 列挙値と共に型に適用して、ランタイムがクラスをレイアウトするための適切な方法を決定できるようにします。  
  
> [!NOTE]
>  <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを使用して、<xref:System.Runtime.InteropServices.StructLayoutAttribute> が型に適用されているかどうかを判断することはできません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値はによって決定され `MyGenericType<T>.`  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例では、型のインスタンスを作成し、<xref:System.Type.IsAutoLayout%2A> プロパティを表示します。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">メタデータと自己言及的なコンポーネント</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public virtual bool IsByRef { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRef As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRef { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が参照渡しかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実際の型を取得するには、参照によって渡された型を逆参照し、その型の <xref:System.Type.GetElementType%2A> を呼び出します。  
  
   
  
## Examples  
 次の例では、`IsByRef` プロパティを使用して、指定した型が参照によって渡されるかどうかを確認します。 この例では、`HasElementTypeImpl` メソッドをオーバーライドする `MyTypeDelegator`クラスを定義しています。 Main クラスは、`HasElementType` プロパティを確認し、要素の型を表示します。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しかどうかを判断します。</summary>
        <returns><see langword="true" /> が参照渡しである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が byref に似た構造体であるかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Type" /> が byref に似た構造体である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
Byref と同様の構造体は、のC#`ref struct` キーワードを使用して宣言されます。 Byref に似た構造体のインスタンスをマネージヒープに配置することはできません。 詳細については、「 [Ref struct 型](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types)」を参照してください。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がクラスまたはデリゲートである (つまり値型やインターフェイスではない) かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がクラスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、クラスとデリゲートの `true` を返します。 このメソッドは、ボックス化されている場合でも、値型 (構造体と列挙型) の `false` を返します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `true`を返します。現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義がクラス定義である場合に `true` を返します。つまり、インターフェイスまたは値の型は定義されません。  
  
> [!NOTE]
>  このプロパティは、<xref:System.Enum> クラスと <xref:System.ValueType> クラスを表す `Type` インスタンスの `true` を返します。 これら2つのクラスは、それぞれ列挙型と値型の基本型ですが、列挙型または値型ではありません。 詳細については、「<xref:System.Type.IsValueType%2A> と <xref:System.Type.IsEnum%2A> のプロパティ」を参照してください。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 列挙値は、型宣言をクラスまたはインターフェイスと区別します。ただし、クラスと値の型はどちらも、<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> 属性でマークされます。 型の Attributes プロパティの値を取得し、<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> 値を使用して、型が値型ではなくクラスであるかどうかを判断する場合は、<xref:System.Type.IsValueType%2A> プロパティも呼び出す必要があります。 <xref:System.Reflection.TypeAttributes> 列挙型の例には、anexample だけでなく、追加情報が含まれています。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、型のインスタンスを作成し、型がクラスであるかどうかを示します。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が COM オブジェクトかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、オブジェクトではないため、COM インターフェイスの `false` を返します。 COM インターフェイスは Microsoft .NET Framework オブジェクトによって実装できます。  
  
 [Tlbimp.exe (タイプライブラリインポーター)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)ツールを使用して、com クラスを読み込んで、その com クラスの `Type` オブジェクトを取得することもできます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int`> (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決定されます。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsCOMObject" /> プロパティを実装し、<see cref="T:System.Type" /> が COM オブジェクトかどうかを判断します。</summary>
        <returns><see langword="true" /> が COM オブジェクトである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、オブジェクトではないため、COM インターフェイスの `false` を返します。 COM インターフェイスは Microsoft .NET Framework オブジェクトによって実装できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public abstract bool IsConstructedGenericType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。 構築ジェネリック型のインスタンスを作成できます。</summary>
        <value>このオブジェクトが構築ジェネリック型を表している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構築されたジェネリック型には、そのすべてのジェネリック型パラメーターに対して明示的な型が指定されています。 クローズジェネリック型とも呼ばれます。  
  
 このプロパティが `true`場合は、現在の型のインスタンスを作成できます。`false`すると、できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテキストは、クラスメンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを適用します。 リモート処理コンテキストの詳細については、「<xref:System.Runtime.Remoting.Contexts.Context>」を参照してください。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例は、<xref:System.Type> クラスの `IsContextful`、<xref:System.Type.IsMarshalByRef%2A>、および <xref:System.Type.IsPrimitive%2A> の各プロパティを示しています。 このメソッドは、指定された型をコンテキストでホストできるかどうか、参照によってマーシャリングできるかどうか、および型がプリミティブデータ型であるかどうかをチェックします。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsContextful" /> プロパティを実装し、<see cref="T:System.Type" /> をコンテキスト内で管理できるかどうかを判断します。</summary>
        <returns><see langword="true" /> をコンテキスト内でホストできる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
 コンテキストは、クラスメンバーへの呼び出しをインターセプトし、同期などのクラスに適用されるポリシーを適用します。  
  
   
  
## Examples  
 次の例は、`IsContextfulImpl` メソッドの使用方法を示しています。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberSignature Language="C#" Value="public bool IsEnum { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が列挙体であるどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が列挙体を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、列挙体の `true` を返します。ただし、<xref:System.Enum> 型自体に対しては返されません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、`IsEnum` プロパティの使用方法を示します。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">テスト対象の値。</param>
        <summary>指定された値が現在の列挙型に存在するかどうかを示す値を返します。</summary>
        <returns>指定された値が現在の列挙型のメンバーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">現在の型は列挙型ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> は、列挙体の基になる型にできない型です。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other">現在の型と等しいかどうかをテストする COM 型。</param>
        <summary>2 つの COM 型が同じ ID を持ち、型の同値の対象になるかどうかを判断します。</summary>
        <returns>両方の COM 型が等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドは、一方の型が実行のために読み込まれたアセンブリに存在し、もう一方の型がリフレクションのみのコンテキストに読み込まれたアセンブリに存在する場合にも <see langword="false" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、共通言語ランタイムは、マネージアセンブリに COM 型の型情報を直接埋め込むことをサポートしています。これは、マネージアセンブリが相互運用機能アセンブリから COM 型の型情報を取得する必要がなくなります。 埋め込まれる型情報にはマネージド アセンブリに実際に使用される型とメンバーのみが含まれるため、2 つのマネージド アセンブリで同じ COM 型の表示が非常に異なることが考えられます。 マネージド アセンブリごとに、COM 型の表示を表す異なる <xref:System.Type> オブジェクトが与えられます。 共通言語ランタイムでは、インターフェイス、構造、列挙、委任といった異なる表示間で型の等価性が与えられます。  
  
 型の等価性とは、マネージド アセンブリ間で渡される COM オブジェクトを受け取り側のアセンブリで適切なマネージド型に変換できることを意味します。 <xref:System.Type.IsEquivalentTo%2A> メソッドを使用すると、アセンブリは、別のアセンブリから取得された COM オブジェクトが、最初のアセンブリ独自の埋め込み相互運用型の1つと同じ COM id を持つことを判別できます。したがって、その型にキャストできます。  
  
 詳細については、「[型の等価性と埋め込み相互運用機能型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、明示的に指定したオフセット位置に配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の <see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは便宜上提供されています。 または、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 列挙値を使用して型レイアウト属性を選択し、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> が設定されているかどうかをテストすることもできます。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 列挙値は、型のフィールドがどのようにメモリにレイアウトされるかを示します。  
  
 動的な型の場合は、型を作成するときに <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> を指定できます。 コードでは、<xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 列挙値と共に型に適用して、フィールドを開始するオフセットが明示的に指定されるように指定します。  
  
> [!NOTE]
>  <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを使用して、<xref:System.Runtime.InteropServices.StructLayoutAttribute> が型に適用されているかどうかを判断することはできません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例では、型のインスタンスを作成し、その <xref:System.Type.IsExplicitLayout%2A> プロパティの値を表示します。 `MySystemTime` クラスを使用します。これは、<xref:System.Runtime.InteropServices.StructLayoutAttribute>のコード例にも含まれています。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">メタデータと自己言及的なコンポーネント</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が、ジェネリック メソッドの定義の型パラメーターを表すかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Type" /> オブジェクトがジェネリックメソッド定義の型パラメーターを表している場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public abstract bool IsGenericParameter { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsGenericParameter { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> がジェネリック型またはジェネリック メソッドの定義の型パラメーターを表しているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> オブジェクトがジェネリック型定義またはジェネリック メソッド定義の型パラメーターを表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型パラメーターを表す <xref:System.Type> オブジェクトは、ジェネリック型定義を表す <xref:System.Type> オブジェクトの <xref:System.Type.GetGenericArguments%2A> メソッド、またはジェネリックメソッド定義を表す <xref:System.Reflection.MethodInfo> オブジェクトの <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> メソッドを呼び出すことによって取得できます。  
  
-   ジェネリック型またはメソッドの定義の場合、<xref:System.Type.IsGenericParameter%2A> プロパティは、結果として得られる配列のすべての要素に対して `true` を返します。  
  
-   構築された閉じた型またはメソッドの場合、<xref:System.Type.IsGenericParameter%2A> プロパティは <xref:System.Type.GetGenericArguments%2A> メソッドによって返される配列のすべての要素に対して `false` を返します。  
  
-   構築されたオープン型またはメソッドの場合、配列の一部の要素は特定の型である場合もあれば、型パラメーターである場合もあります。 型パラメーターの型と `true` の `false` を返す <xref:System.Type.IsGenericParameter%2A>。 <xref:System.Type.ContainsGenericParameters%2A> プロパティのコード例は、型と型パラメーターが混在するジェネリッククラスを示しています。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.IsGenericParameter%2A> プロパティを使用して、ジェネリック型のジェネリック型パラメーターをテストします。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型がジェネリック型かどうかを示す値を取得します。</summary>
        <value>現在の型がジェネリック型である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsGenericType%2A> プロパティを使用して、<xref:System.Type> オブジェクトがジェネリック型を表すかどうかを判断します。 <xref:System.Type.ContainsGenericParameters%2A> プロパティを使用して、<xref:System.Type> オブジェクトがオープン構築型またはクローズ構築型を表しているかどうかを判断します。  
  
> [!NOTE]
>  イミディエイト型がジェネリックでない場合、<xref:System.Type.IsGenericType%2A> プロパティは `false` を返します。 たとえば、要素が型 `A<int>` (Visual Basic の`A(Of Integer)`) である配列は、それ自体がジェネリック型ではありません。  
  
 次の表は、一般的なリフレクションで使用される一般的な用語の不変条件をまとめたものです。  
  
|用語|インバリアント|  
|----------|---------------|  
|ジェネリック型定義|<xref:System.Type.IsGenericTypeDefinition%2A> プロパティが `true` です。<br /><br /> ジェネリック型を定義します。 構築された型を作成するには、ジェネリック型定義を表す <xref:System.Type> オブジェクトの <xref:System.Type.MakeGenericType%2A> メソッドを呼び出し、型引数の配列を指定します。<br /><br /> <xref:System.Type.MakeGenericType%2A> は、ジェネリック型の定義でのみ呼び出すことができます。<br /><br /> ジェネリック型定義はジェネリック型です (<xref:System.Type.IsGenericType%2A> プロパティは `true`) が、逆の場合は true になりません。|  
|ジェネリック型|<xref:System.Type.IsGenericType%2A> プロパティが `true` です。<br /><br /> には、ジェネリック型定義、オープン構築型、またはクローズ構築型を指定できます。<br /><br /> 要素型がジェネリックである配列型は、それ自体がジェネリック型ではないことに注意してください。 これは、ジェネリック型へのポインターを表す <xref:System.Type> オブジェクトにも当てはまります。|  
|構築された型を開く|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> 例としては、割り当てられていない型パラメーターを持つジェネリック型、ジェネリック型定義またはオープン構築型で入れ子にされた型、または <xref:System.Type.ContainsGenericParameters%2A> プロパティが `true`型引数を持つジェネリック型があります。<br /><br /> オープン構築型のインスタンスを作成することはできません。<br /><br /> すべてのオープン構築型がジェネリックではないことに注意してください。 たとえば、要素型がジェネリック型定義である配列はジェネリックではなく、オープン構築型へのポインターはジェネリックではありません。|  
|閉じた構築型|<xref:System.Type.ContainsGenericParameters%2A> プロパティが `false` です。<br /><br /> 再帰的に検査するときに、型に割り当てられていないジェネリックパラメーターがありません。|  
|ジェネリック型パラメーター|<xref:System.Type.IsGenericParameter%2A> プロパティが `true` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> プロパティが `true` です。<br /><br /> ジェネリック型定義で、後で割り当てられる型のプレースホルダー。|  
|ジェネリック型引数|には、ジェネリック型パラメーターを含む任意の型を指定できます。<br /><br /> 型引数は、構築されたジェネリック型を作成するときに <xref:System.Type.MakeGenericType%2A> メソッドに渡される <xref:System.Type> オブジェクトの配列として指定されます。 結果の型のインスタンスを作成する場合は、すべての型引数に対して <xref:System.Type.ContainsGenericParameters%2A> プロパティを `false` する必要があります。|  
  
 次のコード例と表は、これらの用語と不変条件の一部を示しています。 `Derived` クラスは、その基本型が型引数リストに型パラメーターと型パラメーターが混在する構築型であるため、特に重要です。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 次の表は、クラス `Base`、`Derived`、および `G`を使用して構築する例を示しています。 C++とC#のコードが同じ場合は、1つのエントリのみが表示されます。  
  
|例|インバリアント|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|この型の場合:<br /><br /> <xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true` です。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|この型の場合:<br /><br /> <xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `true` です。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|変数の型 `d`:<br /><br /> `d` が配列であるため、<xref:System.Type.IsGenericType%2A> が `false`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> は `false` です。|  
|`T`、`U`、`V` (表示されるすべての場所)|<xref:System.Type.IsGenericParameter%2A> は `true` です。<br /><br /> 型パラメーターをジェネリック型に制約する方法がないため、<xref:System.Type.IsGenericType%2A> が `false` ます。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `false` です。<br /><br /> `T`、`U`、および `V` はそれ自体がジェネリック型パラメーターであるため、<xref:System.Type.ContainsGenericParameters%2A> が `true` ます。 これは、後で型引数に代入されるものを意味しません。|  
|フィールドの型 `F`|<xref:System.Type.IsGenericType%2A> は `true` です。<br /><br /> `G`の型パラメーターに型が割り当てられているため、<xref:System.Type.IsGenericTypeDefinition%2A> が `false`。 これは、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出した場合と同じです。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> が `true` のは、フィールド `F` の型に、オープン構築型の型引数があるためです。 構築された型は、その型引数 (つまり、`Base`) がジェネリック型定義であるため、オープンです。 これは、<xref:System.Type.IsGenericType%2A> プロパティの再帰的な性質を示しています。|  
|入れ子になったクラス `Nested`|<xref:System.Type.IsGenericType%2A> は、ジェネリック型に入れ子になっているため、`Nested` クラスに独自のジェネリック型パラメーターがない場合でも `true`ます。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> は `true` です。 つまり、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出して、それを囲む型の型パラメーター `Derived`を指定できます。<br /><br /> 外側の型 (`Derived`) にジェネリック型パラメーターが含まれているため、<xref:System.Type.ContainsGenericParameters%2A> が `true`。 これは、<xref:System.Type.ContainsGenericParameters%2A> プロパティの再帰的な性質を示しています。|  
  
   
  
## Examples  
 次のコード例では、「解説」で説明されている型の <xref:System.Type.IsGenericType%2A>、<xref:System.Type.IsGenericTypeDefinition%2A>、<xref:System.Type.IsGenericParameter%2A>、および <xref:System.Type.ContainsGenericParameters%2A> の各プロパティの値を表示します。 プロパティ値の説明については、「解説」の表を参照してください。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> オブジェクトがジェネリック型定義を表している場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジェネリック型定義は、他の型を構築できるテンプレートです。 たとえば、ジェネリック型定義 `G<T>` (構文でC#表されます。 Visual Basic または `generic <typename T> ref class G` で `G(Of T)` C++)、`G<int>` の型を含むジェネリック引数リストを使用して`G(Of Integer)` メソッドを呼び出すことによって、型 Visual Basic (<xref:System.Type.MakeGenericType%2A> で <xref:System.Int32>) を構築およびインスタンス化できます。 この構築された型を表す <xref:System.Type> オブジェクトがある場合、<xref:System.Type.GetGenericTypeDefinition%2A> メソッドはジェネリック型の定義を再び取得します。  
  
 現在の型から新しい型を作成できるかどうかを判断するには、<xref:System.Type.IsGenericTypeDefinition%2A> プロパティを使用します。 <xref:System.Type.IsGenericTypeDefinition%2A> プロパティが `true`を返す場合、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出して新しいジェネリック型を作成できます。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
   
  
## Examples  
 次の例では、ジェネリック型定義であるかどうかなど、型に関する情報を表示します。 情報は、構築された型、ジェネリック型定義、および通常の型について表示されます。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が、ジェネリック型の定義の型パラメーターを表すかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Type" /> オブジェクトがジェネリック型定義の型パラメーターを表している場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> に <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性が適用されているかどうかを示す (つまり、COM タイプ ライブラリからインポートされたかどうかを示す) 値を取得します。</summary>
        <value><see langword="true" /> が <see cref="T:System.Type" /> を持っている場合は <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値はによって決定され `MyGenericType<T>.`  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">現在の型と比較するオブジェクト。</param>
        <summary>指定したオブジェクトが現在の <see cref="T:System.Type" /> のインスタンスかどうかを判断します。</summary>
        <returns><see langword="true" /> が返されるのは、現在の <see langword="Type" /> が <paramref name="o" /> によって表されるオブジェクトの継承可能な階層内にある場合、または現在の <see langword="Type" /> が <paramref name="o" /> によって実装されているインターフェイスである場合です。 <see langword="false" /> が返されるのは、これらの条件のいずれも満たされない場合、または <paramref name="o" /> が <see langword="null" /> であるか、現在の <see langword="Type" /> がオープン ジェネリック型である (つまり、<see cref="P:System.Type.ContainsGenericParameters" /> が <see langword="true" /> を返す) 場合です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
> [!NOTE]
>  構築された型は、そのジェネリック型定義のインスタンスではありません。 つまり、`MyGenericList<int>` (Visual Basic で`MyGenericList(Of Integer)`) は `MyGenericList<T>` のインスタンス (`MyGenericList(Of T)` では Visual Basic) ではありません。  
  
   
  
## Examples  
 `IsInstanceOfType` メソッドの使用例を次に示します。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がインターフェイスである (つまり値型やクラスではない) ことを示す値を取得します。</summary>
        <value><see langword="true" /> がインターフェイスである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> は、型宣言をクラス、インターフェイス、または値型として識別します。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、インターフェイスを作成し、インターフェイス型を確認して、クラスに `IsInterface` プロパティが設定されているかどうかを示します。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のフィールドが、定義済みまたはメタデータに対して出力された順序で、連続して配置されているかどうかを示す値を取得します。</summary>
        <value>現在の型の <see langword="true" /> プロパティに <see cref="P:System.Type.Attributes" /> が含まれる場合は <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは便宜上提供されています。 または、<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> 列挙値を使用して型レイアウト属性を選択し、<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> が設定されているかどうかをテストすることもできます。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>、および <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> 列挙値は、型のフィールドがどのようにメモリにレイアウトされるかを示します。  
  
 動的な型の場合は、型を作成するときに <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> を指定できます。 コードで、<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 列挙値を使用して <xref:System.Runtime.InteropServices.StructLayoutAttribute> 属性を型に適用し、レイアウトがシーケンシャルであることを指定します。  
  
> [!NOTE]
>  <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドを使用して、<xref:System.Runtime.InteropServices.StructLayoutAttribute> が型に適用されているかどうかを判断することはできません。  
  
 詳細については、共通言語基盤 (CLI) のドキュメント「パーティション II: メタデータの定義とセマンティクス」の9.1.2 のセクションを参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例では、<xref:System.Runtime.InteropServices.StructLayoutAttribute> クラスの <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> 列挙値が設定されているクラスのインスタンスを作成し、<xref:System.Type.IsLayoutSequential%2A> プロパティをチェックして、結果を表示します。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">メタデータと自己言及的なコンポーネント</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、<xref:System.Type> クラスの `IsContextful`、<xref:System.Type.IsMarshalByRef%2A>、および <xref:System.Type.IsPrimitive%2A> の各プロパティを示しています。 このメソッドは、指定された型をコンテキストでホストできるかどうか、参照によってマーシャリングできるかどうか、および型がプリミティブデータ型であるかどうかをチェックします。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsMarshalByRef" /> プロパティを実装し、<see cref="T:System.Type" /> が参照渡しでマーシャリングされるかどうかを判断します。</summary>
        <returns><see langword="true" /> が参照渡しでマーシャリングされる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
   
  
## Examples  
 次の例では、指定された型が参照によってマーシャリングされているかどうかを判断し、その結果を表示します。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> オブジェクトが、別の型の定義内に入れ子になっている定義で定義された型を表しているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が別の型に入れ子になっている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> プロパティは、可視性に関係なく、すべての入れ子にされた型の `true` を返します。 入れ子と表示を同時にテストするには、関連するプロパティ <xref:System.Type.IsNestedAssembly%2A>、<xref:System.Type.IsNestedFamily%2A>、<xref:System.Type.IsNestedFamANDAssem%2A>、<xref:System.Type.IsNestedFamORAssem%2A>、<xref:System.Type.IsNestedPrivate%2A>、または <xref:System.Type.IsNestedPublic%2A>を使用します。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> 列挙体メンバーは、型の可視性属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。 次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するアセンブリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。 次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するファミリとアセンブリの両方に属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。  
  
> [!NOTE]
>  およびC# Visual Basic 言語には、独自のアセンブリ内の保護された型に対してのみ表示される入れ子になった型を定義できるセマンティクスは含まれていません。 で可視性C#を `protected internal` し、Visual Basic で可視性を `Protected Friend` して、同じアセンブリ内の保護された型と型の両方に表示される入れ子になった型を定義します。  
  
 <xref:System.Type> オブジェクトのファミリは、同じ <xref:System.Type> とそのサブタイプのすべてのオブジェクトとして定義されます。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。 次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するファミリ内でだけ参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。  
  
 <xref:System.Type> オブジェクトのファミリは、完全に同じ <xref:System.Type> とそのサブタイプのすべてのオブジェクトとして定義されます。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。 次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、それ自体が属するファミリまたはアセンブリのいずれかに属しているクラスだけから参照可能な場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型の可視性がC#または Visual Basic の `Protected Friend` `protected internal` 場合、<xref:System.Type.IsNestedFamORAssem%2A> プロパティは `true`を返します。  
  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。  
  
 <xref:System.Type> オブジェクトのファミリは、完全に同じ <xref:System.Type> とそのサブタイプのすべてのオブジェクトとして定義されます。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。 次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が入れ子になっていて、プライベートとして宣言されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が入れ子になっていて、プライベートとして宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。 次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クラスが入れ子になっていて、パブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value>クラスが入れ子になっていて、パブリックとして宣言されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。  
  
   
  
## Examples  
 次の例では、さまざまな種類の可視性を持つ入れ子になったクラスを多数持つ外部クラスを作成します。 次に、親の型と入れ子になった各型について、いくつかの可視性に関連する <xref:System.Type> プロパティの値を取得します。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がパブリックとして宣言されていないかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がパブリックとして宣言されていなくて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、入れ子にされた型では使用しないでください。代わりに、<xref:System.Type.IsNestedPublic%2A> プロパティを使用してください。  
  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは `false`を返します。  
  
   
  
## Examples  
 この例では、`IsNotPublic` プロパティを使用して、型の可視性を取得します。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 次のコード例は、入れ子になったクラスに `IsPublic` と `IsNotPublic` を使用できない理由を示しています。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 入れ子になったクラスの場合は、`IsPublic` と `IsNotPublic` の結果を無視し、`IsNestedPublic` と `IsNestedPrivate`の結果のみに注意してください。 このコード片のリフレクション出力は次のようになります。  
  
|インスタンス|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|FALSE|TRUE|FALSE|FALSE|  
|B|FALSE|FALSE|TRUE|FALSE|  
|C|FALSE|FALSE|FALSE|TRUE|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public virtual bool IsPointer { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPointer As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsPointer { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がポインターかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例は、`IsPointer` プロパティの使用方法を示しています。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPointer" /> プロパティを実装し、<see cref="T:System.Type" /> がポインターかどうかを判断します。</summary>
        <returns><see langword="true" /> がポインターである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プリミティブ型は、<xref:System.Boolean>、<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>、<xref:System.IntPtr>、<xref:System.UIntPtr>、<xref:System.Char>、<xref:System.Double>、<xref:System.Single>です。  
  
 現在の <xref:System.Type> がジェネリック型、またはジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例は、<xref:System.Type> クラスの `IsContextful`、<xref:System.Type.IsMarshalByRef%2A>、および <xref:System.Type.IsPrimitive%2A> の各プロパティを示しています。 このメソッドは、指定された型をコンテキストでホストできるかどうか、参照によってマーシャリングできるかどうか、および型がプリミティブデータ型であるかどうかをチェックします。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスによってオーバーライドされるときに、<see cref="P:System.Type.IsPrimitive" /> プロパティを実装し、<see cref="T:System.Type" /> がプリミティブ型の 1 つかどうかを判断します。</summary>
        <returns><see langword="true" /> がプリミティブ型の 1 つである場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プリミティブ型は、<xref:System.Boolean>、<xref:System.Byte>、<xref:System.SByte>、<xref:System.Int16>、<xref:System.UInt16>、<xref:System.Int32>、<xref:System.UInt32>、<xref:System.Int64>、<xref:System.UInt64>、<xref:System.Char>、<xref:System.Double>、および <xref:System.Single>です。  
  
   
  
## Examples  
 次の例では、指定された型がプリミティブ型であるかどうかを判断し、結果を表示します。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> がパブリックとして宣言されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> がパブリックとして宣言されていて、入れ子にされた型でない場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入れ子になった型では使用しないでください。代わりに <xref:System.Type.IsNestedPublic%2A> を使用してください。  
  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは `true`を返します。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> 表示属性を選択します。  
  
   
  
## Examples  
 次の例では、`MyTestClass`のインスタンスを作成し、`IsPublic` プロパティをチェックして、結果を表示します。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 入れ子になったクラスの場合は、`IsPublic` と `IsNotPublic` の結果を無視し、<xref:System.Type.IsNestedPublic%2A> と <xref:System.Type.IsNestedPrivate%2A>の結果のみに注意してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が sealed として宣言されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が sealed として宣言されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> がジェネリック型の型パラメーターを表している場合、このプロパティは常に `true`を返します。  
  
   
  
## Examples  
 次の例では、`sealed` クラスのインスタンスを作成し、`IsSealed` プロパティをチェックして、結果を表示します。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルでセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型が透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>、および <xref:System.Type.IsSecurityTransparent%2A> の各プロパティは、共通言語ランタイム (CLR) によって決定された、現在の信頼レベルでの型の透明度レベルを報告します。 これらのプロパティの組み合わせを次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重要|`true`|`false`|`false`|  
|安全クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分信頼アセンブリの場合、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリが部分的に信頼されたアプリケーションドメイン (たとえば、サンドボックス化されたアプリケーションドメイン) に読み込まれる場合、ランタイムはアセンブリのセキュリティ注釈を無視します。 アセンブリとそのすべての型は透過的として扱われます。 ランタイムは、アセンブリが完全に信頼されたアプリケーションドメイン (たとえば、デスクトップアプリケーションの既定のアプリケーションドメイン) に読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意します。 これに対し、信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前のアセンブリ) は、アプリケーションドメインの信頼レベルに関係なく、常に完全信頼で読み込まれます。したがって、現在の信頼レベルは常に完全に信頼されます。 アセンブリとアプリケーションドメインの現在の信頼レベルを確認するには、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> の各プロパティを使用します。  
  
 リフレクションと透明度の詳細については、「[リフレクションのセキュリティに関する考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)」を参照してください。 透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework におけるセキュリティの変更点</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>現在の型が現在の信頼レベルでセキュリティ セーフ クリティカルである場合は <see langword="true" />。現在の型がセキュリティ クリティカルまたは透過的な場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>、および <xref:System.Type.IsSecurityTransparent%2A> の各プロパティは、共通言語ランタイム (CLR) によって決定された、現在の信頼レベルでの型の透明度レベルを報告します。 これらのプロパティの組み合わせを次の表に示します。  
  
|セキュリティ レベル|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|重要|`true`|`false`|`false`|  
|安全クリティカル|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分信頼アセンブリの場合、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリが部分的に信頼されたアプリケーションドメイン (たとえば、サンドボックス化されたアプリケーションドメイン) に読み込まれる場合、ランタイムはアセンブリのセキュリティ注釈を無視します。 アセンブリとそのすべての型は透過的として扱われます。 ランタイムは、アセンブリが完全に信頼されたアプリケーションドメイン (たとえば、デスクトップアプリケーションの既定のアプリケーションドメイン) に読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意します。 これに対し、信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前のアセンブリ) は、アプリケーションドメインの信頼レベルに関係なく、常に完全信頼で読み込まれます。したがって、現在の信頼レベルは常に完全に信頼されます。 アセンブリとアプリケーションドメインの現在の信頼レベルを確認するには、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> の各プロパティを使用します。  
  
 リフレクションと透明度の詳細については、「[リフレクションのセキュリティに関する考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)」を参照してください。 透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework におけるセキュリティの変更点</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型が現在の信頼レベルで透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</summary>
        <value>型が現在の信頼レベルで透過的セキュリティであるかどうかを <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが `true`を返す場合、<xref:System.Type.IsSecurityCritical%2A> プロパティと <xref:System.Type.IsSecuritySafeCritical%2A> プロパティは `false`を返します。  
  
 <xref:System.Type.IsSecurityCritical%2A>、<xref:System.Type.IsSecuritySafeCritical%2A>、および <xref:System.Type.IsSecurityTransparent%2A> の各プロパティは、共通言語ランタイム (CLR) によって決定された、現在の信頼レベルでの型の透明度レベルを報告します。 これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。  
  
> [!IMPORTANT]
>  部分信頼アセンブリの場合、このプロパティの値は、アセンブリの現在の信頼レベルによって異なります。 アセンブリが部分的に信頼されたアプリケーションドメイン (たとえば、サンドボックス化されたアプリケーションドメイン) に読み込まれる場合、ランタイムはアセンブリのセキュリティ注釈を無視します。 アセンブリとそのすべての型は透過的として扱われます。 ランタイムは、アセンブリが完全に信頼されたアプリケーションドメイン (たとえば、デスクトップアプリケーションの既定のアプリケーションドメイン) に読み込まれた場合にのみ、部分信頼アセンブリのセキュリティの注釈に注意します。 これに対し、信頼されたアセンブリ (グローバルアセンブリキャッシュにインストールされる厳密な名前のアセンブリ) は、アプリケーションドメインの信頼レベルに関係なく、常に完全信頼で読み込まれます。したがって、現在の信頼レベルは常に完全に信頼されます。 アセンブリとアプリケーションドメインの現在の信頼レベルを確認するには、<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> と <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> の各プロパティを使用します。  
  
 リフレクションと透明度の詳細については、「[リフレクションのセキュリティに関する考慮事項](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)」を参照してください。 透明度の詳細については、「[セキュリティの変更](~/docs/framework/security/security-changes.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">リフレクションに関するセキュリティ上の考慮事項</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework におけるセキュリティの変更点</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSerializable { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> をシリアル化できるかどうかを示す値を取得します。</summary>
        <value><see langword="true" /> をシリアル化できる場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
.NET Standard で定義されている型は、<xref:System.SerializableAttribute>でマークされていません。 代わりに、各 .NET 実装で、型をシリアル化できるかどうかが決定されます。 実行時には、<xref:System.Type.IsSerializable%2A> プロパティを使用して、その実装が型のインスタンスのシリアル化をサポートしているかどうかを判断できます。 詳細と例については、「 [.NET Standard オブジェクトがシリアル化可能かどうかを判断する方法](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)」を参照してください。
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
   
  
## Examples  
 次の例では、`MyTestClass` クラスのインスタンスを作成し、[Serializable] 属性を設定し、`true` または `false`の `IsSerializable` プロパティをチェックします。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が署名型かどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Type" /> が署名の種類である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
シグネチャ型は制限付きの型であり、<xref:System.Type.GetMethod%2A> メソッドに渡すことができますが、その他のリフレクション機能のほとんどはサポートしていません。 たとえば、<xref:System.Type.MakeGenericMethodParameter%2A> メソッドを呼び出すことによって、ジェネリックメソッドのパラメーターに対応する署名の種類のインスタンスを取得できます。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が特別な処理を必要とする名前を持っているかどうかを示す値を取得します。</summary>
        <value>型の名前が特別な処理を必要とする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前の先頭にアンダースコア文字 (_)、プロパティアクセサー、および演算子のオーバーロードメソッドが含まれている場合は、一部のコンパイラで特別な処理が必要となる可能性がある型の例です。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">現在の型と比較する型。</param>
        <summary>現在の <see cref="T:System.Type" /> が、指定した <see cref="T:System.Type" /> から派生しているかどうかを判断します。</summary>
        <returns>現在の <see langword="Type" /> が <paramref name="c" /> から派生している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 <see langword="false" /> と現在の <paramref name="c" /> とが等価の場合も、このメソッドは <see langword="Type" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSubclassOf%2A> メソッドを呼び出して、次のいずれかを決定できます。  
  
-   あるクラスが別のクラスから派生しているかどうか。  
  
-   型が <xref:System.ValueType>から派生しているかどうか。 ただし、<xref:System.Type.IsValueType%2A> は、型が値型であるかどうかを判断するより効率的な方法です。  
  
-   型が <xref:System.Enum>から派生しているかどうか。 ただし、<xref:System.Type.IsEnum%2A> メソッドは、型が列挙型であるかどうかを判断するより効率的な方法です。  
  
-   型がデリゲートであるかどうか、つまり、<xref:System.Delegate> または <xref:System.MulticastDelegate>のどちらから派生するかを示します。  
  
 <xref:System.Type.IsSubclassOf%2A> メソッドを使用して、インターフェイスが別のインターフェイスから派生しているかどうか、またはクラスがインターフェイスを実装しているかどうかを判断することはできません。 次の例に示すように、その目的には <xref:System.Type.IsAssignableFrom%2A> メソッドを使用します。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合は、クラス制約を継承するか、クラス制約がない場合は <xref:System.Object?displayProperty=nameWithType> から派生します。  
  
> [!NOTE]
>  インターフェイスと共に使用する場合を除き、<xref:System.Type.IsSubclassOf%2A> は <xref:System.Type.IsAssignableFrom%2A>の逆です。 つまり、`t1.IsSubclassOf(t2)` が `true`場合、`t2.IsAssignableFrom(t1)` も `true`ます。  
  
 このメソッドは、派生クラスによってオーバーライドできます。  
  
   
  
## Examples  
 次の例では、`Class1` という名前のクラスと、`DerivedC1`という名前の派生クラスを作成します。 <xref:System.Type.IsSubclassOf%2A> メソッドを呼び出して、`DerivedC1` が `Class1`のサブクラスであることを示します。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> が <see langword="null" /> です。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が、下限が 0 の 1 次元配列のみを表すことができる配列型であるかどうかを示す値を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> が、下限がゼロの1次元配列のみを表すことができる配列型である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が型定義かどうかを示す値を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> が型定義である場合は <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> インスタンスは、他の型に基づいて要求時に構築される型とは対照的に、アセンブリで直接定義された型を表す型定義です。 たとえば、プリミティブ型、クラス、構造体、ジェネリック型の定義は型定義ですが、配列、参照、ポインター、またはインスタンス化されたジェネリック型は使用できません。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="UnicodeClass" /> に、文字列書式属性として <see cref="T:System.Type" /> が選択されているかどうかを示す値を取得します。</summary>
        <value><see langword="true" />に、文字列書式属性として<see langword="UnicodeClass" /> が選択されている場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> は、文字列形式の属性を選択するために使用されます。 文字列形式属性は、文字列の解釈方法を定義することで相互運用性を強化します。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に `false`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> が値型かどうかを示す値を取得します。</summary>
        <value><see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値型は、ビットのシーケンスとして表現される型です。値型はクラスまたはインターフェイスではありません。 値型は、一部のプログラミング言語では "struct" と呼ばれます。 列挙型は、値型の特殊なケースです。  
  
 このプロパティは、<xref:System.ValueType> が値型ではないため、<xref:System.ValueType> クラスの `false` を返します。 これはすべての値型の基底クラスであるため、任意の値型を割り当てることができます。 これは、<xref:System.ValueType> 自体が値型の場合はできません。 値型は <xref:System.ValueType>型のフィールドに割り当てられるときにボックス化されます。  
  
 このプロパティは、列挙に対して `true` を返しますが、<xref:System.Enum> 型自体にはを返しません。 この動作を示す例については、「<xref:System.Type.IsEnum%2A>」を参照してください。  
  
 このプロパティは読み取り専用です。  
  
   
  
## Examples  
 次の例では、`MyEnum`型の変数を作成し、`IsValueType` プロパティをチェックして、結果を表示します。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Type.IsValueType" /> プロパティを実装するとともに、<see cref="T:System.Type" /> が値型である (つまり、クラスやインターフェイスでない) かどうかを判断します。</summary>
        <returns><see langword="true" /> が値型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、代替型システムの実装を可能にするために用意されています。 通常、アプリケーションコードでは使用されません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型が多次元配列を表すことができるか、任意の下限を持つ 1 つの配列を表すことができる配列型であるかどうかを示す値を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> が多次元配列または任意の下限を持つ配列を表すことのできる配列型である場合に <see langword="true" /> します。それ以外の場合は、<see langword="false" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
このプロパティの値が配列型に `true` 場合は、任意の下限を持つ1次元配列または多次元配列インスタンスを作成するために使用できます。 それ以外の場合、配列型は、下限が0の1次元配列のインスタンスを作成するためにのみ使用できます。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> にアセンブリの外側のコードからアクセスできるかどうかを示す値を取得します。</summary>
        <value>現在の<see langword="true" /> がパブリック型である場合、またはすべての包含する型がパブリックであるような入れ子にされたパブリック型である場合は <see cref="T:System.Type" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、型がコンポーネントアセンブリのパブリックインターフェイスの一部であるかどうかを判断します。  
  
   
  
## Examples  
 次のコード例では、2つのクラスをテストします。そのうちの1つのみがアセンブリの外部で参照できます。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>下限を 0 に設定して現在の型の 1 次元配列を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> メソッドは、実行時に要素型が計算される配列型を生成する方法を提供します。  
  
 **メモ**共通言語ランタイムは、ベクター (つまり、常に0から始まる1次元配列) と多次元配列を区別します。 常に1つの次元のみを持つベクターは、次元が1つしかない多次元配列と同じではありません。 このメソッドオーバーロードはベクター型の作成にのみ使用でき、ベクター型を作成する唯一の方法です。 多次元配列型を作成するには、<xref:System.Type.MakeArrayType%28System.Int32%29> メソッドオーバーロードを使用します。  
  
   
  
## Examples  
 次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" />です。  
  
- または - 
現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType (int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType(int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank">配列の次元数。 この数値は 32 以下である必要があります。</param>
        <summary>次元数を指定して現在の型の配列を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>次元数を指定して現在の型の配列を表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> メソッドは、実行時に要素型が計算される配列型を生成する方法を提供します。  
  
> [!NOTE]
>  共通言語ランタイムは、ベクター (つまり、常に0から始まる1次元配列) と多次元配列を区別します。 常に1つの次元のみを持つベクターは、次元が1つしかない多次元配列と同じではありません。 このメソッドオーバーロードを使用してベクター型を作成することはできません。`rank` が1の場合、このメソッドオーバーロードは、1つの次元を持つ多次元配列型を返します。 ベクター型を作成するには、<xref:System.Type.MakeArrayType> メソッドオーバーロードを使用します。  
  
   
  
## Examples  
 次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> が無効です。 たとえば、0 または負の値です。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
- または - 
現在の型は <see langword="ByRef" /> 型です。 つまり、 <see cref="P:System.Type.IsByRef" /> は <see langword="true" />を返します。  
  
- または - 
 <paramref name="rank" /> が 32 を超えています。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public abstract Type MakeByRefType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeByRefType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeByRefType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns><see langword="ref" /> パラメーター (Visual Basic の場合は <see langword="ByRef" /> パラメーター) として渡されるときに現在の型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A> メソッドを使用すると、パラメーターリストの `ref` 型 (Visual Basic に`ByRef`) を生成することができます。  
  
 Microsoft 中間言語 (MSIL) の構文を使用して、現在の <xref:System.Type> オブジェクトが <xref:System.Int32>を表している場合、このメソッドは `Int32&`を表す <xref:System.Type> オブジェクトを返します。  
  
   
  
## Examples  
 次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
- または - 
現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">型指定されたパラメーターの位置。</param>
        <summary>ジェネリック パラメーター参照を表すために、<see cref="Overload:System.Type.GetMethod" /> メソッドの <c>Type []</c> 配列パラメーターに渡すことができる署名型オブジェクトを返します。</summary>
        <returns>ジェネリック パラメーター参照を表すために、<see cref="Overload:System.Type.GetMethod" /> メソッドの <c>Type []</c> 配列パラメーターに渡すことができる署名型オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> が負の値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">ジェネリック型定義。</param>
        <param name="typeArguments">型引数の配列。</param>
        <summary>型メンバーの問い合わせで署名の型の利用を完全にサポートするための Reflection の再実装をサードパーティに許可するジェネリック署名の型を作成します。</summary>
        <returns>ジェネリック署名の型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public abstract Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">現在のジェネリック型の型パラメーターに置き換えられる型の配列。</param>
        <summary>型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns><paramref name="typeArguments" /> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A> メソッドを使用すると、特定の型をジェネリック型定義の型パラメーターに割り当て、特定の構築型を表す <xref:System.Type> オブジェクトを作成するコードを記述できます。 この <xref:System.Type> オブジェクトを使用して、構築された型のランタイムインスタンスを作成できます。  
  
 <xref:System.Type.MakeGenericType%2A> で構築された型は開くことができます。つまり、一部の型引数は、それを囲むジェネリックメソッドまたは型の型パラメーターにすることができます。 動的アセンブリを出力するときに、このようなオープン構築型を使用することもできます。 たとえば、次のコードでは、クラス `Base` と `Derived` を考えてみます。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 動的アセンブリ内の `Derived` を生成するには、その基本型を構築する必要があります。 これを行うには、クラス `Base`を表す <xref:System.Type> オブジェクトの <xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。これには、ジェネリック型引数 <xref:System.Int32> および `V` からの型パラメーター `Derived`を使用します。 型とジェネリック型パラメーターはどちらも <xref:System.Type> オブジェクトによって表されるため、両方を含む配列を <xref:System.Type.MakeGenericType%2A> メソッドに渡すことができます。  
  
> [!NOTE]
>  `Base<int, V>` などの構築された型は、コードを出力するときに便利ですが、ジェネリック型定義ではないため、この型の <xref:System.Type.MakeGenericType%2A> メソッドを呼び出すことはできません。 インスタンス化できる閉じた構築型を作成するには、まず <xref:System.Type.GetGenericTypeDefinition%2A> メソッドを呼び出して、ジェネリック型定義を表す <xref:System.Type> オブジェクトを取得し、必要な型引数を指定して <xref:System.Type.MakeGenericType%2A> を呼び出します。  
  
 <xref:System.Type.MakeGenericType%2A> によって返される <xref:System.Type> オブジェクトは、結果の構築型の <xref:System.Object.GetType%2A> メソッドを呼び出すことによって取得される <xref:System.Type> と同じか、同じ型引数を使用して同じジェネリック型定義から作成された任意の構築型の <xref:System.Object.GetType%2A> メソッドと同じです。  
  
> [!NOTE]
>  ジェネリック型の配列は、それ自体がジェネリック型ではありません。 `C<T>[]` (Visual Basic の`Dim ac() As C(Of T)`) などの配列型で <xref:System.Type.MakeGenericType%2A> を呼び出すことはできません。 クローズジェネリック型を `C<T>[]`から構築するには、<xref:System.Type.GetElementType%2A> を呼び出して、ジェネリック型の定義 `C<T>`を取得します。ジェネリック型定義の <xref:System.Type.MakeGenericType%2A> を呼び出して、構築された型を作成します。最後に、構築された型の <xref:System.Type.MakeArrayType%2A> メソッドを呼び出して、配列型を作成します。 ポインター型と `ref` 型 (Visual Basic の`ByRef`) にも同じことが当てはまります。  
  
 ジェネリック リフレクションで使用する用語に関する一定の条件の一覧については、<xref:System.Type.IsGenericType%2A> プロパティの解説を参照してください。  
  
## <a name="nested-types"></a>Nested Types  
 ジェネリック型が、 C# C++、または Visual Basic を使用して定義されている場合、その入れ子にされた型はすべてジェネリックになります。 これは、入れ子にされた型が独自の型パラメーターを持たない場合でも当てはまります。これは、3つのすべての言語に、入れ子にされた型の型パラメーターリストに含まれる型の型パラメーターが含まれているためです。 次のクラスについて考えてみます。  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 入れ子になったクラス `Inner` の型パラメーターリストには、`T` と `U`の2つの型パラメーターがあります。1つ目は、外側のクラスの型パラメーターです。 同様に、入れ子になったクラスの型パラメーターリスト `Innermost1` には、`T`、`U`、および `V`の3つの型パラメーターがあり、その外側のクラスからの `T` と `U` があります。 入れ子になったクラス `Innermost2` には、`T` と `U`の2つの型パラメーターがあります。これらは、外側のクラスから取得されます。  
  
 外側の型のパラメーターリストに複数の型パラメーターがある場合は、すべての型パラメーターが入れ子になった型の型パラメーターリストに含まれます。  
  
 入れ子になった型のジェネリック型の定義からジェネリック型を構築するには、外側のすべての型の型引数配列を連結して、最も外側のジェネリック型から始まり、入れ子になった型自体の型引数配列で終了する (独自の型パラメーターがある場合) ことによって、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。 `Innermost1`のインスタンスを作成するには、T、U、V に割り当てられる3つの型を含む配列を使用して、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。`Innermost2`のインスタンスを作成するには、T と U に割り当てられる2つの型を含む配列を使用して、<xref:System.Type.MakeGenericType%2A> メソッドを呼び出します。  
  
 これらの言語は、外側の型の型パラメーターを使用して入れ子になった型のフィールドを定義できるように、それを囲む型の型パラメーターをこの方法で反映します。 それ以外の場合、型パラメーターは入れ子にされた型の本体内のスコープ内にありません。 動的アセンブリまたは[Ilasm (IL アセンブラー)](~/docs/framework/tools/ilasm-exe-il-assembler.md)を使用して、外側の型の型パラメーターを伝達せずに入れ子にされた型を定義することができます。 次の MSIL アセンブラーのコードについて考えてみましょう。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 この例では、型パラメーターがスコープに含まれていないため、クラス `Innermost`で `T` 型または `U` 型のフィールドを定義することはできません。 次のアセンブラコードでは、、Visual Basic、およびC++ C#で定義されている場合に動作するように、入れ子になったクラスを定義しています。  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 [Ildasm.exe (IL 逆アセンブラー)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)を使用して、高レベル言語で定義されている入れ子になったクラスを確認し、この名前付けスキームを観察できます。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.MakeGenericType%2A> メソッドを使用して、<xref:System.Collections.Generic.Dictionary%602> 型のジェネリック型定義から構築された型を作成します。 構築された型は、文字列キーを持つ `Test` オブジェクトの <xref:System.Collections.Generic.Dictionary%602> を表します。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在の型はジェネリック型の定義を表していません。 つまり、<see cref="P:System.Type.IsGenericTypeDefinition" /> は <see langword="false" /> を返します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> が <see langword="null" /> です。  
  
- または - 
<paramref name="typeArguments" /> のどの要素も <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeArguments" /> 内の要素数は現在のジェネリック型定義の型パラメーター数と同じではありません。  
  
- または - 
<paramref name="typeArguments" /> のいずれかの要素が、現在のジェネリック型の対応する型パラメーターに指定された制約を満たしていません。  
  
- または - 
 <paramref name="typeArguments" /> には、ポインター型 (<see cref="P:System.Type.IsPointer" /> は <see langword="true" /> を返します)、参照渡し型 (<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します)、または <see cref="T:System.Void" /> である要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。 派生クラスには実装を指定しなければなりません。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">リフレクションとジェネリック型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">方法 : リフレクションを使用してジェネリック型をチェックおよびインスタンス化する</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public abstract Type MakePointerType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakePointerType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakePointerType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクトを返します。</summary>
        <returns>現在の型へのポインターを表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> メソッドは、パラメーターリストのポインター型を生成する方法を提供します。  
  
 Microsoft 中間言語 (MSIL) の構文を使用して、現在の <xref:System.Type> オブジェクトが <xref:System.Int32>を表している場合、このメソッドは `Int32*`を表す <xref:System.Type> オブジェクトを返します。  
  
   
  
## Examples  
 次のコード例では、配列、`ref` (`ByRef` Visual Basic)、および `Test` クラスのポインター型を作成します。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <exception cref="T:System.TypeLoadException">現在の型は <see cref="T:System.TypedReference" /> です。  
  
- または - 
現在の型は <see langword="ByRef" /> 型です。 つまり、<see cref="P:System.Type.IsByRef" /> は <see langword="true" /> を返します。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値を取得します。</summary>
        <value>このメンバーが型であるか、または入れ子にされた型であるかを示す <see cref="T:System.Reflection.MemberTypes" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>をオーバーライドします。 したがって、<xref:System.Type.GetMembers%2A> によって返される配列などの <xref:System.Reflection.MemberInfo> オブジェクトのセットを調べると、指定されたメンバーが入れ子になった型である場合、<xref:System.Reflection.MemberInfo.MemberType%2A> プロパティによって <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> が返されます。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、型が構築された元のジェネリック型定義に適用されます。 たとえば、現在の <xref:System.Type> が `MyGenericType<int>` (Visual Basic で`MyGenericType(Of Integer)`) を表している場合、このプロパティの値は `MyGenericType<T>`によって決まります。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは常に <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>を返します。  
  
   
  
## Examples  
 次のコード例では、`GetMember` メソッドのパラメーターとして `MemberType` フィールドを示します。  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> 情報に不足している値を表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーターの既定値を取得するには、リフレクションを使用した呼び出しに `Missing` フィールドを使用します。 パラメーター値に `Missing` フィールドが渡され、そのパラメーターに既定値がない場合は、<xref:System.ArgumentException> がスローされます。  
  
   
  
## Examples  
 次のコード例では、`Missing` フィールドを使用して、既定の引数を持つメソッドを呼び出す方法を示します。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 このコードを実行すると、次の出力が生成されます。  
  
 a = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 a = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> が定義されているモジュール (DLL) を取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> が定義されているモジュールです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義が定義されているモジュールを返します。 たとえば、`MyGenericStack<int>`のインスタンスを作成した場合、構築された型の <xref:System.Type.Module%2A> プロパティは `MyGenericStack<T>` が定義されているモジュールを返します。  
  
 同様に、現在の <xref:System.Type> がジェネリックパラメーター `T`を表している場合、このプロパティは `T`を定義するジェネリック型を含むアセンブリを返します。  
  
   
  
## Examples  
 次の例は、<xref:System.Type.Namespace%2A> と `Module` のプロパティと <xref:System.Type>の <xref:System.Type.ToString%2A> メソッドの使用方法を示しています。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされると、現在の型の名前を取得します。</summary>
        <value>現在の型の名前。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Type" /> の名前空間を取得します。</summary>
        <value><see cref="T:System.Type" /> の名前空間。現在のインスタンスに名前空間がない場合、または現在のインスタンスがジェネリック パラメーターを表す場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前空間は論理的なデザイン時の名前付けの便宜です。主にアプリケーションでスコープを定義し、1つの階層構造でクラスやその他の型を整理するために使用されます。 ランタイムの視点から見ると、名前空間はありません。  
  
 現在の <xref:System.Type> が構築ジェネリック型を表している場合、このプロパティは、ジェネリック型定義を含む名前空間を返します。 同様に、現在の <xref:System.Type> がジェネリックパラメーター `T`を表している場合、このプロパティは `T`を定義するジェネリック型定義を含む名前空間を返します。  
  
 現在の <xref:System.Type> オブジェクトがジェネリックパラメーターを表している場合、このプロパティは `null`を返します。  
  
   
  
## Examples  
 次の例は、`Namespace` と <xref:System.Type.Module%2A> のプロパティと <xref:System.Type>の <xref:System.Type.ToString%2A> メソッドの使用方法を示しています。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Type" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns><see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーを取得するために使用したクラス オブジェクトを取得します。</summary>
        <value>この <see langword="Type" /> オブジェクトを取得するために使用した <see cref="T:System.Type" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> オブジェクトの場合、このプロパティの値は常に <xref:System.Type.DeclaringType%2A> プロパティの値と同じになります。  
  
   
  
## Examples  
 この例では、入れ子になったクラスのリフレクションされた型を表示します。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">取得する <see cref="T:System.Type" /> のアセンブリ修飾名。</param>
        <param name="throwIfNotFound">型が見つからない場合に<see langword="true" /> をスローするには <see cref="T:System.TypeLoadException" /> 。型が見つからない場合に <see langword="false" /> を返すには <see langword="null" /> 。 また、 <see langword="false" /> を指定すると、一部の例外条件は抑制されますが、すべての例外が抑制されるわけではありません。 「例外」セクションを参照してください。</param>
        <param name="ignoreCase">大文字と小文字を区別せずに <paramref name="typeName" /> の検索を実行するには <see langword="true" />。大文字と小文字を区別して <paramref name="typeName" /> の検索を実行するには <see langword="false" />。</param>
        <summary>大文字と小文字を区別する検索を実行し、型が見つからない場合に例外をスローするかどうかを指定して、指定した名前の <see cref="T:System.Type" /> を取得します。 型は実行ではなくリフレクションのためだけに読み込まれます。</summary>
        <returns>存在する場合は、指定した名前を持つ型。それ以外の場合は <see langword="null" />。 型が見つからない場合、<paramref name="throwIfNotFound" /> パラメーターで <see langword="null" /> を返すか例外をスローするかを指定します。 一部の場合は、<paramref name="throwIfNotFound" /> の値に関係なく、例外がスローされます。 「例外」を参照してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型を含むアセンブリがリフレクションのみのコンテキストにまだ読み込まれていない場合、<xref:System.Type.ReflectionOnlyGetType%2A> メソッドを使用することは、最初にリフレクションのためにアセンブリを読み込み、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> メソッドを使用して、アセンブリの <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> メソッドを呼び出すことによって型を読み込むことと同じです。 アセンブリ修飾名の詳細については、「<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> プロパティ」を参照してください。 型名の指定の詳細については、<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> メソッドのオーバーロードに関する説明を参照してください。  
  
 アセンブリが実行のために既に読み込まれている場合は、別のコピーがリフレクションのみのコンテキストに読み込まれます。  
  
 `throwIfNotFound` パラメーターは、型が見つからない場合の動作を指定します。また、「例外」セクションで説明されているように、他の特定の例外条件も抑制します。 `throwIfNotFound`の値に関係なく、一部の例外がスローされます。 たとえば、アセンブリが有効でない場合、`throwIfNotFound` が `false`場合でも、<xref:System.BadImageFormatException> がスローされます。  
  
 リフレクションのみのコンテキストの使用方法の詳細については、「[方法: リフレクションのみのコンテキストにアセンブリを読み込む](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。型が見つかりません。  
  
- または - 
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。 <paramref name="typeName" /> に埋め込まれたタブなどの正しくない文字が含まれています。 
- または - 
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。 <paramref name="typeName" /> は空の文字列です。  
  
- または - 
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。 <paramref name="typeName" /> は無効なサイズの配列型を表します。  
  
- または - 
 <paramref name="typeName" /> が <see cref="T:System.TypedReference" /> オブジェクトの配列を表しています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> にはアセンブリ名は含まれません。  
  
- または - 
 <paramref name="throwIfNotFound" /> が <see langword="true" /> です。 <paramref name="typeName" /> に正しくない構文 ("MyType[,*,]" など) が含まれています。  
  
- または - 
 <paramref name="typeName" /> が、型引数の 1 つとしてポインター型、 <see langword="ByRef" /> 型、または <see cref="T:System.Void" /> を持つジェネリック型を表しています。  
  
- または - 
 <paramref name="typeName" /> は型引数の数が正しくないジェネリック型を表します。  
  
- または - 
 <paramref name="typeName" /> がジェネリック型を表し、型引数のいずれかが、対応する型パラメーターの制約を満たしていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> が <see langword="true" /> です。アセンブリ、またはその依存関係のうちの 1 つが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">アセンブリまたはその依存関係のうちの 1 つが見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">アセンブリまたはその依存関係のうちの 1 つが正しくありません。  
  
 - または -  
  
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、アセンブリがコンパイルされました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">方法 : リフレクションのみのコンテキストにアセンブリを読み込む</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の型のレイアウトを説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</summary>
        <value>現在の型のレイアウト機能全体を説明する <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> を取得します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> は <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> メソッドによって返されません。 代わりに、このプロパティを使用して取得します。  
  
   
  
## Examples  
 次のコード例では、まず、特別なレイアウト属性を持つクラス、構造体、および構造体を定義します (構造体はクラス内で入れ子になっています)。 この例では、<xref:System.Type.StructLayoutAttribute%2A> プロパティを使用して、各型の <xref:System.Runtime.InteropServices.StructLayoutAttribute> を取得し、属性のプロパティを表示します。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">呼び出されたメソッドは基底クラスでサポートされていません。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 `IDispatch::GetIDsOfNames`の詳細については、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインター。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 `IDispatch::GetTypeInfo`の詳細については、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 `IDispatch::GetTypeInfoCount`の詳細については、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 `IDispatch::Invoke`の詳細については、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see langword="String" /> の名前を表す <see langword="Type" /> を返します。</summary>
        <returns>現在の <see cref="T:System.String" /> の名前を表す <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、すべてのプリミティブ型の完全修飾共通言語ランタイム名前空間と名前を返します。 たとえば、命令のC#場合、`(long)0.Type().ToString()` は単に "int64" ではなく "system.string" を返します。  
  
 現在の <xref:System.Type> がジェネリック型を表している場合、型とその型引数は、名前空間と入れ子になった型によって修飾されますが、アセンブリによって修飾されることはありません。 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このメソッドは型パラメーターの非修飾名を返します。  
  
   
  
## Examples  
 次の例は、<xref:System.Type.Namespace%2A> と <xref:System.Type.Module%2A> のプロパティと <xref:System.Type>の `ToString` メソッドの使用方法を示しています。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 次の例では、<xref:System.Type.ToString%2A> メソッドによって返される文字列と、`Name`、<xref:System.Type.FullName%2A>、および <xref:System.Type.AssemblyQualifiedName%2A> プロパティを比較します。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberSignature Language="C#" Value="public abstract RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Type" /> のハンドルを取得します。</summary>
        <value>現在の <see cref="T:System.Type" /> のハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` は、型を表す内部データ構造へのポインターをカプセル化します。 このハンドルは、プロセスの有効期間中に一意です。 ハンドルは、取得されたアプリケーションドメインでのみ有効です。  
  
   
  
## Examples  
 次の例では、対応する型のハンドルを返し、ハンドルから型を取得して表示するメソッドにハンドルを渡します。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在、.NET Compact Framework は、このプロパティをサポートしていません。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の初期化子を取得します。</summary>
        <value><see cref="T:System.Type" /> のクラス コンストラクターの名前を格納するオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クラス初期化子は、<xref:System.Type.FindMembers%2A> メソッド、またはパラメーターとして <xref:System.Type.GetConstructors%2A> を受け取る <xref:System.Type.GetMember%2A>、<xref:System.Type.GetMembers%2A>、<xref:System.Type.GetConstructor%2A>、および <xref:System.Reflection.BindingFlags> メソッドのオーバーロードを介して使用することもできます。  
  
 現在の <xref:System.Type> がジェネリック型またはジェネリックメソッドの定義の型パラメーターを表している場合、このプロパティは `null`を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この型を表す共通言語ランタイムによって提供された型を示します。</summary>
        <value><see cref="T:System.Type" /> の基になるシステム型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
