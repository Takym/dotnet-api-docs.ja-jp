<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0f4a1bb9f35be38e9a01180a5f34792030a72e08" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75158570" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>タスクの実行、作業項目のポスト、非同期 I/O の処理、他のスレッドの代理で行う待機、およびタイマーの処理に使用できるスレッドのプールを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多くのアプリケーションでは、スリープ状態に非常に多くの時間を費やし、イベントが発生するのを待機しているスレッドを作成します。 その他のスレッドは、定期的にスリープ状態にならないようにして、変更または更新状態情報をポーリングすることができます。 スレッドプールを使用すると、システムによって管理されるワーカースレッドのプールをアプリケーションに提供することで、スレッドをより効率的に使用できます。 スレッドプールのスレッドを使用する操作の例を次に示します。  
  
-   <xref:System.Threading.Tasks.Task> または <xref:System.Threading.Tasks.Task%601> オブジェクトを作成してタスクを非同期に実行する場合、既定では、タスクはスレッドプールのスレッドで実行されるようにスケジュールされます。  
  
-   非同期タイマーは、スレッドプールを使用します。 スレッドプールスレッドは、<xref:System.Threading.Timer?displayProperty=nameWithType> クラスからコールバックを実行し、<xref:System.Timers.Timer?displayProperty=nameWithType> クラスからイベントを発生させます。  
  
-   登録された待機ハンドルを使用すると、システムスレッドは待機ハンドルの状態を監視します。 待機操作が完了すると、スレッドプールからのワーカースレッドが、対応するコールバック関数を実行します。  
  
-   <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを呼び出して、スレッドプールのスレッドで実行するメソッドをキューに入れた場合。 これを行うには、メソッドに <xref:System.Threading.WaitCallback> デリゲートを渡します。   デリゲートにはシグネチャがあります。  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     ここで `state` は、デリゲートによって使用されるデータを格納するオブジェクトです。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> メソッドを呼び出すことによって、実際のデータをデリゲートに渡すことができます。  
  
> [!NOTE]
>  マネージスレッドプール内のスレッドは、バックグラウンドスレッドです。 つまり、<xref:System.Threading.Thread.IsBackground%2A> のプロパティが `true`ます。 これは、すべてのフォアグラウンドスレッドが終了した後に、<xref:System.Threading.ThreadPool> のスレッドがアプリケーションを実行し続けることがないことを意味します。  
  
> [!IMPORTANT]
>  スレッドプールは、スレッドを再利用するときに、スレッドローカルストレージまたは <xref:System.ThreadStaticAttribute> 属性でマークされているフィールドのデータをクリアしません。 したがって、メソッドがスレッドローカルストレージまたは <xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを検査する場合、その値は、スレッドプールのスレッドを以前に使用した後に残されている可能性があります。  
  
 また、待機操作に関連付けられていない作業項目をスレッドプールにキューに置いてもかまいません。 スレッドプール内のスレッドが作業項目を処理するように要求するには、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを呼び出します。 このメソッドは、スレッドプールから選択されたスレッドによって呼び出されるメソッドまたはデリゲートへの参照をパラメーターとして受け取ります。 キューに登録された後は、作業項目を取り消すことはできません。  
  
 タイマー-キューのタイマーと登録されている待機操作は、スレッドプールも使用します。 これらのコールバック関数は、スレッドプールのキューに登録されます。  
  
 プロセスごとに1つのスレッドプールがあります。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 以降では、プロセスのスレッド プールの既定のサイズは、仮想アドレス空間のサイズなど、いくつかの要素によって決まります。 スレッドの数は、プロセスで <xref:System.Threading.ThreadPool.GetMaxThreads%2A> メソッドを呼び出せば確認できます。 スレッドプール内のスレッドの数は、<xref:System.Threading.ThreadPool.SetMaxThreads%2A> メソッドを使用して変更できます。 各スレッドは既定のスタックサイズを使用し、既定の優先順位で実行されます。  
  
> [!NOTE]
>  .NET Framework をホストするアンマネージコードは、mscoree.dll ファイルで定義されている `CorSetMaxThreads` 関数を使用して、スレッドプールのサイズを変更できます。  
  
 スレッドプールは、各カテゴリの最小値に達するまで、新しいワーカースレッドまたは i/o 完了スレッドをオンデマンドで提供します。 最小値に達すると、スレッドプールはそのカテゴリに追加のスレッドを作成したり、一部のタスクが完了するまで待機したりすることができます。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以降では、スループットを最適化するために、スレッド プールでワーカー スレッドの作成と破棄が行われます。スループットは、タスクの単位時間あたりの完了数として定義されます。 スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。  
  
> [!NOTE]
>  要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。  
  
 これらの最小値は、<xref:System.Threading.ThreadPool.GetMinThreads%2A> メソッドを使用して取得できます。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.SetMinThreads%2A> メソッドを使用して、スレッドの最小数を増やすことができます。 ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。 同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。 ほとんどの場合、スレッドを割り当てるためのスレッド プール独自のアルゴリズムを使用することでスレッド プールのパフォーマンスが向上します。  
  
   
  
## Examples  
 次の例では、メインアプリケーションスレッドが `ThreadProc` という名前のメソッドをキューに入れて、スレッドプールのスレッドで実行し、1秒間スリープしてから終了します。 `ThreadProc` メソッドは、単にメッセージを表示します。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドへの呼び出しをコメントアウトすると、スレッドプールのスレッドでメソッドが実行される前に、メインスレッドが終了します。  スレッドプールはバックグラウンドスレッドを使用します。これにより、すべてのフォアグラウンドスレッドが終了してもアプリケーションは実行されません。  (これは競合状態の簡単な例です)。  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージスレッドプール</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="osHandle">ハンドルを保持する <see cref="T:System.IntPtr" />。 ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</param>
        <summary>オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</summary>
        <returns>ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを呼び出すことができる。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">オペレーティング システム ハンドルを保持する <see cref="T:System.Runtime.InteropServices.SafeHandle" />。 ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</param>
        <summary>オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</summary>
        <returns>ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle` パラメーターは、抽象 <xref:System.Runtime.InteropServices.SafeHandle> クラスから派生する <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>である必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" /> が <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを呼び出すことができる。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これまでに処理された作業項目の数を取得します。</summary>
        <value>これまでに処理された作業項目の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

スレッドプールの実装に異なる種類の作業項目がある場合、カウントにはすべての型が含まれます。

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">使用できるワーカー スレッドの数。</param>
        <param name="completionPortThreads">使用できる非同期 I/O スレッドの数。</param>
        <summary>スレッド プール スレッドの最大数 (<see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> メソッドから返される) と現在アクティブなスレッドの数との差を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> が返されると、`workerThreads` によって指定された変数には、開始可能な追加のワーカースレッドの数が含まれ、`completionPortThreads` で指定された変数には、開始可能な追加の非同期 i/o スレッドの数が含まれます。  
  
 使用可能なスレッドがない場合、スレッドプールのスレッドが使用可能になるまで、追加のスレッドプール要求はキューに置かれたままになります。  
  
   
  
## Examples  
 次の例では、単純なアプリの起動時に使用可能なワーカースレッドと i/o スレッドの数を表示します。  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">スレッド プール内のワーカー スレッドの最大数。</param>
        <param name="completionPortThreads">スレッド プール内の非同期 I/O スレッドの最大数。</param>
        <summary>同時にアクティブにできるスレッド プールへの要求の数を取得します。 この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> が返されると、`workerThreads` によって指定された変数にはスレッドプールで許可されるワーカースレッドの最大数が含まれ、`completionPortThreads` で指定された変数には、スレッドプールで許可されている非同期 i/o スレッドの最大数が含まれます。  
  
 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> メソッドを使用して、いつでもスレッドプール内のスレッドの実際の数を確認できます。  
  
 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> を使用すると、スレッドプール内のワーカースレッドの最大数と非同期 i/o スレッドの数を設定できます。  
  
 システムメモリで許可されている数のスレッドプール要求をキューにすることができます。 スレッドプールのスレッド数よりも多くの要求がある場合、スレッドプールのスレッドが使用可能になるまで、追加の要求はキューに置かれたままになります。  
  
   
  
## Examples  
 スレッドプール内のスレッドの最大数と使用可能な数を取得する方法を次のコード例に示します。 `FileStream` を使用して2つのファイルに非同期的に書き込む作業項目がキューに登録されます。 コールバックメソッドは、重複するように時間が指定されています。 ワーカースレッドは作業項目を処理し、コンピューターのプロセッサの速度と数に応じて、1つまたは2つの完了ポートスレッドが書き込み操作を処理します。  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">このメソッドが戻るとき、スレッド プールがオンデマンドで作成するワーカー スレッドの最小数が含まれています。</param>
        <param name="completionPortThreads">このメソッドが戻るとき、スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数が含まれています。</param>
        <summary>スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を取得します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドプールは、各カテゴリの最小値に達するまで、新しいワーカースレッドまたは i/o 完了スレッドをオンデマンドで提供します。 既定では、スレッドの最小数はシステム上のプロセッサの数に設定されます。 最小値に達すると、スレッドプールはそのカテゴリに追加のスレッドを作成したり、一部のタスクが完了するまで待機したりすることができます。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、スレッドプールは、スループットを最適化するためにスレッドを作成して破棄します。スループットは、時間単位で完了するタスクの数として定義されます。 スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。  
  
> [!NOTE]
>  要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。  
  
   
  
## Examples  
 次の例では、ワーカースレッドの最小数を4に設定し、元の値を非同期 i/o 完了スレッドの最小数に保持します。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理するキューに置かれた現在の作業項目の数を取得します。</summary>
        <value>処理のために現在キューに登録されている作業項目の数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

スレッドプールの実装に異なる種類の作業項目がある場合、カウントには追跡可能なすべての種類が含まれます。これは、タスクを含むユーザーの作業項目である可能性があります。 一部の実装では、キューに入っているタイマーと待機コールバックがカウントされることもあります。 Windows では、IO 完了ポートに直接ポストされるため、保留中の IO の完了回数がカウントに含まれることはほとんどありません。

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メソッドを実行するためのキューに置きます。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</param>
        <summary>メソッドを実行するためのキューに置きます。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
        <returns>メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キューに格納されたメソッドに必要なデータは、メソッドが定義されているクラスのインスタンスフィールドに配置できます。また、必要なデータを格納しているオブジェクトを受け取る <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> オーバーロードを使用することもできます。  
  
> [!NOTE]
>  Visual Basic ユーザーは、<xref:System.Threading.WaitCallback> コンストラクターを省略できます。また、コールバックメソッドを <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>に渡すときに `AddressOf` 演算子を使用するだけです。 Visual Basic は、正しいデリゲートコンストラクターを自動的に呼び出します。  
  
## <a name="version-information"></a>バージョン情報  
 .NET Framework バージョン2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。 以前のバージョンでは、プリンシパル情報は反映されません。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> メソッドオーバーロードを使用して、`ThreadProc` メソッドによって表されるタスクをキューに置いて、スレッドが使用可能になったときに実行します。 このオーバーロードでは、タスク情報は提供されません。 したがって、`ThreadProc` メソッドで使用できる情報は、メソッドが属しているオブジェクトに限定されます。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</param>
        <param name="state">メソッドが使用するデータを格納したオブジェクト。</param>
        <summary>実行するためのキューにメソッドを置き、そのメソッドが使用するデータを含んだオブジェクトを指定します。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
        <returns>メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コールバックメソッドに複雑なデータが必要な場合は、データを格納するクラスを定義できます。  
  
> [!NOTE]
>  Visual Basic ユーザーは、<xref:System.Threading.WaitCallback> コンストラクターを省略できます。また、コールバックメソッドを <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>に渡すときに `AddressOf` 演算子を使用するだけです。 Visual Basic は、正しいデリゲートコンストラクターを自動的に呼び出します。  
  
## <a name="version-information"></a>バージョン情報  
 .NET Framework バージョン2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。 以前のバージョンでは、プリンシパル情報は反映されません。  
  
   
  
## Examples  
 次の例では、.NET スレッドプールを使用して、20 ~ 40 の5つの数値の `Fibonacci` 結果を計算します。 各 `Fibonacci` の結果は `Fibonacci` クラスによって表され、このクラスには計算を実行する `ThreadPoolCallback` という名前のメソッドがあります。 `Fibonacci` の各値を表すオブジェクトが作成され、`ThreadPoolCallback` メソッドが <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> に渡されます。このメソッドは、プール内の使用可能なスレッドを割り当てて、渡されたメソッドを実行します。  
  
 各 `Fibonacci` オブジェクトには計算対象の半ランダムな値が与えられるため、各スレッドはプロセッサ時間に対して競合するので、5つのすべての結果が計算されるまでにかかる時間を事前に知ることはできません。 そのため、各 `Fibonacci` オブジェクトには構築の間に <xref:System.Threading.ManualResetEvent> クラスのインスタンスを渡されます。 各オブジェクトは、その計算が完了したときに、指定されたイベントオブジェクトに通知します。これにより、プライマリスレッドは、5つのすべての `Fibonacci` オブジェクトが結果を計算するまで <xref:System.Threading.WaitHandle.WaitAll%2A> での実行をブロックできます。 その後、`Main` メソッドは各 `Fibonacci` の結果を表示します。
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> が <see langword="null" />です。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><paramref name="state" /> の要素の型。</typeparam>
        <param name="callBack">実行するメソッドを表す <see cref="T:System.Action`1" />。</param>
        <param name="state">メソッドが使用するデータを格納したオブジェクト。</param>
        <param name="preferLocal">現在のスレッドに近いキューに作業項目を入れる場合は <see langword="true" />。スレッド プールの共有キューに作業項目を入れる場合は <see langword="false" />。</param>
        <summary>実行用に <see cref="T:System.Action`1" /> デリゲートで指定したメソッドをキューに入れ、メソッドで使うデータを指定します。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
        <returns>メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。
.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> を待機しているデリゲートを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。 <paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。 次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。  
  
-   指定されたオブジェクトはシグナル状態です。  
  
-   タイムアウト間隔が経過した。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。 オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。 待機操作は、スレッドプールからのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。 `timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。  
  
> [!IMPORTANT]
>  `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。 <xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。  
  
 待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。  
  
 待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。 したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。  
  
 関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。 変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。 たとえば、セマフォのカウントは1つ減少します。  
  
## <a name="version-information"></a>バージョン情報  
 .NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。 以前のバージョンでは、プリンシパル情報は反映されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されたオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。 <paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。 次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。  
  
-   指定されたオブジェクトはシグナル状態です。  
  
-   タイムアウト間隔が経過した。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。 オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。 待機操作は、スレッドプールからのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。 `timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。  
  
> [!IMPORTANT]
>  `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。 <xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。  
  
 待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。  
  
 待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。 したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。  
  
 関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。 変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。 たとえば、セマフォのカウントは1つ減少します。  
  
## <a name="version-information"></a>バージョン情報  
 .NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。 以前のバージョンでは、プリンシパル情報は反映されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されたオブジェクト。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> で表されるタイムアウト。 <paramref name="timeout" /> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="timeout" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary><see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。 次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。  
  
-   指定されたオブジェクトはシグナル状態です。  
  
-   タイムアウト間隔が経過した。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。 オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。 待機操作は、スレッドプールからのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。 `timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。  
  
> [!IMPORTANT]
>  `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。 <xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。  
  
 待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。  
  
 待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。 したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。  
  
 関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。 変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。 たとえば、セマフォのカウントは1つ減少します。  
  
## <a name="version-information"></a>バージョン情報  
 .NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。 以前のバージョンでは、プリンシパル情報は反映されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> パラメーターが -1 未満。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</param>
        <param name="state">デリゲートに渡されたオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。 <paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。 次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。  
  
-   指定されたオブジェクトはシグナル状態です。  
  
-   タイムアウト間隔が経過した。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。 オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。 待機操作は、スレッドプールからのスレッドによって実行されます。 デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。 `timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。  
  
> [!IMPORTANT]
>  `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。 <xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。  
  
 待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。  
  
 待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。 したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。  
  
 関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。 変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。 たとえば、セマフォのカウントは1つ減少します。  
  
## <a name="version-information"></a>バージョン情報  
 .NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。 以前のバージョンでは、プリンシパル情報は反映されません。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用して、指定された待機ハンドルがシグナル状態になったときに、指定されたコールバックメソッドを実行する方法を示しています。 この例では、コールバックメソッドが `WaitProc`、待機ハンドルが <xref:System.Threading.AutoResetEvent>です。  
  
 この例では、実行時にコールバックに渡される情報を保持する `TaskInfo` クラスを定義します。 この例では、`TaskInfo` オブジェクトを作成し、いくつかの文字列データを割り当てます。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドによって返される <xref:System.Threading.RegisteredWaitHandle> は、コールバックメソッドが <xref:System.Threading.RegisteredWaitHandle>にアクセスできるように、`TaskInfo` オブジェクトの `Handle` フィールドに割り当てられます。  
  
 コールバックメソッドに渡すオブジェクトとして `TaskInfo` を指定するだけでなく、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドの呼び出しでは、タスクが待機する <xref:System.Threading.AutoResetEvent>、`WaitProc` コールバックメソッドを表す <xref:System.Threading.WaitOrTimerCallback> デリゲート、1秒のタイムアウト時間、および複数のコールバックを指定します。  
  
 メインスレッドが <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出すことによって <xref:System.Threading.AutoResetEvent> に通知すると、<xref:System.Threading.WaitOrTimerCallback> デリゲートが呼び出されます。 `WaitProc` メソッドは、タイムアウトが発生したかどうかを判断するために <xref:System.Threading.RegisteredWaitHandle> をテストします。 待機ハンドルがシグナル状態になったためにコールバックが呼び出された場合、`WaitProc` メソッドは、<xref:System.Threading.RegisteredWaitHandle>の登録を解除し、追加のコールバックを停止します。 タイムアウトの場合、タスクは待機を続けます。 `WaitProc` メソッドは、メッセージをコンソールに出力することによって終了します。  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">スレッド プール内のワーカー スレッドの最大数。</param>
        <param name="completionPortThreads">スレッド プール内の非同期 I/O スレッドの最大数。</param>
        <summary>同時にアクティブにできるスレッド プールへの要求の数を設定します。 この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</summary>
        <returns>変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ワーカースレッドまたは i/o 完了スレッドの最大数を、コンピューター上のプロセッサ数よりも小さい数に設定することはできません。 存在するプロセッサの数を確認するには、<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> プロパティの値を取得します。 さらに、ワーカースレッドまたは i/o 完了スレッドの最大数を、対応するワーカースレッドまたは i/o 完了スレッドの最小数よりも小さい数に設定することはできません。 最小スレッドプールサイズを確認するには、<xref:System.Threading.ThreadPool.GetMinThreads%2A> メソッドを呼び出します。  
  
 共通言語ランタイムがインターネットインフォメーションサービス (IIS) や SQL Server などでホストされている場合、ホストはスレッドプールサイズの変更を制限したり、禁止したりすることができます。  
  
 スレッドプール内のスレッドの最大数を変更するときは注意してください。 コードが恩恵を受ける可能性がありますが、変更は使用するコードライブラリに悪影響を及ぼす可能性があります。  
  
 スレッドプールのサイズを大きく設定すると、パフォーマンスの問題が発生する可能性があります。 同時に実行されているスレッドの数が多すぎると、タスクの切り替えによるオーバーヘッドが大きくなります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドを制御する機能。 アクセス許可値: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">スレッド プールがオンデマンドで作成するワーカー スレッドの最小数。</param>
        <param name="completionPortThreads">スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数。</param>
        <summary>スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を設定します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</summary>
        <returns>変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドプールは、各カテゴリの最小値に達するまで、新しいワーカースレッドまたは i/o 完了スレッドをオンデマンドで提供します。 最小値に達すると、スレッドプールはそのカテゴリに追加のスレッドを作成したり、一部のタスクが完了するまで待機したりすることができます。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、スレッドプールは、スループットを最適化するためにスレッドを作成して破棄します。スループットは、時間単位で完了するタスクの数として定義されます。 スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。  
  
 要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。  
  
 <xref:System.Threading.ThreadPool.GetMaxThreads%2A>を使用して取得した、アクティブなスレッドプールのスレッドの最大数よりも大きい負の数または数を指定した場合、<xref:System.Threading.ThreadPool.SetMinThreads%2A> は `false` を返し、最小値のいずれかを変更しません。  
  
> [!CAUTION]
>  既定では、スレッドの最小数はシステム上のプロセッサの数に設定されます。 <xref:System.Threading.ThreadPool.SetMinThreads%2A> メソッドを使用して、スレッドの最小数を増やすことができます。 ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。 同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。 ほとんどの場合、スレッドプールは、スレッドを割り当てる独自のアルゴリズムによってパフォーマンスが向上します。 最小値をプロセッサ数未満に減らすと、パフォーマンスが低下する場合もあります。  
  
   
  
## Examples  
 次の例では、ワーカースレッドの最小数を4に設定し、元の値を非同期 i/o 完了スレッドの最小数に保持します。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドを制御する機能。 アクセス許可値: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在存在しているスレッド プールのスレッド数を取得します。</summary>
        <value>現在存在しているスレッドプールスレッドの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

スレッドプールの実装のスレッドの種類が異なる場合、カウントにはすべての型が含まれます。

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="overlapped">キューに置く <see cref="T:System.Threading.NativeOverlapped" /> 構造体。</param>
        <summary>重複した I/O 操作を、実行するためのキューに置きます。</summary>
        <returns>操作が I/O 完了ポートのキューに正常に置かれた場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ネイティブ Win32 のオーバーラップ i/o の使用の詳細については、Win32 Platform SDK の <xref:System.Threading.Overlapped> クラス、<xref:System.Threading.NativeOverlapped> 構造体、および `OVERLAPPED` 構造体を参照してください。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> メソッドを使用すると、セキュリティホールが誤って表示される可能性があります。 コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。 悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack">スレッド プールのスレッドが作業項目を選択したときに呼び出される作業項目。</param>
        <param name="preferLocal">現在のスレッドに近いキューに作業項目を入れる場合は <see langword="true" />。スレッド プールの共有キューに作業項目を入れる場合は <see langword="false" />。</param>
        <summary>指定された作業項目オブジェクトをスレッド プールのキューに入れます。</summary>
        <returns>メソッドが成功した場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.OutOfMemoryException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

スレッドプールは、作業項目の <xref:System.Threading.IThreadPoolWorkItem.Execute> メソッドを呼び出します。 必要に応じて、その作業項目が <xref:System.Threading.ExecutionContext> に反映される役割を担います。スレッドプールはこれを行いません。

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">作業項目は <see cref="T:System.Threading.Tasks.Task" /> です。</exception>
        <exception cref="T:System.OutOfMemoryException">作業項目をキューに配置できません。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack">スレッド プール内のスレッドが作業項目をピック アップするときに呼び出すデリゲートを表す <see cref="T:System.Threading.WaitCallback" />。</param>
        <param name="state">スレッド プールから処理されるときにデリゲートに渡されるオブジェクト。</param>
        <summary>指定したデリゲートをスレッド プールのキューに置きます。ただし、コール スタックをワーカー スレッドに反映しません。</summary>
        <returns>メソッドが成功した場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.OutOfMemoryException" /> がスローされます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> は呼び出し元のスタックをワーカースレッドに反映しません。 これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> を使用すると、セキュリティホールを誤って開く可能性があります。 コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。 悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.ApplicationException">メモリが不足しています。</exception>
        <exception cref="T:System.OutOfMemoryException">作業項目をキューに配置できません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> が <see langword="null" />です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><paramref name="state" /> の要素の型。</typeparam>
        <param name="callBack">実行するメソッドを表すデリゲート。</param>
        <param name="state">メソッドが使用するデータを格納したオブジェクト。</param>
        <param name="preferLocal">現在のスレッドに近いキューに作業項目を入れる場合は <see langword="true" />。スレッド プールの共有キューに作業項目を入れる場合は <see langword="false" />。</param>
        <summary>実行用に <see cref="T:System.Action`1" /> デリゲートで指定したメソッドをキューに入れ、そのメソッドで使用するデータを含んだオブジェクトを指定します。 メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</summary>
        <returns>メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">作業項目をキューに配置できません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。ただし、コール スタックをワーカー スレッドに反映しません。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。 <paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を使用して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。 このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。 これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。 コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。 悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。  
  
 `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。  
  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。 <paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。 このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。 これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。 コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。 悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。  
  
 `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。  
  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> で表されるタイムアウト。 <paramref name="timeout" /> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="timeout" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary><see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。 これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。 コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。 悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。  
  
 `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。  
  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> パラメーターが -1 未満。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">登録する <see cref="T:System.Threading.WaitHandle" />。 <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</param>
        <param name="callBack"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</param>
        <param name="state">デリゲートに渡されるオブジェクト。</param>
        <param name="millisecondsTimeOutInterval">ミリ秒単位のタイムアウト。 <paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。 <paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</param>
        <param name="executeOnlyOnce">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</param>
        <summary>32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。 このメソッドはコール スタックをワーカー スレッドに反映しません。</summary>
        <returns>登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。 これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。 コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。 悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。  
  
 `waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。  
  
 このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。 `executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。 登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
  </Members>
</Type>
