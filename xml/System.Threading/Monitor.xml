<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="43eb33d069ff4708c6978251697a86abcffa143c" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75116229" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>オブジェクトへのアクセスを同期する機構を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Monitor> クラスを使用すると、<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>、および <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> の各メソッドを呼び出すことによって、特定のオブジェクトのロックを取得および解放することによって、コードの領域へのアクセスを同期できます。 オブジェクトロックは、一般にクリティカルセクションと呼ばれる、コードブロックへのアクセスを制限する機能を提供します。 スレッドがオブジェクトのロックを所有している間、他のスレッドがそのロックを取得することはできません。 また、<xref:System.Threading.Monitor> クラスを使用して、他のスレッドが別のロックされたオブジェクトを使用してコードを実行している場合を除き、他のスレッドがロック所有者によって実行されるアプリケーションコードのセクションにアクセスできないようにすることもできます。  
  
 この記事の内容  
  
 [Monitor クラス: 概要](#Overview)   
 [Lock オブジェクト](#Lock)   
 [クリティカルセクション](#CriticalSection)   
 [Pulse、system.threading.monitor.pulseall、Wait](#Pulse)   
 [モニターと待機ハンドル](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Monitor クラス: 概要  
 <xref:System.Threading.Monitor> には、次の機能があります。  
  
-   要求時にオブジェクトに関連付けられています。  
  
-   バインド解除されているため、任意のコンテキストから直接呼び出すことができます。  
  
-   <xref:System.Threading.Monitor> クラスのインスタンスを作成できません。<xref:System.Threading.Monitor> クラスのメソッドはすべて静的です。 各メソッドには、クリティカルセクションへのアクセスを制御する同期されたオブジェクトが渡されます。  
  
> [!NOTE]
>  <xref:System.Threading.Monitor> クラスを使用して、値型ではなく、文字列 (つまり、<xref:System.String>以外の参照型) 以外のオブジェクトをロックします。 詳細については、この記事で後述する「<xref:System.Threading.Monitor.Enter%2A> メソッドと[lock オブジェクト](#Lock)のオーバーロード」を参照してください。  
  
 次の表では、同期されたオブジェクトにアクセスするスレッドで実行できる操作について説明します。  
  
|操作|説明|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>、 <xref:System.Threading.Monitor.TryEnter%2A>|オブジェクトのロックを取得します。 この操作は、クリティカルセクションの開始を示すこともできます。 他のスレッドは、別のロックされたオブジェクトを使用してクリティカルセクションの命令を実行しない限り、クリティカルセクションに入ることはできません。|  
|<xref:System.Threading.Monitor.Wait%2A>|オブジェクトのロックを解除し、他のスレッドがオブジェクトにロックしてアクセスできるようにします。 呼び出し元のスレッドは、別のスレッドがオブジェクトにアクセスしている間、待機します。 パルスシグナルは、オブジェクトの状態に対する変更について、待機中のスレッドに通知するために使用されます。|  
|<xref:System.Threading.Monitor.Pulse%2A> (シグナル)、<xref:System.Threading.Monitor.PulseAll%2A>|1つ以上の待機中のスレッドにシグナルを送信します。 シグナルは、ロックされたオブジェクトの状態が変化したこと、およびロックの所有者がロックを解放する準備ができたことを待機中のスレッドに通知します。 待機中のスレッドは、オブジェクトのロックを最終的に受け取る可能性があるように、オブジェクトの準備完了キューに配置されます。 スレッドがロック状態になったら、オブジェクトの新しい状態をチェックして、必要な状態に達したかどうかを確認できます。|  
|<xref:System.Threading.Monitor.Exit%2A>|オブジェクトのロックを解放します。 この操作は、ロックされたオブジェクトによって保護されているクリティカルセクションの終了もマークします。|  
  
 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、<xref:System.Threading.Monitor.Enter%2A> メソッドと <xref:System.Threading.Monitor.TryEnter%2A> メソッドに2組のオーバーロードがあります。 1つのオーバーロードセットには、ロックC#を取得するときに例外がスローされた場合でも、ロックが取得された場合にはアトミックに `true` に設定される `ref` (in) または `ByRef` (Visual Basic) の <xref:System.Boolean> パラメーターがあります。 ロックが保護されているリソースが一貫性のある状態ではない場合でも、常にロックを解放することが重要な場合は、これらのオーバーロードを使用します。  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Lock オブジェクト  
 Monitor クラスは、クリティカルセクションへのC#アクセスを制御するオブジェクトを操作する `static` (では) または `Shared` (Visual Basic) メソッドで構成されます。  同期されたオブジェクトごとに、次の情報が保持されます。  
  
-   現在ロックを保持しているスレッドへの参照。  
  
-   準備完了のキューへの参照。ロックを取得する準備ができているスレッドを格納します。  
  
-   待機中のキューへの参照。ロックされたオブジェクトの状態の変更の通知を待機しているスレッドを格納します。  
  
 <xref:System.Threading.Monitor> は値型ではなく、オブジェクト (つまり、参照型) をロックします。 値型を <xref:System.Threading.Monitor.Enter%2A> と <xref:System.Threading.Monitor.Exit%2A> に渡すことができますが、値型は呼び出しごとに個別にボックス化されます。 呼び出しごとに個別のオブジェクトが作成されるので、<xref:System.Threading.Monitor.Enter%2A> は決してコードをブロックすることはなく、保護していると想定しているコードは実際には同期されません。 さらに、<xref:System.Threading.Monitor.Exit%2A> に渡されたオブジェクトは <xref:System.Threading.Monitor.Enter%2A> に渡されたオブジェクトとは異なるため、<xref:System.Threading.Monitor> は「オブジェクトの同期メソッドが、コードの非同期ブロックから呼び出されました。」というメッセージとともに <xref:System.Threading.SynchronizationLockException> 例外をスローします。  
  
 この問題を説明する例を次に示します。 10 個のタスクが起動され、それぞれが 250 ミリ秒間スリープ状態になります。 次に、各タスクはカウンター変数である `nTasks` を更新します。これは実際に起動、実行されるタスクの数をカウントするためのものです。 `nTasks` は複数のタスクで同時に更新可能なグローバル変数なので、複数のタスクによる同時変更を防止するためにモニターを使用します。 しかし、例に示す出力のように、各タスクは <xref:System.Threading.SynchronizationLockException> 例外をスローします。  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 各タスクの <xref:System.Threading.SynchronizationLockException> メソッドに対する呼び出しの前に `nTasks` 変数がボックス化されるため、各タスクは <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 例外をスローします。 つまり、各メソッドの呼び出しは他のメソッドから独立している個別の変数に渡されます。 `nTasks` は <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> メソッドへの呼び出しで再びボックス化されます。 こうして 10 個の新しいボックス化された変数が作成されます。これらは互いに独立したものであり、`nTasks` からも <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> メソッドへの呼び出しで作成された 10 個のボックス化された変数からも独立しています。 それで、以前ロックされていなかった新規に作成された変数のロックを解放しようとしているため、例外がスローされます。  
  
 次の例に示すように、<xref:System.Threading.Monitor.Enter%2A> と <xref:System.Threading.Monitor.Exit%2A> の呼び出しの前に値型の変数をボックス化したり、ボックス化された同じオブジェクトを両方のメソッドに渡したりできますが、これを行う利点はありません。 ボックス化解除された変数への変更は、ボックス化されたコピーには反映されません。またボックス化されたコピーの値を変更する方法はありません。  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 同期するオブジェクトを選択するときは、プライベートまたは内部のオブジェクトのみをロックする必要があります。 外部オブジェクトをロックするとデッドロックが発生する可能性があります。これは、関連のないコードが、異なる目的でロックする同じオブジェクトを選択する可能性があるためです。  
  
 ロックに使用されるオブジェクトが <xref:System.MarshalByRefObject>から派生している場合は、複数のアプリケーションドメイン内のオブジェクトを同期できます。  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>クリティカルセクション  
 <xref:System.Threading.Monitor.Enter%2A> および <xref:System.Threading.Monitor.Exit%2A> メソッドを使用して、クリティカルセクションの開始と終了をマークします。  
  
> [!NOTE]
>  <xref:System.Threading.Monitor.Enter%2A> メソッドと <xref:System.Threading.Monitor.Exit%2A> メソッドによって提供される機能は、のC# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md)ステートメントと Visual Basic の[SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)ステートメントによって提供される機能と同じですが、言語構成要素によって <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> メソッドのオーバーロードと <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> メソッドが `try`にラップされる点が異なり`finally` ブロックして、モニターがリリースされていることを確認します。  
  
 クリティカルセクションが一連の連続する命令である場合、<xref:System.Threading.Monitor.Enter%2A> メソッドによって取得されたロックは、ロックされたオブジェクトを使用して、囲まれたコードを1つのスレッドだけが実行できることを保証します。 この場合は、そのコードを `try` ブロックに配置し、<xref:System.Threading.Monitor.Exit%2A> メソッドへの呼び出しを `finally` ブロックに配置することをお勧めします。 これにより、例外が発生しても必ずロックが解放されるようになります。 次のコードは、このパターンを示しています。  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 この機能は、通常、クラスの静的メソッドまたはインスタンスメソッドへのアクセスを同期するために使用されます。  
  
 クリティカルセクションがメソッド全体にまたがっている場合は、メソッドに <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> を配置し、<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>のコンストラクターで <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> 値を指定することによって、ロック機能を実現できます。 この属性を使用する場合、<xref:System.Threading.Monitor.Enter%2A> および <xref:System.Threading.Monitor.Exit%2A> メソッドの呼び出しは必要ありません。 次のコードは、このパターンを示しています。  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 属性によって、メソッドが戻るまで、ロックを保持するために、現在のスレッドに注意してください。ロックがすぐに解放する場合は、使用、<xref:System.Threading.Monitor>クラスの C#[ロック](~/docs/csharp/language-reference/keywords/lock-statement.md)ステートメント、または Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)属性ではなく、メソッド内でステートメント。  
  
 指定されたオブジェクトをロックして解放する <xref:System.Threading.Monitor.Enter%2A> および <xref:System.Threading.Monitor.Exit%2A> ステートメントは、メンバーまたはクラスの境界の間またはその両方になる可能性がありますが、この方法はお勧めしません。  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse、System.threading.monitor.pulseall、Wait  
 スレッドがロックを所有し、ロックによって保護されているクリティカルセクションに入った後は、<xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>、<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>、および <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> メソッドを呼び出すことができます。  
  
 ロックを保持しているスレッドが <xref:System.Threading.Monitor.Wait%2A>を呼び出すと、ロックが解放され、スレッドが同期されたオブジェクトの待機キューに追加されます。 準備完了キュー内の最初のスレッド (存在する場合) は、ロックを取得し、クリティカルセクションに入ります。 <xref:System.Threading.Monitor.Wait%2A> を呼び出したスレッドは、<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> または <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> メソッドがロックを保持しているスレッドによって呼び出されたときに、待機キューから準備キューに移動されます (移動するには、スレッドが待機キューの先頭にある必要があります)。 <xref:System.Threading.Monitor.Wait%2A> メソッドは、呼び出し元のスレッドがロックを再取得したときに戻ります。  
  
 ロックを保持しているスレッドが <xref:System.Threading.Monitor.Pulse%2A>を呼び出すと、待機キューの先頭にあるスレッドが準備完了キューに移動されます。 <xref:System.Threading.Monitor.PulseAll%2A> メソッドを呼び出すと、すべてのスレッドが待機キューから準備完了キューに移動されます。  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>モニターと待機ハンドル  
 <xref:System.Threading.Monitor> クラスと <xref:System.Threading.WaitHandle> オブジェクトの使用方法の違いに注意することが重要です。  
  
-   <xref:System.Threading.Monitor> クラスは純粋に管理され、完全に移植可能であり、オペレーティングシステムのリソース要件に関してより効率的です。  
  
-   <xref:System.Threading.WaitHandle> オブジェクトはオペレーティング システムの待機可能オブジェクトを表しており、マネージドとアンマネージド コード間で同期するのに便利です。また一度に多くのオブジェクトを待機できる機能などの高度なオペレーティング システム機能を公開します。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Monitor> クラスを使用して、<xref:System.Random> クラスによって表される乱数ジェネレーターの1つのインスタンスへのアクセスを同期します。 この例では、スレッドプールのスレッドで非同期的に実行される10個のタスクを作成します。 各タスクは、1万の乱数を生成し、平均値を計算し、生成された乱数の合計数と合計を保持する2つのプロシージャレベル変数を更新します。 すべてのタスクが実行された後、これらの2つの値を使用して全体的な平均が計算されます。  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 スレッドプールのスレッドで実行されているすべてのタスクからアクセスできるため、`total` および `n` の変数へのアクセスも同期する必要があります。 この目的には、<xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> メソッドが使用されます。  
  
 次の例では、<xref:System.Threading.Monitor> クラス (`lock` または `SyncLock` 言語コンストラクトで実装)、<xref:System.Threading.Interlocked> クラス、および <xref:System.Threading.AutoResetEvent> クラスを組み合わせて使用する方法を示します。 2 つの `internal` クラス (C# の場合) または `Friend` クラス (Visual Basic の場合)、`SyncResource` と `UnSyncResource` を定義します。これらはそれぞれ、リソースへの同期アクセスと非同期アクセスを提供します。 同期アクセスと非同期アクセスの違い (各メソッド呼び出しが迅速に完了する場合に違いが生じる可能性がある) を示すために、次の例では、メソッドにランダムな遅延を含めてあります。<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> プロパティが偶数であるスレッドでは、メソッドが <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> を呼び出して、2,000 ミリ秒の遅延を生じさせます。 `SyncResource` クラスはパブリックではなく、同期されたリソースでロックを取得するクライアント コードは存在しないので、内部クラス自体がロックを取得することに注意してください。 これにより、悪意のあるコードがパブリック オブジェクトでロックを取得するのを防ぐことができます。  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 例では、リソースにアクセスしようとするスレッドの数を定義する変数 `numOps` を定義します。 アプリケーション スレッドは、同期アクセスの場合も非同期アクセスの場合もそれぞれ 5 回、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> メソッドを呼び出します。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> メソッドにはパラメーターが 1 つしかありません。パラメーターを受け入れず値を返さないデリゲートです。 同期アクセスの場合は `SyncUpdateResource` メソッドを呼び出し、非同期アクセスの場合は `UnSyncUpdateResource` メソッドを呼び出します。 メソッドが呼び出されるたびに、アプリケーションスレッドは[AutoResetEvent](xref:System.Threading.WaitHandle.WaitOne*)メソッドを呼び出して、<xref:System.Threading.AutoResetEvent> インスタンスがシグナル状態になるまでブロックされるようにします。  
  
 `SyncUpdateResource` メソッドを呼び出すたびに、内部 `SyncResource.Access` メソッドが呼び出され、<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> メソッドが呼び出されて、`numOps` カウンターがデクリメントされます。 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> メソッドは、カウンターをデクリメントするために使用されます。それ以外の場合、最初のスレッドのデクリメントされた値が変数に格納される前に、2番目のスレッドが値にアクセスすることはありません。 最後に同期されたワーカースレッドがカウンターをゼロにデクリメントすると、同期されたすべてのスレッドがリソースへのアクセスを完了したことを示すために、`SyncUpdateResource` メソッドは <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> メソッドを呼び出します。これにより、メインスレッドに実行を継続するように通知されます。  
  
 `UnSyncUpdateResource` メソッドを呼び出すたびに、内部 `UnSyncResource.Access` メソッドが呼び出され、<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> メソッドが呼び出されて、`numOps` カウンターがデクリメントされます。 ここでも、<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> メソッドを使用してカウンターをデクリメントし、最初のスレッドのデクリメントされた値が変数に割り当てられる前に、2番目のスレッドが値にアクセスしないようにします。 最後の同期されていないワーカースレッドがカウンターをゼロにデクリメントすると、そのリソースにアクセスする必要がある非同期のスレッドがないことが示され、`UnSyncUpdateResource` メソッドは、メインスレッドに実行を継続するように通知する <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> メソッドを呼び出します。  
  
 例の出力からわかるように、同期アクセスでは、呼び出し元スレッドが保護リソースを終了してからでないと別のスレッドがそれにアクセスできません。つまり各スレッドはその先行処理を待機します。 その一方で、ロックがない `UnSyncResource.Access` メソッドは、スレッドが到達する順序で呼び出されます。  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">スレッド処理オブジェクトと機能</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したオブジェクトの排他ロックを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">モニター ロックを取得する対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの排他ロックを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーターとして渡されたオブジェクトの <xref:System.Threading.Monitor> を取得するには、`Enter` を使用します。 別のスレッドがオブジェクトに対して `Enter` を実行したが、対応する <xref:System.Threading.Monitor.Exit%2A>をまだ実行していない場合、現在のスレッドは、他のスレッドがオブジェクトを解放するまでブロックします。 同じスレッドが、ブロックせずに複数回 `Enter` を呼び出すことができます。ただし、オブジェクトを待機している他のスレッドがブロック解除される前に、同じ数の `Exit` 呼び出しを呼び出す必要があります。  
  
 値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 値型の変数を `Enter`に渡すと、オブジェクトとしてボックス化されます。 同じ変数を再び `Enter` に渡すと、別のオブジェクトとしてボックス化され、スレッドはブロックされません。 この場合、`Monitor` するコードは保護されていません。 さらに、変数を `Exit`に渡す場合でも、別の個別のオブジェクトが作成されます。 `Exit` に渡されたオブジェクトは `Enter`に渡されたオブジェクトとは異なるため、`Monitor` は <xref:System.Threading.SynchronizationLockException>をスローします。 詳細については、概念説明のトピック「[モニター](xref:System.Threading.Monitor)」を参照してください。  
  
 <xref:System.Threading.Thread.Interrupt%2A> は、オブジェクトへの `Monitor` の入力を待機しているスレッドを中断できます。 <xref:System.Threading.ThreadInterruptedException> がスローされます。  
  
 C# を使用して、 `try`.`finally` ブロック (`Try`.`Finally` VVisual Basic)、モニターを解放するか、または、C# を使用する`lock`ステートメント (`SyncLock` Visual Basic でのステートメント)、ラップ、<xref:System.Threading.Monitor.Enter%2A>と<xref:System.Threading.Monitor.Exit%2A>メソッド、`try`.`finally` ブロックです。  
  
   
  
## Examples  
 `Enter` メソッドの使用方法を次の例に示します。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力は <see langword="false" /> でなければなりません。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。  
  
メモ   例外が発生しない場合、このメソッドの出力は常に <see langword="true" /> です。</param>
        <summary>指定したオブジェクトの排他ロックを取得し、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `obj` パラメーターとして渡されたオブジェクトの <xref:System.Threading.Monitor> を取得するには、`Enter` を使用します。 別のスレッドがオブジェクトに対して `Enter` を実行したが、対応する <xref:System.Threading.Monitor.Exit%2A>をまだ実行していない場合、現在のスレッドは、他のスレッドがオブジェクトを解放するまでブロックします。 同じスレッドが、ブロックせずに複数回 `Enter` を呼び出すことができます。ただし、オブジェクトを待機している他のスレッドがブロック解除される前に、同じ数の `Exit` 呼び出しを呼び出す必要があります。  
  
 例外がスローされたためにロックが取得されなかった場合は、このメソッドの終了後に、`lockTaken` パラメーターに指定された変数が `false` ます。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。 このメソッドが例外をスローせずに戻る場合、`lockTaken` パラメーターに指定された変数は常に `true`されるため、テストする必要はありません。  
  
 値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 値型の変数を `Enter`に渡すと、オブジェクトとしてボックス化されます。 同じ変数を再び `Enter` に渡すと、別のオブジェクトとしてボックス化され、スレッドはブロックされません。 この場合、`Monitor` するコードは保護されていません。 さらに、変数を `Exit`に渡すと、別の別のオブジェクトが作成されます。 `Exit` に渡されたオブジェクトは `Enter`に渡されたオブジェクトとは異なるため、`Monitor` は <xref:System.Threading.SynchronizationLockException>をスローします。 詳細については、概念説明のトピック「[モニター](xref:System.Threading.Monitor)」を参照してください。  
  
 <xref:System.Threading.Thread.Interrupt%2A> は、オブジェクトへの `Monitor` の入力を待機しているスレッドを中断できます。 <xref:System.Threading.ThreadInterruptedException> がスローされます。  
  
   
  
## Examples  
 次のコードは、<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> メソッドのオーバーロードを使用するための基本的なパターンを示しています。 このオーバーロードでは、メソッドが例外をスローした場合でも、`ref` パラメーター (`ByRef` Visual Basic `lockTaken`) に渡される変数の値が常に設定されます。したがって、変数の値は、ロックを解放する必要があるかどうかをテストするための信頼性の高い方法です。  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">ロックを解放する対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの排他ロックを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し元のスレッドは、`obj` パラメーターのロックを所有している必要があります。 呼び出し元のスレッドが、指定されたオブジェクトに対するロックを所有していて、そのオブジェクトに対して同じ数の `Exit` と <xref:System.Threading.Monitor.Enter%2A> 呼び出しを行った場合は、ロックが解放されます。 呼び出し元のスレッドが `Enter``Exit` 何回も呼び出されていない場合、ロックは解放されません。  
  
 ロックが解除され、他のスレッドがそのオブジェクトの準備完了キューにある場合、スレッドの1つがロックを取得します。 他のスレッドがロックの取得を待機している待機キューにある場合、ロックの所有者が `Exit`を呼び出すと、そのスレッドは準備完了キューに自動的に移動されません。 1つ以上の待機中のスレッドを準備完了キューに移動するには、`Exit`を呼び出す前に <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> を呼び出します。  
  
   
  
## Examples  
 `Exit` メソッドの使用方法を次の例に示します。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">現在のスレッドが、指定したオブジェクトのロックを所有していません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">テストするオブジェクト。</param>
        <summary>現在のスレッドが指定したオブジェクトのロックを保持しているかどうかを判断します。</summary>
        <returns>現在のスレッドが <see langword="true" /> のロックを保持している場合は <paramref name="obj" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの動作のメソッドを使用して取得されるロックに対してのみ、<xref:System.Threading.Monitor>クラス、またはを使用して、C#`lock`ステートメントまたは Visual Basic`SyncLock`ステートメントで実装される<xref:System.Threading.Monitor>します。  
  
 このメソッドは、<xref:System.Diagnostics.Debug.Assert%2A> メソッドや <xref:System.Diagnostics.Contracts.Contract> クラスなどの診断ツールと共に使用して、<xref:System.Threading.Monitor> クラスに関連するロックの問題をデバッグします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> は <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モニターのロックを取得しようとするときに、接続があった回数を取得します。</summary>
        <value>モニターのロックを取得しようとしたときに競合が発生した回数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">スレッドが待機するオブジェクト。</param>
        <summary>ロックされたオブジェクトの状態が変更されたことを、待機キュー内のスレッドに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Pulse`を使用して待機中のオブジェクトを通知できるのは、ロックの現在の所有者だけです。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、このメソッドを呼び出して、ロックの行の次のスレッドを通知します。 パルスを受け取ると、待機中のスレッドが準備完了キューに移動されます。 `Pulse` 呼び出されたスレッドがロックを解放すると、準備完了キュー内の次のスレッド (これは、必ずしも公開されていたスレッドではありません) がロックを取得します。  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor> クラスは、<xref:System.Threading.Monitor.Pulse%2A> メソッドが呼び出されたことを示す状態を保持しません。 したがって、待機しているスレッドがないときに <xref:System.Threading.Monitor.Pulse%2A> を呼び出した場合、<xref:System.Threading.Monitor.Wait%2A> を呼び出す次のスレッドは <xref:System.Threading.Monitor.Pulse%2A> が呼び出されたことがないかのようにブロックされます。 2つのスレッドが <xref:System.Threading.Monitor.Pulse%2A> を使用し、対話する <xref:System.Threading.Monitor.Wait%2A> 場合、デッドロックが発生する可能性があります。 これを <xref:System.Threading.AutoResetEvent> クラスの動作と比較します。 <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出して <xref:System.Threading.AutoResetEvent> を通知し、待機中のスレッドが存在しない場合、スレッドが <xref:System.Threading.WaitHandle.WaitOne%2A>、<xref:System.Threading.WaitHandle.WaitAny%2A>、または <xref:System.Threading.WaitHandle.WaitAll%2A>を呼び出すまで、<xref:System.Threading.AutoResetEvent> はシグナル状態のままになります。 <xref:System.Threading.AutoResetEvent> は、そのスレッドを解放し、非シグナル状態に戻ります。  
  
 同期されたオブジェクトには、現在ロックを保持しているスレッドへの参照、準備完了キューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照が保持されていることに注意してください。オブジェクトの状態が変更されたことを示す通知を待機しているスレッドを格納します。  
  
 `Pulse`、<xref:System.Threading.Monitor.PulseAll%2A>、および <xref:System.Threading.Monitor.Wait%2A> メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 複数のスレッドを通知するには、<xref:System.Threading.Monitor.PulseAll%2A> メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">パルスを送るオブジェクト。</param>
        <summary>オブジェクトの状態が変更されたことを、待機中のすべてのスレッドに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在、指定されたオブジェクトのロックを所有しているスレッドは、このメソッドを呼び出して、オブジェクトのロックの取得を待機しているすべてのスレッドに通知します。 シグナルが送信されると、待機中のスレッドが準備完了キューに移動されます。 `PulseAll` 呼び出されたスレッドがロックを解放すると、準備完了キュー内の次のスレッドがロックを取得します。  
  
 同期されたオブジェクトには、現在ロックを保持しているスレッドへの参照、準備完了キューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照が保持されていることに注意してください。オブジェクトの状態が変更されたことを示す通知を待機しているスレッドを格納します。  
  
 <xref:System.Threading.Monitor.Pulse%2A>、`PulseAll`、および <xref:System.Threading.Monitor.Wait%2A> メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A> メソッドの解説では、スレッドが待機していないときに <xref:System.Threading.Monitor.Pulse%2A> が呼び出された場合の処理について説明します。  
  
 1つのスレッドを通知するには、`Pulse` メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したオブジェクトの排他ロックの取得を試みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <summary>指定したオブジェクトの排他ロックの取得を試みます。</summary>
        <returns>現在のスレッドがロックを取得した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成功した場合、このメソッドは `obj` パラメーターの排他ロックを取得します。 このメソッドは、ロックが使用可能かどうかにかかわらず、直ちに戻ります。  
  
 このメソッドは <xref:System.Threading.Monitor.Enter%2A>に似ていますが、現在のスレッドをブロックすることはありません。 スレッドがブロックせずに入力できない場合、メソッドは `false,`を返します。  
  
> [!NOTE]
>  値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 詳細については、<xref:System.Threading.Monitor> に関する記事を参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、メソッドの戻り値を調べて、その戻り値が `true`場合にのみ、クリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した場合に、呼び出し元のスレッドがクリティカルセクションのロックを解放するには、`finally` ブロックで <xref:System.Threading.Monitor.Exit%2A> を呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 次のコード例は、`TryEnter` メソッドの使用方法を示します。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力は <see langword="false" /> でなければなりません。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。</param>
        <summary>指定したオブジェクトの排他ロックの取得を試み、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成功した場合、このメソッドは `obj` パラメーターの排他ロックを取得します。 このメソッドは、ロックが使用可能かどうかにかかわらず、直ちに戻ります。  
  
 例外がスローされたためにロックが取得されなかった場合は、このメソッドの終了後に、`lockTaken` パラメーターに指定された変数が `false` ます。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。  
  
 このメソッドは <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>に似ていますが、現在のスレッドをブロックすることはありません。 スレッドがブロックせずに入力できない場合、メソッドから制御が戻ったときに、`lockTaken` 引数が `false` に設定されます。  
  
> [!NOTE]
>  値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 詳細については、「<xref:System.Threading.Monitor>」の記事を参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、`lockTaken` の値を調べ、その値が `true`の場合にのみクリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した場合に、呼び出し元のスレッドがクリティカルセクションのロックを解放するには、`finally` ブロックで <xref:System.Threading.Monitor.Exit%2A> を呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 次のコードは、<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> メソッドのオーバーロードを使用するための基本的なパターンを示しています。 このオーバーロードでは、メソッドが例外をスローした場合でも、`ref` パラメーター (`ByRef` Visual Basic `lockTaken`) に渡される変数の値が常に設定されます。したがって、変数の値は、ロックを解放する必要があるかどうかをテストするための信頼性の高い方法です。  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="millisecondsTimeout">ロックを待機するミリ秒単位の時間。</param>
        <summary>指定したミリ秒間に、指定したオブジェクトの排他ロックの取得を試みます。</summary>
        <returns>現在のスレッドがロックを取得した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` パラメーターが <xref:System.Threading.Timeout.Infinite>に等しい場合、このメソッドは <xref:System.Threading.Monitor.Enter%2A>に相当します。 `millisecondsTimeout` が0の場合、このメソッドは <xref:System.Threading.Monitor.TryEnter%2A>と同じです。  
  
> [!NOTE]
>  値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 詳細については、<xref:System.Threading.Monitor> に関する記事を参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、メソッドの戻り値を調べて、その戻り値が `true`場合にのみ、クリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した場合に、呼び出し元のスレッドがクリティカルセクションのロックを解放するには、`finally` ブロックで <xref:System.Threading.Monitor.Exit%2A> を呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="timeout">ロックを待機する時間を表す <see cref="T:System.TimeSpan" />。 -1 ミリ秒という値は、無期限の待機を指定します。</param>
        <summary>指定した時間内に、指定したオブジェクトの排他ロックの取得を試みます。</summary>
        <returns>現在のスレッドがロックを取得した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ミリ秒に変換された `timeout` パラメーターの値が-1 と等しい場合、このメソッドは <xref:System.Threading.Monitor.Enter%2A>と同じです。 `timeout` の値が0の場合、このメソッドは <xref:System.Threading.Monitor.TryEnter%2A>と同じです。  
  
> [!NOTE]
>  値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 詳細については、<xref:System.Threading.Monitor> クラスに関するトピックを参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、メソッドの戻り値を調べて、その戻り値が `true`場合にのみ、クリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した場合に、呼び出し元のスレッドがクリティカルセクションのロックを解放するには、`finally` ブロックで <xref:System.Threading.Monitor.Exit%2A> を呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ミリ秒の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="millisecondsTimeout">ロックを待機するミリ秒単位の時間。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力は <see langword="false" /> でなければなりません。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。</param>
        <summary>指定したオブジェクトの排他ロックの取得を指定したミリ秒間試み、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` パラメーターが <xref:System.Threading.Timeout.Infinite>に等しい場合、このメソッドは <xref:System.Threading.Monitor.Enter%28System.Object%29>に相当します。 `millisecondsTimeout` が0の場合、このメソッドは <xref:System.Threading.Monitor.TryEnter%28System.Object%29>と同じです。  
  
 例外がスローされたためにロックが取得されなかった場合は、このメソッドの終了後に、`lockTaken` パラメーターに指定された変数が `false` ます。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。  
  
> [!NOTE]
>  値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 詳細については、<xref:System.Threading.Monitor> クラスのトピックを参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、`lockTaken` の値を調べ、その値が `true`の場合にのみクリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した場合に、呼び出し元のスレッドがクリティカルセクションのロックを解放するには、`finally` ブロックで <xref:System.Threading.Monitor.Exit%2A> を呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 次のコードは、<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> メソッドのオーバーロードを使用するための基本的なパターンを示しています。 このオーバーロードでは、メソッドが例外をスローした場合でも、`ref` パラメーター (`ByRef` Visual Basic `lockTaken`) に渡される変数の値が常に設定されます。したがって、変数の値は、ロックを解放する必要があるかどうかをテストするための信頼性の高い方法です。  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="timeout">ロックを待機する時間。 -1 ミリ秒という値は、無期限の待機を指定します。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力は <see langword="false" /> でなければなりません。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。</param>
        <summary>指定したオブジェクトの排他ロックの取得を指定した時間にわたって試み、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ミリ秒に変換された `timeout` パラメーターの値が-1 と等しい場合、このメソッドは <xref:System.Threading.Monitor.Enter%28System.Object%29>と同じです。 `timeout` の値が0の場合、このメソッドは <xref:System.Threading.Monitor.TryEnter%28System.Object%29>と同じです。  
  
 例外がスローされたためにロックが取得されなかった場合は、このメソッドの終了後に、`lockTaken` パラメーターに指定された変数が `false` ます。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。  
  
> [!NOTE]
>  値型ではなく、オブジェクト (参照型) をロックするには <xref:System.Threading.Monitor> を使用します。 詳細については、<xref:System.Threading.Monitor> クラスのトピックを参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、`lockTaken` の値を調べ、その値が `true`の場合にのみクリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した場合に、呼び出し元のスレッドがクリティカルセクションのロックを解放するには、`finally` ブロックで <xref:System.Threading.Monitor.Exit%2A> を呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ミリ秒の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。</summary>
        <returns>呼び出し元が、指定したオブジェクトのロックを再取得したために呼び出しが返された場合は <see langword="true" />。 このメソッドは、ロックが再取得されないと制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 スレッドが `Wait`を呼び出すと、オブジェクトのロックが解放され、オブジェクトの待機キューに入ります。 オブジェクトの準備完了キュー内の次のスレッド (存在する場合) は、ロックを取得し、オブジェクトを排他的に使用します。 `Wait` を呼び出すすべてのスレッドは、ロックの所有者によって送信された <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A>からのシグナルを受信するまで待機キューに保持されます。 `Pulse` が送信されると、待機キューの先頭にあるスレッドだけが影響を受けます。 `PulseAll` が送信されると、そのオブジェクトを待機しているすべてのスレッドが影響を受けます。 シグナルを受信すると、1つまたは複数のスレッドが待機キューを離れ、準備完了キューに入ります。 準備完了キュー内のスレッドは、ロックを再取得することが許可されています。  
  
 このメソッドは、呼び出し元のスレッドがオブジェクトのロックを再取得たときにを返します。 ロックの所有者が `Pulse` または `PulseAll`を呼び出さない場合、このメソッドは無期限にブロックされることに注意してください。  
  
 呼び出し元は、指定されたオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> が呼び出された回数に関係なく、一度 `Wait` を実行します。 概念的には、`Wait` メソッドは、呼び出し元がオブジェクトに対して `Enter` 呼び出した回数を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ `Exit` を呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システムは、呼び出し元に対して保存された `Enter` カウントを復元するために必要な回数だけ `Enter` を呼び出します。 を呼び出すと、指定したオブジェクトのロックのみが解放されます。 `Wait` は、呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
 同期されたオブジェクトには、現在ロックを保持しているスレッドへの参照、準備完了キューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照が保持されていることに注意してください。オブジェクトの状態が変更されたことを示す通知を待機しているスレッドを格納します。  
  
 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>、および `Wait` メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A> メソッドの解説では、スレッドが待機していないときに <xref:System.Threading.Monitor.Pulse%2A> が呼び出された場合の処理について説明します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="millisecondsTimeout">スレッドが実行待ちキューに入るまでの待機時間 (ミリ秒)。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`obj` パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、<xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを最初に呼び出さずに、別のスレッドがロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、<xref:System.Threading.Monitor.Wait%2A> メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価し、必要に応じて <xref:System.Threading.Monitor.Wait%2A> メソッドを再度呼び出します。  
  
 スレッドが `Wait`を呼び出すと、オブジェクトのロックが解放され、オブジェクトの待機キューに入ります。 オブジェクトの準備完了キュー内の次のスレッド (存在する場合) は、ロックを取得し、オブジェクトを排他的に使用します。 ロックを保持するスレッドが <xref:System.Threading.Monitor.PulseAll%2A>を呼び出すか、またはキュー内の次のスレッドが呼び出され、ロックを保持しているスレッドが <xref:System.Threading.Monitor.Pulse%2A>を呼び出すまで、`Wait` を呼び出したスレッドは待機キューに残ります。 ただし、別のスレッドがこのオブジェクトの <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを呼び出す前に `millisecondsTimeout` が経過すると、ロックを取り戻すために元のスレッドが準備完了キューに移動されます。  
  
> [!NOTE]
>  `millisecondsTimeout` パラメーターに <xref:System.Threading.Timeout.Infinite> が指定されている場合、ロックの所有者が <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A>を呼び出す場合を除き、このメソッドは無期限にブロックされます。 `millisecondsTimeout` が0の場合、`Wait` を呼び出すスレッドはロックを解放し、ロックを取り戻すためにすぐに準備完了キューに入ります。  
  
 呼び出し元は、指定されたオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> が呼び出された回数に関係なく、一度 `Wait` を実行します。 概念的には、`Wait` メソッドは、呼び出し元がオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> 呼び出した回数を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ <xref:System.Threading.Monitor.Exit%2A> を呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システムは、呼び出し元に対して保存された <xref:System.Threading.Monitor.Enter%2A> カウントを復元するために必要な回数だけ <xref:System.Threading.Monitor.Enter%2A> を呼び出します。 を呼び出すと、指定したオブジェクトのロックのみが解放されます。 `Wait` は、呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>、および `Wait` メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A> メソッドの解説では、スレッドが待機していないときに <xref:System.Threading.Monitor.Pulse%2A> が呼び出された場合の処理について説明します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> パラメーターの値が負で、<see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="timeout">スレッドが実行待ちキューに入るまでの時間を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`obj` パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、<xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを最初に呼び出さずに、別のスレッドがロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、<xref:System.Threading.Monitor.Wait%2A> メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価し、必要に応じて <xref:System.Threading.Monitor.Wait%2A> メソッドを再度呼び出します。  
  
 スレッドが `Wait`を呼び出すと、オブジェクトのロックが解放され、オブジェクトの待機キューに入ります。 オブジェクトの準備完了キュー内の次のスレッド (存在する場合) は、ロックを取得し、オブジェクトを排他的に使用します。 ロックを保持するスレッドが <xref:System.Threading.Monitor.PulseAll%2A>を呼び出すか、またはキュー内の次のスレッドが呼び出され、ロックを保持しているスレッドが <xref:System.Threading.Monitor.Pulse%2A>を呼び出すまで、`Wait` を呼び出したスレッドは待機キューに残ります。 ただし、別のスレッドがこのオブジェクトの <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを呼び出す前に `timeout` が経過すると、ロックを取り戻すために元のスレッドが準備完了キューに移動されます。  
  
> [!NOTE]
>  `timeout` パラメーターに-1 ミリ秒を表す <xref:System.TimeSpan> が指定されている場合、ロックの所有者が <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A>を呼び出す場合を除き、このメソッドは無期限にブロックします。 `timeout` が0ミリ秒の場合、`Wait` を呼び出すスレッドはロックを解放し、ロックを取り戻すためにすぐに準備完了キューに入ります。  
  
 呼び出し元は、指定されたオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> が呼び出された回数に関係なく、一度 `Wait` を実行します。 概念的には、`Wait` メソッドは、呼び出し元がオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> 呼び出した回数を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ <xref:System.Threading.Monitor.Exit%2A> を呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システムは、呼び出し元に対して保存された <xref:System.Threading.Monitor.Enter%2A> カウントを復元するために必要な回数だけ <xref:System.Threading.Monitor.Enter%2A> を呼び出します。 を呼び出すと、指定したオブジェクトのロックのみが解放されます。 `Wait` は、呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>、および `Wait` メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A> メソッドの解説では、スレッドが待機していないときに <xref:System.Threading.Monitor.Pulse%2A> が呼び出された場合の処理について説明します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> パラメーターのミリ秒単位の値が負で、かつ <see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) ではありません。または <see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="millisecondsTimeout">スレッドが実行待ちキューに入るまでの待機時間 (ミリ秒)。</param>
        <param name="exitContext">待機の前にコンテキストの同期ドメイン (同期されたコンテキストの場合) を終了および再取得する場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。 このメソッドは、コンテキストの同期ドメイン (同期されたコンテキストの場合) が待機の前に終了し、後で再取得されるかどうかも指定します。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`obj` パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、<xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを最初に呼び出さずに、別のスレッドがロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、<xref:System.Threading.Monitor.Wait%2A> メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価し、必要に応じて <xref:System.Threading.Monitor.Wait%2A> メソッドを再度呼び出します。  
  
 スレッドが `Wait`を呼び出すと、ロックが解放され、待機キューに入ります。 この時点で、準備完了キュー内の次のスレッド (存在する場合) は、ロックの制御を許可されます。 ロックを保持するスレッドが <xref:System.Threading.Monitor.PulseAll%2A>を呼び出すか、またはキュー内の次のスレッドが呼び出され、ロックを保持しているスレッドが <xref:System.Threading.Monitor.Pulse%2A>を呼び出すまで、`Wait` を呼び出したスレッドは待機キューに残ります。 ただし、別のスレッドがこのオブジェクトの <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを呼び出す前に `millisecondsTimeout` が経過すると、ロックを取り戻すために元のスレッドが準備完了キューに移動されます。  
  
> [!NOTE]
>  `millisecondsTimeout` パラメーターに <xref:System.Threading.Timeout.Infinite> が指定されている場合、ロックの所有者が <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A>を呼び出す場合を除き、このメソッドは無期限にブロックされます。 `millisecondsTimeout` が0の場合、`Wait` を呼び出すスレッドはロックを解放し、ロックを取り戻すためにすぐに準備完了キューに入ります。  
  
 呼び出し元は、指定されたオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> が呼び出された回数に関係なく、一度 `Wait` を実行します。 概念的には、`Wait` メソッドは、呼び出し元がオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> 呼び出した回数を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ <xref:System.Threading.Monitor.Exit%2A> を呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システムは、呼び出し元に対して保存された <xref:System.Threading.Monitor.Enter%2A> カウントを復元するために必要な回数だけ <xref:System.Threading.Monitor.Enter%2A> を呼び出します。 を呼び出すと、指定したオブジェクトのロックのみが解放されます。 `Wait` は、呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>、および `Wait` メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A> メソッドの解説では、スレッドが待機していないときに <xref:System.Threading.Monitor.Pulse%2A> が呼び出された場合の処理について説明します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.Monitor.Wait%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.Monitor.Wait%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 <xref:System.Threading.Monitor.Wait%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 属性が適用されている場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.Monitor.Wait%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.Monitor.Wait%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> は、同期されたコード ブロック内からは呼び出されません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> パラメーターの値が負で、<see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="timeout">スレッドが実行待ちキューに入るまでの時間を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機の前にコンテキストの同期ドメイン (同期されたコンテキストの場合) を終了および再取得する場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。 または、待機の前に同期化されたコンテキストの同期ドメインを終了し、ドメインを後で再取得します。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`obj` パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、<xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを最初に呼び出さずに、別のスレッドがロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、<xref:System.Threading.Monitor.Wait%2A> メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価し、必要に応じて <xref:System.Threading.Monitor.Wait%2A> メソッドを再度呼び出します。  
  
 スレッドが `Wait`を呼び出すと、ロックが解放され、待機キューに入ります。 この時点で、準備完了キュー内の次のスレッド (存在する場合) は、ロックの制御を許可されます。 ロックを保持するスレッドが <xref:System.Threading.Monitor.PulseAll%2A>を呼び出すか、またはキュー内の次のスレッドが呼び出され、ロックを保持しているスレッドが <xref:System.Threading.Monitor.Pulse%2A>を呼び出すまで、`Wait` を呼び出したスレッドは待機キューに残ります。 ただし、別のスレッドがこのオブジェクトの <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A> メソッドを呼び出す前に `timeout` ミリ秒が経過した場合、ロックを取り戻すために元のスレッドは準備完了キューに移動されます。  
  
> [!NOTE]
>  `timeout` パラメーターに-1 ミリ秒を表す <xref:System.TimeSpan> が指定されている場合、ロックの所有者が <xref:System.Threading.Monitor.Pulse%2A> または <xref:System.Threading.Monitor.PulseAll%2A>を呼び出す場合を除き、このメソッドは無期限にブロックします。 `timeout` が0ミリ秒の場合、`Wait` を呼び出すスレッドはロックを解放し、ロックを取り戻すためにすぐに準備完了キューに入ります。  
  
 呼び出し元は、指定されたオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> が呼び出された回数に関係なく、一度 `Wait` を実行します。 概念的には、`Wait` メソッドは、呼び出し元がオブジェクトに対して <xref:System.Threading.Monitor.Enter%2A> 呼び出した回数を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ <xref:System.Threading.Monitor.Exit%2A> を呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システムは、呼び出し元に対して保存された <xref:System.Threading.Monitor.Enter%2A> カウントを復元するために必要な回数だけ <xref:System.Threading.Monitor.Enter%2A> を呼び出します。 を呼び出すと、指定したオブジェクトのロックのみが解放されます。 `Wait` は、呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 <xref:System.Threading.Monitor.Pulse%2A>、<xref:System.Threading.Monitor.PulseAll%2A>、および `Wait` メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A> メソッドの解説では、スレッドが待機していないときに <xref:System.Threading.Monitor.Pulse%2A> が呼び出された場合の処理について説明します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.Monitor.Wait%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.Monitor.Wait%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 <xref:System.Threading.Monitor.Wait%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 属性が適用されている場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.Monitor.Wait%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.Monitor.Wait%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> は、同期されたコード ブロック内からは呼び出されません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wait を呼び出すスレッドは、後で待機状態の途中で中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> パラメーターが負で <see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) を表していないか、<see cref="F:System.Int32.MaxValue" /> よりも大きいです。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
  </Members>
</Type>
