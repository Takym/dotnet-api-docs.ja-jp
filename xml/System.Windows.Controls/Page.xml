<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata><Meta Name="ms.openlocfilehash" Value="98d57587b881b8029c8e6be50187dc3f413c32b1" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69213643" /></Metadata><TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows Internet Explorer、<see cref="T:System.Windows.Navigation.NavigationWindow" />、および <see cref="T:System.Windows.Controls.Frame" /> でナビゲーションおよびホストできるコンテンツのページをカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page>移動できるコンテンツのページをカプセル化し、次の主なメンバーを持ちます。  
  
-   **有効期間**の<xref:System.Windows.Controls.Page.KeepAlive%2A>管理:。  
  
-   **ナビゲーション**: <xref:System.Windows.Controls.Page.NavigationService%2A>。  
  
-   **外観**: <xref:System.Windows.Controls.Page.Background%2A> <xref:System.Windows.Controls.Page.Content%2A> 、<xref:System.Windows.Controls.Page.FontFamily%2A>、、 、、<xref:System.Windows.Controls.Page.Template%2A>、、 。<xref:System.Windows.Controls.Page.Title%2A> <xref:System.Windows.Controls.Page.FontSize%2A> <xref:System.Windows.Controls.Page.Foreground%2A> <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>  
  
-   **ホストウィンドウ**の外観<xref:System.Windows.Controls.Page.WindowHeight%2A>: <xref:System.Windows.Controls.Page.WindowWidth%2A>、 <xref:System.Windows.Controls.Page.WindowTitle%2A>、。  
  
 ページは、マークアップ、マークアップと分離コード、またはコードを使用して定義できます。 ページは、次の理由により、ナビゲーションのためにコンテンツをパッケージ化するために推奨される方法です。  
  
-   定義、再利用、および管理が簡単です。  
  
-   移動先の<xref:System.Windows.Navigation.NavigationService>にアクセスして使用することができます。  
  
-   [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]ホストウィンドウ (<xref:System.Windows.Controls.Page.WindowTitle%2A>、 <xref:System.Windows.Controls.Page.WindowWidth%2A>、 、<xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>)のタイトル、幅、高さ、およびナビゲーションを変更できます。 <xref:System.Windows.Controls.Page.WindowHeight%2A>  
  
-   で[!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]はデザイナーがサポートされています。  
  
 ページは<xref:System.Windows.Window> <xref:System.Windows.Navigation.NavigationWindow> 、、、、またはブラウザーからホストできます。<xref:System.Windows.Controls.Frame> ホストされるページは次のようになります。  
  
-   内<xref:System.Windows.Window> <xref:System.Windows.Navigation.NavigationWindow>の、、または<xref:System.Windows.Controls.Frame>要素の直接の子。 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]  
  
-   インスタンス化され`Content` 、、 <xref:System.Windows.Navigation.NavigationWindow>、および<xref:System.Windows.Controls.Frame>の<xref:System.Windows.Window>プロパティの値として設定されます。  
  
-   [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] `Source`またはの<xref:System.Windows.Controls.Frame>プロパティのソースとして設定します。 <xref:System.Windows.Navigation.NavigationWindow>  
  
-   スタンドアロンアプリケーション<xref:System.Windows.Application.StartupUri%2A>ではとして設定します。  
  
-   <xref:System.Windows.Application.StartupUri%2A> を[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]内のとして設定します。  
  
 通常、アプリケーションには2つ以上のページがあり、次のメカニズムを使用して移動できます。  
  
-   を使用<xref:System.Windows.Documents.Hyperlink>して宣言的に行います。  
  
-   を使用<xref:System.Windows.Navigation.NavigationService>したプログラムによる。  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]、 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 、などのホストのナビゲーションを使用して視覚的にします。<xref:System.Windows.Navigation.NavigationWindow> <xref:System.Windows.Controls.Frame>  
  
 ページ関数 (<xref:System.Windows.Navigation.PageFunction%601>) を使用した構造化ナビゲーションについては、「[構造化ナビゲーションの概要](~/docs/framework/wpf/app-development/structured-navigation-overview.md)」および「[ナビゲーショントポロジの概要](~/docs/framework/wpf/app-development/navigation-topologies-overview.md)」を参照してください。  
  
 このコントロールの依存関係のプロパティは、コントロールの既定のスタイルによって設定される可能性があります。  プロパティが既定のスタイルによって設定されている場合、アプリケーションにコントロールが表示されると、プロパティが既定値から変更されることがあります。 既定のスタイルは、アプリケーションの実行時に使用するデスクトップテーマによって決定されます。  詳しくは、「[既定の WPF テーマ](https://go.microsoft.com/fwlink/?LinkID=158252)」をご覧ください。  
  
   
  
## Examples  
 次の例は、マークアップのみを使用して標準のページを定義する方法を示しています。  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 次の例は、コードのみを使用して標準ページを定義する方法を示しています。  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 次の例は、マークアップと分離コードの組み合わせを使用して、標準のページを定義する方法を示しています。  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 が維持されていない場合 ( <xref:System.Windows.Controls.Page.KeepAlive%2A>「」を参照)、[戻る] または[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] [進む] ナビゲーション履歴でに移動したときにが新しいインスタンスを作成できるように、パラメーターなしのコンストラクターを実装する必要があります。 <xref:System.Windows.Controls.Page>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">子要素の配置に使用されるサイズ。</param>
        <summary><see cref="T:System.Windows.Controls.Page" /> のコンテンツ (子要素) を配置します。</summary>
        <returns>ページの配置後のサイズを表す <see cref="T:System.Windows.Size" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> の背景を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Media.Brush" /> の背景を描画するために使用される <see cref="T:System.Windows.Controls.Page" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|メタデータプロパティがに設定される`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、 <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Background" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Controls.Page.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> のコンテンツを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> のコンテンツが格納されるオブジェクト。 既定値は、<see cref="P:System.Windows.SystemFonts.MessageFontFamily" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 は<xref:System.Windows.Controls.Page> 、1つの子要素のみを持つことができます。 上の他のすべて<xref:System.Windows.Controls.Page>の要素は、その要素の子孫である必要があります。 通常、のコンテンツ<xref:System.Windows.Controls.Page>は、のコンテンツ<xref:System.Windows.Controls.Grid> <xref:System.Windows.Controls.StackPanel> <xref:System.Windows.Controls.DockPanel>をホストするレイアウト要素 (、、など) をホストします。<xref:System.Windows.Controls.Page>  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.ContentProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Content" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Controls.Page.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したフォント ファミリの名前を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Media.FontFamily" /> のコンテンツのフォント ファミリである <see cref="T:System.Windows.Controls.Page" />。 既定値は、<see cref="P:System.Windows.SystemFonts.MessageFontFamily" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|メタデータプロパティがに設定される`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.FontFamily" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.FontFamily%2A> 依存関係プロパティの識別子。  
  
   
  
## Examples  
 [依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Controls.Page.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォント サイズを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> のコンテンツのフォント サイズ。 既定値は、<see cref="P:System.Windows.SystemFonts.MessageFontSize" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォントサイズは、 <xref:System.Windows.SystemFonts.MessageFontSize%2A>正の数値との範囲で指定する必要があります。  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|メタデータプロパティがに設定される`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.FontSize" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.FontSize%2A> 依存関係プロパティの識別子。  
  
   
  
## Examples  
 [依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> の前景を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Media.Brush" /> の前景を描画するために使用される <see cref="T:System.Windows.Controls.Page" />。 既定値は、<see cref="P:System.Windows.Media.Brushes.Black" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|メタデータプロパティがに設定される`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Foreground" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.Foreground%2A> 依存関係プロパティの識別子。  
  
   
  
## Examples  
 [依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Windows.Controls.Page.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> のインスタンスがナビゲーション履歴に保持されるかどうかを示す値を取得または設定します。</summary>
        <value>ナビゲーション履歴に <see cref="T:System.Windows.Controls.Page" /> のインスタンスを保持する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページが最初に移動されると、 <xref:System.Windows.Controls.Page>クラスの新しいインスタンスが作成されます。 ページが (戻るまたは forward) から移動すると、ページのエントリがナビゲーション履歴に追加されます。 既定では、エントリはページオブジェクトを参照しません。 このエントリには、ページのパック URI (uniform resource identifier) が含まれています。 ページのエントリにナビゲーション履歴を使用して移動すると、そのページの新しいインスタンスを作成するためにパック URI が使用されます。 この動作は、メモリ使用量が過剰にならないようにするための既定の動作です。ページインスタンスを保持することで、特に、大量のコンテンツを含むメモリをすぐに使用できます。 この問題は、ナビゲーション履歴のバックスタックと転送スタックに格納できるエントリ数に制限がないという事実によって強化されています。 これに対して、ページのパック Uri の格納は、実質的にはメモリの消費に影響しません。  
  
 ページの新しいインスタンスを作成する主な効果は、ページのあるインスタンスから別のインスタンスにページの状態が記憶されないことです。 このような場合、Windows Presentation Foundation には、状態を記憶するためのいくつかの方法が用意されています。  
  
 ページを保持するには、 <xref:System.Windows.Controls.Page.KeepAlive%2A>プロパティをに`true`設定します (既定`false`値はです)。  
  
> [!NOTE]
>  インスタンス化され、コードのみを使用してナビゲートされる<xref:System.Windows.Navigation.NavigationService.Navigate%2A>ページ (たとえば、を呼び出す) は、自動的に保持されます。  
  
 次のことを<xref:System.Windows.Controls.Page.KeepAlive%2A>行う`true`必要がある場合を除き、をに設定しないようにしてください。  
  
-   ページに大量のコンテンツがある場合は、インスタンス化に時間がかかることがあります。 ページが保持されておらず、ページが頻繁に移動している場合は、ページを継続的にインスタンス化するコストがユーザーエクスペリエンスに悪影響を与える可能性があります。 ただし、パフォーマンスの観点からは、既定の設定を利用し、アプリケーションのパフォーマンスをプロファイリングする必要があります。アプリケーションに必要な範囲を下回る読み込み時間があるページをテストする場合は、維持されるようにページを構成することは、問題を解決する方法の1つです。  
  
> [!NOTE]
>  ユーザーがに移動してから[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]に戻ると、アクティブなままになっているページのエントリは、のナビゲーション履歴に保持されません。 保持されていないページのジャーナルエントリだけがナビゲーション履歴に保持されます。  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
> [!NOTE]
>  この依存関係プロパティのメタデータ型<xref:System.Windows.PropertyMetadata>はで<xref:System.Windows.FrameworkPropertyMetadata>あり、ではありません。  
  
   
  
## Examples  
 次の例は、を使用[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]して、 <xref:System.Windows.Controls.Page>複数のナビゲーションでクラスのインスタンスを保持する方法を示しています。  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeepAliveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.KeepAlive" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.KeepAlive%2A> 依存関係プロパティの識別子。  
  
   
  
## Examples  
 [依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.Page.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> の論理上の子要素に対する列挙子を返します。</summary>
        <value><see cref="T:System.Collections.IEnumerator" /> の論理上の子要素に対する <see cref="T:System.Windows.Controls.Page" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">ウィンドウで子に割り当てることができる領域。</param>
        <summary><see cref="T:System.Windows.Controls.Page" /> の子要素のサイズを測定します。</summary>
        <returns>ウィンドウの実際のサイズである <see cref="T:System.Windows.Size" />。 親がスクロール バーを追加する必要がある場合などは、このメソッドにより、ウィンドウの実際のサイズより大きな値が返されることがあります。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NavigationService : System.Windows.Navigation.NavigationService" Usage="System.Windows.Controls.Page.NavigationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのホストがナビゲーションの管理のために使用しているナビゲーション サービスを取得します。</summary>
        <value>ページのホストがナビゲーションの管理のために使用している <see cref="T:System.Windows.Navigation.NavigationService" /> オブジェクト。ホストがナビゲーションをサポートしない場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページは<xref:System.Windows.Window> <xref:System.Windows.Navigation.NavigationWindow>、、、 、およびブラウザーを含む複数の種類のホストによってホストできます。<xref:System.Windows.Controls.Frame>  
  
 ページ間のナビゲーションをサポートするには、多くの場合、そのホストのナビゲーションと統合する必要があります。 ただし、ページは実行時のホストの内容を認識しない場合があるため、ホストのナビゲーションメンバーに直接統合することはできません。  
  
 代わりに、ブラウザースタイルのナビゲーションをサポートし、 <xref:System.Windows.Navigation.NavigationService>クラスによってカプセル化されたサービスであるナビゲーションサービスの使用を試みることができます。 ただし、独自<xref:System.Windows.Navigation.NavigationService>のインスタンスを作成することはできません。 代わりに、、 <xref:System.Windows.Controls.Frame>、または<xref:System.Windows.Navigation.NavigationWindow>ブラウザーなどのホストの種類は、 <xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Controls.Page.NavigationService%2A>プロパティからアクセスできる独自のインスタンスを作成します。  
  
 <xref:System.Windows.Controls.Page.NavigationService%2A>プロパティから返されるナビゲーションサービスは、最初のナビゲーターによって<xref:System.Windows.Navigation.NavigationService>ビジュアルツリーに管理されるクラスのインスタンスです。 見つからない場合は、 `null`が返されます。ページのホストがナビゲーションをサポートしていないことを示します。  
  
> [!NOTE]
>  クラス<xref:System.Windows.Window>はナビゲーションをサポートしていないため、ナビゲーションサービスを提供しません。  
  
   
  
## Examples  
 次の例は、ナビゲーションサービスが使用可能かどうかを確認する方法を示しています。その場合は、ページを使用して前のページに戻ることができます。  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit&#xA;override this.OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit" Usage="page.OnTemplateChanged (oldTemplate, newTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">古いテンプレート。</param>
        <param name="newTemplate">新しいテンプレート。</param>
        <summary><see cref="T:System.Windows.Controls.Page" /> のテンプレートが変更されたときに呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下を参照してください。<xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="page.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">直前の親。 <see cref="T:System.Windows.DependencyObject" /> の直前の親がなかった場合は <see langword="null" /> に設定されます。</param>
        <summary><see cref="T:System.Windows.Controls.Page" /> の親が変更されると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">新しい親が <see cref="T:System.Windows.Window" /> でも <see cref="T:System.Windows.Controls.Frame" /> でもありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeShowsNavigationUI : unit -&gt; bool" Usage="page.ShouldSerializeShowsNavigationUI " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに対し、<see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> プロパティのシリアル化動作の決定を許可します。</summary>
        <returns>コンテンツをシリアル化する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTitle : unit -&gt; bool" Usage="page.ShouldSerializeTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに対し、<see cref="P:System.Windows.Controls.Page.Title" /> プロパティのシリアル化動作の決定を許可します。</summary>
        <returns>コンテンツをシリアル化する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowHeight : unit -&gt; bool" Usage="page.ShouldSerializeWindowHeight " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに対し、<see cref="P:System.Windows.Controls.Page.WindowHeight" /> プロパティのシリアル化動作の決定を許可します。</summary>
        <returns>コンテンツをシリアル化する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowTitle : unit -&gt; bool" Usage="page.ShouldSerializeWindowTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに対し、<see cref="P:System.Windows.Controls.Page.WindowTitle" /> プロパティのシリアル化動作の決定を許可します。</summary>
        <returns>コンテンツをシリアル化する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowWidth : unit -&gt; bool" Usage="page.ShouldSerializeWindowWidth " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスに対し、<see cref="P:System.Windows.Controls.Page.WindowWidth" /> プロパティのシリアル化動作の決定を許可します。</summary>
        <returns>コンテンツをシリアル化する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowsNavigationUI : bool with get, set" Usage="System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] の <see cref="T:System.Windows.Navigation.NavigationWindow" /> のナビゲーション [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] を表示するかどうかを示す値を取得または設定します。</summary>
        <value>ホスト <see cref="T:System.Windows.Navigation.NavigationWindow" /> のナビゲーション [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] が表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow>ブラウザースタイル[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]の転送と後方ナビゲーションを有効にするために、既定でナビゲーションを表示します。 ページがとして設定さ<xref:System.Windows.Application.StartupUri%2A>れ<xref:System.Windows.Application>ている場合<xref:System.Windows.Navigation.NavigationWindow> 、は、でページをホストするためにを自動的に開きます。 ページで既定<xref:System.Windows.Navigation.NavigationWindow>のナビゲーション[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]を使用しない場合は、をに`false`設定<xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>できます。  
  
> [!NOTE]
>  は[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]のナビゲーション[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]と統合されない[!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)]ため、を設定<xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>して[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]表示または非表示にできる独自のナビゲーションを提供します。 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]は[!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)]ナビゲーション[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]と統合します。その<xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>ため、の[!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)]ページを設定しても効果はありません。  
  
   
  
## Examples  
 次の例は、を使用[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]しての<xref:System.Windows.Navigation.NavigationWindow>ナビゲーション[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]を非表示にする方法を示しています。  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" />、<see cref="T:System.Windows.Controls.Page" />、またはブラウザーでホストされていない <see cref="T:System.Windows.Window" /> インスタンスで <see cref="T:System.Windows.Navigation.NavigationWindow" /> プロパティが検査されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">追加する子オブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Windows.Controls.Page> のインスタンスが <xref:System.Windows.Markup.IAddChild> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">オブジェクトに追加するテキスト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Windows.Controls.Page> のインスタンスが <xref:System.Windows.Markup.IAddChild> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Template : System.Windows.Controls.ControlTemplate with get, set" Usage="System.Windows.Controls.Page.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> のコントロール テンプレートを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Controls.ControlTemplate" /> の <see cref="T:System.Windows.Controls.Page" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>XAML 値  
 *resourceExtension*  
 テンプレートリソースを参照する方法を示すマークアップ拡張機能 ( `StaticResource`また`DynamicResource`は)。 「 [XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
 *styleResourceKey*  
 要求されたテンプレートセレクターを識別するキー。 キーは、 <xref:System.Windows.ResourceDictionary>内の既存のリソースを参照します。  
  
> [!NOTE]
>  Property 要素の構文は技術的には可能ですが、推奨されません。 詳細については、「[インラインスタイルとテンプレート](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)」を参照してください。  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|メタデータプロパティがに設定される`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Template" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Controls.Page.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> のタイトルを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> のタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.Title%2A>プロパティの値はによって<xref:System.Windows.Controls.Page>表示されません。また、を<xref:System.Windows.Controls.Page>ホストしているウィンドウのタイトルバーにも表示されません。 代わりに、を設定<xref:System.Windows.Controls.Page.WindowTitle%2A>してホストウィンドウのタイトルを変更します。  
  
 <xref:System.Windows.Controls.Page.Title%2A>は、移動したコンテンツのナビゲーション履歴エントリの名前を生成するためにも使用できます。 次のデータは、ナビゲーション履歴エントリの名前を優先順位に従って自動的に構築するために使用されます。  
  
-   添付<xref:System.Windows.Navigation.JournalEntry.Name%2A>属性。  
  
-   <xref:System.Windows.Controls.Page.Title%2A> プロパティ。  
  
-   現在のページ[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]のプロパティと。<xref:System.Windows.Controls.Page.WindowTitle%2A>  
  
-   現在のページの [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]。  
  
 ナビゲーション履歴でオブジェクトを<xref:System.Windows.Navigation.CustomContentState>コンテンツに関連付けた場合は、をオーバーライド<xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>することによって、ナビゲーション履歴エントリに表示される名前を指定できます。  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールド|<xref:System.Windows.Controls.Page.TitleProperty>|  
|メタデータプロパティがに設定される`true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Title" /> 依存関係プロパティを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.Title%2A> 依存関係プロパティの識別子。  
  
   
  
## Examples  
 [依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : double with get, set" Usage="System.Windows.Controls.Page.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" /> のホスト <see cref="T:System.Windows.Navigation.NavigationWindow" /> または <see cref="T:System.Windows.Controls.Page" /> の高さを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> を直接ホストするウィンドウの高さ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A>は、 <xref:System.Windows.Controls.Page>がウィンドウによって直接ホストされている場合にのみ適用されます。これには次のものが含まれます。  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 がによってホストされて<xref:System.Windows.Controls.Page.WindowHeight%2A>いる場合<xref:System.Windows.Controls.Page.WindowHeight%2A>、を設定しても効果はありませんが、の値を取得することはできます。 <xref:System.Windows.Controls.Frame> <xref:System.Windows.Controls.Page>  
  
 <xref:System.Windows.Controls.Page> <xref:System.Windows.FrameworkElement.Height%2A> <xref:System.Windows.FrameworkElement.MinHeight%2A> <xref:System.Windows.Controls.Page.WindowHeight%2A> [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]のは<xref:System.Windows.FrameworkElement.MaxHeight%2A>、を使用しての高さを変更する場合にのみ使用できます。高さは、、、またはを設定して変更することはできません。[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]  
  
 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]ウィンドウの高さの最小値は150ピクセルです。 ブラウザーでホストされているページの場合、 <xref:System.Windows.Controls.Page.WindowHeight%2A> [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]ウィンドウの高さの合計が150ピクセル未満になると、の値が適用されないことを意味します。  
  
   
  
## Examples  
 次の例は、ページからウィンドウの高さを設定する方法を示しています。  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTitle : string with get, set" Usage="System.Windows.Controls.Page.WindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" /> のホスト <see cref="T:System.Windows.Navigation.NavigationWindow" /> またはホスト <see cref="T:System.Windows.Controls.Page" /> のタイトルを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> を直接ホストするウィンドウのタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、および<xref:System.Windows.Navigation.NavigationWindow> [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]を含む、ページをホストするウィンドウのタイトルは、現在ホストされているファイルの名前です (ページがゆるん[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]でいる場合は .xaml 拡張子、ページがに[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]含まれている場合は拡張子はxbapです)。).  
  
 ページでは、 <xref:System.Windows.Controls.Page.WindowTitle%2A>プロパティを設定することによって既定値を変更できます。  
  
 ページによってウィンドウのタイトルがこのように設定されると、別の値を持つ別のページ<xref:System.Windows.Controls.Page.WindowTitle%2A>が設定されるまで、ウィンドウのタイトルは変わりません。  
  
> [!NOTE]
>  は<xref:System.Windows.Controls.Page> 、に影響を与えるため<xref:System.Windows.Controls.Page.WindowTitle%2A>に、ウィンドウ内の最上位のコンテンツである必要<xref:System.Windows.Controls.Page>があります。 <xref:System.Windows.Controls.Frame>がでホストされ<xref:System.Windows.Controls.Page.WindowTitle%2A>ている場合、たとえば、を設定すると、ホストウィンドウのタイトルが変更されません。  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A>は、移動したコンテンツのナビゲーション履歴エントリの名前を生成するためにも使用できます。 次のデータは、ナビゲーション履歴エントリの名前を優先順位に従って自動的に構築するために使用されます。  
  
-   添付<xref:System.Windows.Navigation.JournalEntry.Name%2A>属性。  
  
-   <xref:System.Windows.Controls.Page.Title%2A> プロパティ。  
  
-   現在のページ[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]のプロパティと。<xref:System.Windows.Controls.Page.WindowTitle%2A>  
  
-   現在のページの [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]。  
  
 ナビゲーション履歴でオブジェクトを<xref:System.Windows.Navigation.CustomContentState>コンテンツに関連付けた場合は、をオーバーライド<xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>して、ナビゲーション履歴要素の名前の値を指定できます。  
  
   
  
## Examples  
 次の例では、ページからウィンドウのタイトルを設定する方法を示します。  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : double with get, set" Usage="System.Windows.Controls.Page.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" /> のホスト <see cref="T:System.Windows.Navigation.NavigationWindow" /> または <see cref="T:System.Windows.Controls.Page" /> の幅を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> を直接ホストするウィンドウの幅。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A>は、 <xref:System.Windows.Controls.Page>がウィンドウによって直接ホストされている場合にのみ適用されます。これには次のものが含まれます。  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 がによってホストされて<xref:System.Windows.Controls.Page.WindowWidth%2A>いる場合<xref:System.Windows.Controls.Page.WindowWidth%2A>、を設定しても効果はありませんが、の値を取得することはできます。 <xref:System.Windows.Controls.Frame> <xref:System.Windows.Controls.Page>  
  
 <xref:System.Windows.Controls.Page> <xref:System.Windows.FrameworkElement.Width%2A> <xref:System.Windows.FrameworkElement.MinWidth%2A> <xref:System.Windows.Controls.Page.WindowWidth%2A> [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]のは<xref:System.Windows.FrameworkElement.MaxWidth%2A>、を使用しての幅を変更する場合にのみ使用できます。幅は、、、またはを設定して変更することはできません。[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]  
  
 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]ウィンドウの幅の最小値は250ピクセルです。 ブラウザーでホストされているページの場合、 <xref:System.Windows.Controls.Page.WindowWidth%2A> [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]ウィンドウの合計幅が250ピクセル未満になると、の値が適用されないことを意味します。  
  
   
  
## Examples  
 次の例は、ページからウィンドウの幅を設定する方法を示しています。  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
